<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiaosolll.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.2.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta name="description" content="分离适配malloclab分离适配分配器维护着一个空闲链表的数组。每个空闲链表是和一个大小类相关联的，并且被组织称某种类型的显示或隐式链接。 每个链表包含潜在的大小不同的块。这些块的大小是大小类的成员。  大小类:所有可能的块分成一些等价类。 每个大小类一个空闲链表，按照大小的升序排列。  分离适配如何分配一个块1.确定请求的大小类 2.对适当的空闲链表做首次适配，查找一个合适的块。 有合适的块：">
<meta property="og:type" content="article">
<meta property="og:title" content="malloclab2">
<meta property="og:url" content="https://xiaosolll.github.io/2021/02/28/malloclab2/index.html">
<meta property="og:site_name" content="Antinomy">
<meta property="og:description" content="分离适配malloclab分离适配分配器维护着一个空闲链表的数组。每个空闲链表是和一个大小类相关联的，并且被组织称某种类型的显示或隐式链接。 每个链表包含潜在的大小不同的块。这些块的大小是大小类的成员。  大小类:所有可能的块分成一些等价类。 每个大小类一个空闲链表，按照大小的升序排列。  分离适配如何分配一个块1.确定请求的大小类 2.对适当的空闲链表做首次适配，查找一个合适的块。 有合适的块：">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210228152236270.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210228134715629.png#pic_center">
<meta property="article:published_time" content="2021-02-28T05:53:21.000Z">
<meta property="article:modified_time" content="2021-02-28T15:01:58.439Z">
<meta property="article:author" content="eetan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20210228152236270.png#pic_center">


<link rel="canonical" href="https://xiaosolll.github.io/2021/02/28/malloclab2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>malloclab2 | Antinomy</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Antinomy</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E9%80%82%E9%85%8Dmalloclab"><span class="nav-number">1.</span> <span class="nav-text">分离适配malloclab</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E9%80%82%E9%85%8D"><span class="nav-number">1.0.1.</span> <span class="nav-text">分离适配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E9%80%82%E9%85%8D%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%E5%9D%97"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">分离适配如何分配一个块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E9%80%82%E9%85%8D%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96mm-init"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">分离适配空闲链表初始化mm_init()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%A0%86extend-heap"><span class="nav-number">1.0.1.3.</span> <span class="nav-text">扩展堆extend_heap()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%A0%86mm-malloc"><span class="nav-number">1.0.1.4.</span> <span class="nav-text">分配堆mm_malloc()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E5%A0%86free"><span class="nav-number">1.0.1.5.</span> <span class="nav-text">释放堆free()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E9%80%82%E5%90%88%E5%9D%97first-fit"><span class="nav-number">1.0.1.6.</span> <span class="nav-text">寻找适合块first_fit()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%9D%97%E7%A9%BA%E9%97%B4place"><span class="nav-number">1.0.1.7.</span> <span class="nav-text">放置请求块空间place()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%8B%E5%8D%B3%E5%90%88%E5%B9%B6immediate-coalesce"><span class="nav-number">1.0.1.8.</span> <span class="nav-text">立即合并immediate_coalesce()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8Drealloc"><span class="nav-number">1.0.1.9.</span> <span class="nav-text">重新分配realloc()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E5%90%88%E5%87%BD%E6%95%B0"><span class="nav-number">1.0.1.10.</span> <span class="nav-text">配合函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Index"><span class="nav-number">1.0.1.10.1.</span> <span class="nav-text">Index</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#add-block"><span class="nav-number">1.0.1.10.2.</span> <span class="nav-text">add_block</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#delete-block"><span class="nav-number">1.0.1.10.3.</span> <span class="nav-text">delete_block</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#error"><span class="nav-number">1.0.1.11.</span> <span class="nav-text">error</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eetan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/02/28/malloclab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          malloclab2
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-02-28 13:53:21 / Modified: 23:01:58" itemprop="dateCreated datePublished" datetime="2021-02-28T13:53:21+08:00">2021-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="分离适配malloclab"><a href="#分离适配malloclab" class="headerlink" title="分离适配malloclab"></a>分离适配malloclab</h1><h3 id="分离适配"><a href="#分离适配" class="headerlink" title="分离适配"></a>分离适配</h3><p>分配器维护着一个空闲链表的数组。每个空闲链表是和一个大小类相关联的，并且被组织称某种类型的显示或隐式链接。 每个链表包含潜在的大小不同的块。这些块的大小是大小类的成员。</p>
<blockquote>
<p>大小类:所有可能的块分成一些等价类。</p>
<p>每个大小类一个空闲链表，按照大小的升序排列。</p>
</blockquote>
<h4 id="分离适配如何分配一个块"><a href="#分离适配如何分配一个块" class="headerlink" title="分离适配如何分配一个块"></a>分离适配如何分配一个块</h4><p>1.确定请求的大小类</p>
<p>2.对适当的空闲链表做首次适配，查找一个合适的块。</p>
<p>有合适的块：（可选地）分割，将剩余部分插入到空闲链表中。</p>
<p>没有合适的块：<strong>搜索下一个更大地大小类的空闲链表。</strong></p>
<p>最终没有合适的块:  向操作系统请求额外地堆内存，从新的堆内存中分配出一个块，将剩余部分放置在适当地大小类中。</p>
<blockquote>
<p>分离适配的基本思想就是将所有空闲块分成大小类，分别分成0-8，9-16，17-32，33-64，65-128，…… ，2049-4096，4097-正无穷，这么几个大小类的空闲链表，然后我们想要进行malloc的时候，就将空闲块进行筛选，将其分到对应的大小块中进行搜索，这样就可以将malloc搜索块的时间从所有空的空闲块降低到局部链表的空闲块中，提高了效率。</p>
</blockquote>
<h4 id="分离适配空闲链表初始化mm-init"><a href="#分离适配空闲链表初始化mm-init" class="headerlink" title="分离适配空闲链表初始化mm_init()"></a>分离适配空闲链表初始化mm_init()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int mm_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    if((heap_listp &#x3D; mem_sbrk(14 * WSIZE)) &#x3D;&#x3D; (void *)-1) return -1;</span><br><span class="line">    PUT(heap_listp, 0);             </span><br><span class="line">    PUT(heap_listp + (1*WSIZE), NULL); &#x2F;&#x2F;  8-16</span><br><span class="line">    PUT(heap_listp + (2*WSIZE), NULL); &#x2F;&#x2F;  16-32</span><br><span class="line">    PUT(heap_listp + (3*WSIZE), NULL); &#x2F;&#x2F;  32-64</span><br><span class="line">    PUT(heap_listp + (4*WSIZE), NULL); &#x2F;&#x2F;  64-128</span><br><span class="line">    PUT(heap_listp + (5*WSIZE), NULL); &#x2F;&#x2F;  128-256</span><br><span class="line">    PUT(heap_listp + (6*WSIZE), NULL); &#x2F;&#x2F;  256-512</span><br><span class="line">    PUT(heap_listp + (7*WSIZE), NULL); &#x2F;&#x2F;  512-1024</span><br><span class="line">    PUT(heap_listp + (8*WSIZE), NULL); &#x2F;&#x2F;  1024-2048</span><br><span class="line">    PUT(heap_listp + (9*WSIZE), NULL);&#x2F;&#x2F;  2048-4096</span><br><span class="line">    PUT(heap_listp + (10*WSIZE), NULL);&#x2F;&#x2F;  4096--</span><br><span class="line"></span><br><span class="line">    PUT(heap_listp + (11*WSIZE), PACK(DSIZE, 1));</span><br><span class="line">    PUT(heap_listp + (12*WSIZE), PACK(DSIZE, 1));</span><br><span class="line">    PUT(heap_listp + (13*WSIZE), PACK(0, 1));</span><br><span class="line">    list_table &#x3D; heap_listp;</span><br><span class="line">    heap_listp +&#x3D; (12*WSIZE);</span><br><span class="line"></span><br><span class="line">    if(extend_heap(CHUNKSIZE&#x2F;WSIZE) &#x3D;&#x3D; NULL) return -1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CHUNKSIZE (1&lt;&lt;12)：每次扩展堆大小。</p>
</blockquote>
<p>mem_sbrk由memlib.c封装。</p>
<p>扩展堆，以incr字节为单位，并返回新区域的起始地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void *mem_sbrk(int incr) </span><br><span class="line">&#123;</span><br><span class="line">char *old_brk &#x3D; mem_brk;</span><br><span class="line"></span><br><span class="line">if ( (incr &lt; 0) || ((mem_brk + incr) &gt; mem_max_addr)) &#123;</span><br><span class="line">errno &#x3D; ENOMEM;</span><br><span class="line">fprintf(stderr, &quot;ERROR: mem_sbrk failed. Ran out of memory...\n&quot;);</span><br><span class="line">return (void *)-1;</span><br><span class="line">&#125;</span><br><span class="line">mem_brk +&#x3D; incr;</span><br><span class="line">return (void *)old_brk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>PUT(P,VAL)—将值压入p指向的字</p>
</blockquote>
<p>初始化14个put将所有空闲块分成大小类。</p>
<blockquote>
<p>PACK(size, alloc) ((size) | (alloc))—-将块大小和标志位整合到一个字中</p>
</blockquote>
<blockquote>
<p> PUT(heap_listp + (11<em>WSIZE), PACK(DSIZE, 1));//序言块头部<br> PUT(heap_listp + (12</em>WSIZE), PACK(DSIZE, 1));//序言块尾部<br> PUT(heap_listp + (13*WSIZE), PACK(0, 1));//结尾块</p>
</blockquote>
<p>序言块是两个八字节的已分配块，一部分是头部，一部分是尾部。</p>
<p>结尾块是一个大小为0的已分配块。</p>
<p><img src="https://img-blog.csdnimg.cn/20210228152236270.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="扩展堆extend-heap"><a href="#扩展堆extend-heap" class="headerlink" title="扩展堆extend_heap()"></a>扩展堆extend_heap()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void *extend_heap(size_t words)&#123;</span><br><span class="line">    char *bp;</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    size  &#x3D; (words % 2)?(words+1)*WSIZE:words*WSIZE;</span><br><span class="line">    if((long)(bp &#x3D; mem_sbrk(size)) &#x3D;&#x3D; -1) return NULL;</span><br><span class="line">    PUT(HDRP(bp), PACK(size, 0));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, 0));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1));</span><br><span class="line">    PUT(PREV_LINKED_BLKP(bp), NULL);</span><br><span class="line">    PUT(NEXT_LINKED_BLKP(bp), NULL);</span><br><span class="line"></span><br><span class="line">    return immediate_coalesce(bp);&#x2F;&#x2F;立即合并</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拓展堆的可用空间，返回原堆顶地址(mem_brk),失败返回NULL</p>
<h4 id="分配堆mm-malloc"><a href="#分配堆mm-malloc" class="headerlink" title="分配堆mm_malloc()"></a>分配堆mm_malloc()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void *mm_malloc(size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    size_t asize;</span><br><span class="line">    size_t extendsize;</span><br><span class="line">    char *bp;</span><br><span class="line"></span><br><span class="line">    if(size &#x3D;&#x3D; 0)  return  NULL;</span><br><span class="line"></span><br><span class="line">    if(size &lt;&#x3D; DSIZE) asize  &#x3D; 2 * DSIZE;</span><br><span class="line">    else asize &#x3D; DSIZE * ((size + (DSIZE) + (DSIZE - 1))&#x2F;DSIZE);</span><br><span class="line"></span><br><span class="line">    if((bp &#x3D; first_fit(asize)) !&#x3D; NULL)&#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        return bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    extendsize &#x3D; MAX(asize, CHUNKSIZE);</span><br><span class="line">    if((bp &#x3D; extend_heap(extendsize&#x2F;WSIZE)) &#x3D;&#x3D; NULL) return NULL;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    return bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="释放堆free"><a href="#释放堆free" class="headerlink" title="释放堆free()"></a>释放堆free()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void mm_free(void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    if(ptr &#x3D;&#x3D; NULL) return;</span><br><span class="line">    size_t size &#x3D; GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, 0));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, 0));</span><br><span class="line">    PUT(PREV_LINKED_BLKP(ptr), NULL);</span><br><span class="line">    PUT(NEXT_LINKED_BLKP(ptr), NULL);</span><br><span class="line">    immediate_coalesce(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="寻找适合块first-fit"><a href="#寻找适合块first-fit" class="headerlink" title="寻找适合块first_fit()"></a>寻找适合块first_fit()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void *first_fit(size_t asize)&#123;</span><br><span class="line">    int index &#x3D; Index(asize);</span><br><span class="line">    for(;index&lt;&#x3D;10;index++)&#123;</span><br><span class="line">        char *st &#x3D; GET(list_table+(index*WSIZE));</span><br><span class="line">        while(st!&#x3D;NULL)&#123;</span><br><span class="line">            if(GET_SIZE(HDRP(st)) &gt;&#x3D; asize) return st;</span><br><span class="line">            st &#x3D; GET(NEXT_LINKED_BLKP(st));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>GET(P)—-返回p指向的字</p>
</blockquote>
<p>通过index函数得到是哪个大小类，for函数从小到大找合适的大小类。</p>
<h4 id="放置请求块空间place"><a href="#放置请求块空间place" class="headerlink" title="放置请求块空间place()"></a>放置请求块空间place()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void place(void *bp, size_t asize)&#123;</span><br><span class="line">    size_t newsize &#x3D; GET_SIZE(HDRP(bp)) - asize;</span><br><span class="line">    if(newsize &gt;&#x3D; 2*DSIZE)&#123;</span><br><span class="line">        delete_block(bp, GET_SIZE(HDRP(bp)));</span><br><span class="line">        PUT(HDRP(bp), PACK(asize, 1));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize, 1));</span><br><span class="line"></span><br><span class="line">        bp&#x3D;NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp), PACK(newsize, 0));</span><br><span class="line">        PUT(FTRP(bp), PACK(newsize, 0));</span><br><span class="line">        PUT(PREV_LINKED_BLKP(bp), NULL);</span><br><span class="line">        PUT(NEXT_LINKED_BLKP(bp), NULL);</span><br><span class="line">        add_block(bp, newsize);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        delete_block(bp, GET_SIZE(HDRP(bp)));</span><br><span class="line">        PUT(HDRP(bp), PACK(GET_SIZE(HDRP(bp)), 1));</span><br><span class="line">        PUT(FTRP(bp), PACK(GET_SIZE(HDRP(bp)), 1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放置请求块，请求块可能小于大小类中找到的适合块，也可能等于适合块。</p>
<p>newsize得到请求块和适合块的差值。通过if-else函数，分别处理不同情况。差值大于等于两字，则进行块切割。否则将整个适合块给请求块。</p>
<p>if中将适合块分成两部分，对请求块进行已分配头尾设定，对遗留的适合块空间进行add_block()。</p>
<h4 id="立即合并immediate-coalesce"><a href="#立即合并immediate-coalesce" class="headerlink" title="立即合并immediate_coalesce()"></a>立即合并immediate_coalesce()</h4><p>合并bp指向块的前后块,返回合并后的块指针。</p>
<p>（扩展和释放）（realloc）时需要调用这个函数。</p>
<p>传入的bp是需要合并的块的块指针。mm_free(void *ptr)中immediate_coalesce(ptr)将释放的块并入空闲链表中。</p>
<p>NEXT_BLKP(bp)：<em>返回当前块的下一块</em></p>
<p>PREV_BLKP(bp)：<em>返回但前块的上一块</em></p>
<p>#define HDRP(bp)    ((char *)bp - WSIZE)                <em>//返回块的头部</em></p>
<p>#define FTRP(bp)    ((char *)bp + GET_SIZE(bp) - DSIZE)                <em>//返回块的尾部</em></p>
<p>GET_ALLOC(p)    // 获得标志位</p>
<p>首先获得bp前后块的标志位。根据前后块标志位的情况进行条件选择合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void *immediate_coalesce(void *bp)&#123;</span><br><span class="line">    size_t prev_alloc &#x3D; GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    size_t next_alloc &#x3D; GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    size_t size &#x3D; GET_SIZE(HDRP(bp));&#x2F;&#x2F;返回头或尾部的高29位,即该块的大小</span><br><span class="line"></span><br><span class="line">    if(prev_alloc &amp;&amp; next_alloc)&#123;</span><br><span class="line">        add_block(bp, GET_SIZE(HDRP(bp)));</span><br><span class="line">        return bp;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(prev_alloc &amp;&amp; !next_alloc)&#123;</span><br><span class="line">        delete_block(NEXT_BLKP(bp), GET_SIZE(HDRP(NEXT_BLKP(bp))));</span><br><span class="line">        size +&#x3D; GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, 0));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, 0));</span><br><span class="line">        PUT(PREV_LINKED_BLKP(bp), NULL);</span><br><span class="line">        PUT(NEXT_LINKED_BLKP(bp), NULL);</span><br><span class="line">        add_block(bp, size);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!prev_alloc &amp;&amp; next_alloc)&#123;</span><br><span class="line">        delete_block(PREV_BLKP(bp), GET_SIZE(HDRP(PREV_BLKP(bp))));</span><br><span class="line">        size +&#x3D; GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, 0));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));</span><br><span class="line">        bp &#x3D; PREV_BLKP(bp);</span><br><span class="line">        PUT(PREV_LINKED_BLKP(bp), NULL);</span><br><span class="line">        PUT(NEXT_LINKED_BLKP(bp), NULL);</span><br><span class="line">        add_block(bp, size);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        delete_block(PREV_BLKP(bp), GET_SIZE(HDRP(PREV_BLKP(bp))));</span><br><span class="line">        delete_block(NEXT_BLKP(bp), GET_SIZE(HDRP(NEXT_BLKP(bp))));</span><br><span class="line">        size +&#x3D; GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0));</span><br><span class="line">        bp &#x3D; PREV_BLKP(bp);</span><br><span class="line">        PUT(PREV_LINKED_BLKP(bp), NULL);</span><br><span class="line">        PUT(NEXT_LINKED_BLKP(bp), NULL);</span><br><span class="line">        add_block(bp, size);</span><br><span class="line">    &#125;</span><br><span class="line">    return bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重新分配realloc"><a href="#重新分配realloc" class="headerlink" title="重新分配realloc()"></a>重新分配realloc()</h4><p>传入块的指针和希望的大小，对情况分别进行选择。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">void *mm_realloc(void *ptr, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    if(ptr &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">        return mm_malloc(size);</span><br><span class="line">    &#125;</span><br><span class="line">    if(size &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        mm_free(ptr);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t asize;</span><br><span class="line">    if(size &lt;&#x3D; DSIZE) asize  &#x3D; 2 * DSIZE;</span><br><span class="line">    else asize &#x3D; DSIZE * ((size + (DSIZE) + (DSIZE - 1))&#x2F;DSIZE);</span><br><span class="line"></span><br><span class="line">    size_t oldsize &#x3D; GET_SIZE(HDRP(ptr));</span><br><span class="line">    if(oldsize &#x3D;&#x3D; asize) return ptr;</span><br><span class="line">    else if(oldsize &gt; asize)&#123;</span><br><span class="line">        if(oldsize - asize&gt;&#x3D;2*DSIZE)&#123;</span><br><span class="line">            PUT(HDRP(ptr), PACK(asize, 1));</span><br><span class="line">            PUT(FTRP(ptr), PACK(asize, 1));</span><br><span class="line">            void *bp &#x3D; ptr;</span><br><span class="line">            bp &#x3D; NEXT_BLKP(bp);</span><br><span class="line">            PUT(HDRP(bp), PACK(oldsize - asize, 0));</span><br><span class="line">            PUT(FTRP(bp), PACK(oldsize - asize, 0));</span><br><span class="line">            PUT(PREV_LINKED_BLKP(bp), NULL);</span><br><span class="line">            PUT(NEXT_LINKED_BLKP(bp), NULL);</span><br><span class="line"></span><br><span class="line">            immediate_coalesce(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            PUT(HDRP(ptr), PACK(oldsize, 1));</span><br><span class="line">            PUT(FTRP(ptr), PACK(oldsize, 1));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;immediate or delay</span><br><span class="line">        return ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        size_t next_alloc &#x3D; GET_ALLOC(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">        if(!next_alloc &amp;&amp; GET_SIZE(HDRP(NEXT_BLKP(ptr))) + oldsize &gt;&#x3D; asize) &#123;</span><br><span class="line">            delete_block(NEXT_BLKP(ptr), GET_SIZE(HDRP(NEXT_BLKP(ptr))));</span><br><span class="line">            size_t ssize &#x3D; GET_SIZE(HDRP(NEXT_BLKP(ptr))) + oldsize;</span><br><span class="line">            size_t last &#x3D; ssize - asize;</span><br><span class="line">            if(last &gt;&#x3D; 2*DSIZE)&#123;</span><br><span class="line">                PUT(HDRP(ptr), PACK(asize, 1));</span><br><span class="line">                PUT(FTRP(ptr), PACK(asize, 1));</span><br><span class="line">                char *bp &#x3D; NEXT_BLKP(ptr);</span><br><span class="line">                PUT(HDRP(bp), PACK(last, 0));</span><br><span class="line">                PUT(FTRP(bp), PACK(last, 0));</span><br><span class="line">                PUT(NEXT_LINKED_BLKP(bp), NULL);</span><br><span class="line">                PUT(PREV_LINKED_BLKP(bp), NULL);</span><br><span class="line">                add_block(bp, last);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                PUT(HDRP(ptr), PACK(ssize, 1));</span><br><span class="line">                PUT(FTRP(ptr), PACK(ssize, 1));</span><br><span class="line">            &#125;</span><br><span class="line">            return ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            char *newptr &#x3D; mm_malloc(asize);</span><br><span class="line">            if(newptr &#x3D;&#x3D; NULL) return NULL;</span><br><span class="line">            memcpy(newptr, ptr, oldsize - DSIZE);</span><br><span class="line">            mm_free(ptr);</span><br><span class="line">            return newptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="配合函数"><a href="#配合函数" class="headerlink" title="配合函数"></a>配合函数</h4><h5 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h5><p>用来确定是哪个大小类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Index(size_t asize)&#123;</span><br><span class="line">    int ret&#x3D;0;</span><br><span class="line">    if(asize&gt;&#x3D;4096) return 10;</span><br><span class="line">    while(asize)&#123;</span><br><span class="line">        asize&#x2F;&#x3D;2;</span><br><span class="line">        ret++;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret-3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="add-block"><a href="#add-block" class="headerlink" title="add_block"></a>add_block</h5><p>处理切割后遗留的块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void add_block(void *bp, size_t asize)&#123;</span><br><span class="line">    int index &#x3D; Index(asize);</span><br><span class="line">    if(GET(list_table+(index*WSIZE))&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        PUT(list_table+(index*WSIZE), bp);</span><br><span class="line">        PUT(PREV_LINKED_BLKP(bp), list_table+(index*WSIZE));</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        char *pre &#x3D; list_table+(index*WSIZE);</span><br><span class="line">        char *st &#x3D; GET(pre);</span><br><span class="line">        while(st!&#x3D;NULL&amp;&amp;st&lt;bp)&#123;</span><br><span class="line">            pre&#x3D;st;</span><br><span class="line">            st &#x3D; GET(NEXT_LINKED_BLKP(st));</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre!&#x3D;list_table+(index*WSIZE))&#123;</span><br><span class="line">            PUT(PREV_LINKED_BLKP(bp),pre);</span><br><span class="line">            PUT(NEXT_LINKED_BLKP(bp),st);</span><br><span class="line">            PUT(NEXT_LINKED_BLKP(pre),bp);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            PUT(PREV_LINKED_BLKP(bp),pre);</span><br><span class="line">            PUT(NEXT_LINKED_BLKP(bp),st);</span><br><span class="line">            PUT(pre,bp);</span><br><span class="line">        &#125;</span><br><span class="line">        if(st!&#x3D;NULL) PUT(PREV_LINKED_BLKP(st), bp);</span><br><span class="line">        &#x2F;&#x2F; char *st &#x3D; GET(list_table+(index*WSIZE));</span><br><span class="line">        &#x2F;&#x2F; PUT(list_table+(index*WSIZE), bp);</span><br><span class="line">        &#x2F;&#x2F; PUT(NEXT_LINKED_BLKP(bp), st);</span><br><span class="line">        &#x2F;&#x2F; PUT(PREV_LINKED_BLKP(bp), list_table+(index*WSIZE));</span><br><span class="line">        &#x2F;&#x2F; PUT(PREV_LINKED_BLKP(st), bp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="delete-block"><a href="#delete-block" class="headerlink" title="delete_block"></a>delete_block</h5><p>else条件处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void delete_block(void *bp, size_t asize)&#123;</span><br><span class="line">    int index &#x3D; Index(asize);</span><br><span class="line">    char *prev &#x3D; GET(PREV_LINKED_BLKP(bp));</span><br><span class="line">    char *next &#x3D; GET(NEXT_LINKED_BLKP(bp));</span><br><span class="line">    if(prev &#x3D;&#x3D; list_table+(index*WSIZE))&#123;</span><br><span class="line">        PUT(prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        PUT(NEXT_LINKED_BLKP(prev), next);</span><br><span class="line">    &#125;</span><br><span class="line">    if(next !&#x3D; NULL)&#123;</span><br><span class="line">        PUT(PREV_LINKED_BLKP(next), prev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="error"><a href="#error" class="headerlink" title="error"></a>error</h4><p> conflicting types for ‘x’</p>
<blockquote>
<p>static …</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210228134715629.png#pic_center" alt="在这里插入图片描述"></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/02/21/malloc-lab/" rel="prev" title="malloc-lab">
                  <i class="fa fa-chevron-left"></i> malloc-lab
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/03/17/Daily-learning-and-document-collection/" rel="next" title="Daily learning and document collection">
                  Daily learning and document collection <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">eetan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
